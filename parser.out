Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program_start
Rule 1     program_start -> PROGRAM ID SEMICOL program_start_1 program_start_2 main
Rule 2     program_start_1 -> vars
Rule 3     program_start_2 -> funcs
Rule 4     program_start_2 -> empty
Rule 5     vars -> VAR type COL vars_1 SEMICOL vars
Rule 6     vars -> empty
Rule 7     vars_1 -> ID vars_2 vars_3
Rule 8     vars_2 -> dims
Rule 9     vars_2 -> empty
Rule 10    vars_3 -> COMMA vars_1
Rule 11    vars_3 -> empty
Rule 12    type -> INT
Rule 13    type -> FLOAT
Rule 14    type -> CHAR
Rule 15    type -> BOOL
Rule 16    rtype -> INT
Rule 17    rtype -> FLOAT
Rule 18    rtype -> CHAR
Rule 19    rtype -> BOOL
Rule 20    rtype -> VOID
Rule 21    block -> LCURLY block_1 RCURLY
Rule 22    block_1 -> statement
Rule 23    funcs -> FUNC rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3
Rule 24    funcs_1 -> vars
Rule 25    funcs_2 -> RETURN expression SEMICOL
Rule 26    funcs_2 -> empty
Rule 27    funcs_3 -> funcs
Rule 28    funcs_3 -> empty
Rule 29    params -> LPAR params_1 RPAR
Rule 30    params_1 -> type ID params_2 params_3
Rule 31    params_1 -> empty
Rule 32    params_2 -> dims
Rule 33    params_2 -> empty
Rule 34    params_3 -> COMMA params_1
Rule 35    params_3 -> empty
Rule 36    assign -> ID assign_1 EQUAL expression SEMICOL
Rule 37    assign_1 -> dims
Rule 38    assign_1 -> empty
Rule 39    dims -> LBRACK expression dims_1 RBRACK
Rule 40    dims_1 -> COMMA expression
Rule 41    dims_1 -> empty
Rule 42    statement -> statement_1 statement
Rule 43    statement -> empty
Rule 44    statement_1 -> assign
Rule 45    statement_1 -> cond
Rule 46    statement_1 -> cloop
Rule 47    statement_1 -> nloop
Rule 48    statement_1 -> callfunc
Rule 49    statement_1 -> read
Rule 50    statement_1 -> write
Rule 51    statement_1 -> loadfile
Rule 52    cond -> IF LPAR expression RPAR block cond_1
Rule 53    cond_1 -> ELSE cond_2
Rule 54    cond_2 -> IF LPAR expression RPAR block cond_3
Rule 55    cond_2 -> block
Rule 56    cond_3 -> cond_1
Rule 57    cond_3 -> empty
Rule 58    cloop -> WHILE LPAR expression RPAR block
Rule 59    nloop -> FROM ID nloop_1 nloop_2 TO expression block
Rule 60    nloop_1 -> dims
Rule 61    nloop_1 -> empty
Rule 62    nloop_2 -> EQUAL expression
Rule 63    nloop_2 -> empty
Rule 64    callfunc -> ID LPAR callfunc_1 RPAR
Rule 65    callfunc_1 -> ID callfunc_2 callfunc_3
Rule 66    callfunc_1 -> empty
Rule 67    callfunc_2 -> dims
Rule 68    callfunc_2 -> empty
Rule 69    callfunc_3 -> COMMA callfunc_1
Rule 70    callfunc_3 -> empty
Rule 71    read -> READ LPAR read_1 RPAR SEMICOL
Rule 72    read_1 -> ID read_2 read_3
Rule 73    read_2 -> dims
Rule 74    read_2 -> empty
Rule 75    read_3 -> COMMA read_1
Rule 76    read_3 -> empty
Rule 77    write -> WRITE LPAR write_1 RPAR SEMICOL
Rule 78    write_1 -> write_2 write_3
Rule 79    write_2 -> expression
Rule 80    write_2 -> CTES
Rule 81    write_3 -> COMMA write_1
Rule 82    write_3 -> empty
Rule 83    loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
Rule 84    loadfile_1 -> CTEI
Rule 85    loadfile_1 -> ID
Rule 86    loadfile_2 -> CTEI
Rule 87    loadfile_2 -> ID
Rule 88    expression -> sexp expression_1
Rule 89    expression_1 -> expression_2 expression
Rule 90    expression_1 -> empty
Rule 91    expression_2 -> OR
Rule 92    expression_2 -> AND
Rule 93    sexp -> exp sexp_1
Rule 94    sexp_1 -> sexp_2 exp
Rule 95    sexp_1 -> empty
Rule 96    sexp_2 -> ISEQUAL
Rule 97    sexp_2 -> EQUAL
Rule 98    sexp_2 -> NOTEQUAL
Rule 99    sexp_2 -> GREATERTHAN
Rule 100   sexp_2 -> GREATERORQUAL
Rule 101   sexp_2 -> LESSTHAN
Rule 102   sexp_2 -> LESSOREQUAL
Rule 103   exp -> term exp_1
Rule 104   exp_1 -> exp_2 exp
Rule 105   exp_1 -> empty
Rule 106   exp_2 -> PLUS
Rule 107   exp_2 -> MINUS
Rule 108   term -> factor term_1
Rule 109   term_1 -> term_2 term
Rule 110   term_1 -> empty
Rule 111   term_2 -> TIMES
Rule 112   term_2 -> DIV
Rule 113   factor -> factor_1 factor_2
Rule 114   factor_1 -> ID factor_3
Rule 115   factor_1 -> callfunc
Rule 116   factor_1 -> CTEI
Rule 117   factor_1 -> CTEF
Rule 118   factor_1 -> CTEB
Rule 119   factor_1 -> CTEC
Rule 120   factor_1 -> empty
Rule 121   factor_2 -> LPAR expression RPAR
Rule 122   factor_2 -> empty
Rule 123   factor_3 -> dims
Rule 124   factor_3 -> empty
Rule 125   main -> MAIN LPAR RPAR LCURLY main_1 statement END SEMICOL RCURLY
Rule 126   main_1 -> vars
Rule 127   empty -> <empty>

Terminals, with rules where they appear

AND                  : 92
BOOL                 : 15 19
CHAR                 : 14 18
COL                  : 5
COMMA                : 10 34 40 69 75 81 83 83 83
COMMENT              : 
CTEB                 : 118
CTEC                 : 119
CTEF                 : 117
CTEI                 : 84 86 116
CTES                 : 80 83
DIV                  : 112
ELSE                 : 53
END                  : 125
EQUAL                : 36 62 97
FLOAT                : 13 17
FROM                 : 59
FUNC                 : 23
GREATERORQUAL        : 100
GREATERTHAN          : 99
ID                   : 1 7 23 30 36 59 64 65 72 83 85 87 114
IF                   : 52 54
INT                  : 12 16
ISEQUAL              : 96
LBRACK               : 39
LCURLY               : 21 23 125
LESSOREQUAL          : 102
LESSTHAN             : 101
LOADFILE             : 83
LPAR                 : 29 52 54 58 64 71 77 83 121 125
MAIN                 : 125
MINUS                : 107
NOTEQUAL             : 98
OR                   : 91
PLUS                 : 106
PROGRAM              : 1
RBRACK               : 39
RCURLY               : 21 23 125
READ                 : 71
RETURN               : 25
RPAR                 : 29 52 54 58 64 71 77 83 121 125
SEMICOL              : 1 5 25 36 71 77 83 125
TIMES                : 111
TO                   : 59
VAR                  : 5
VOID                 : 20
WHILE                : 58
WRITE                : 77
error                : 

Nonterminals, with rules where they appear

assign               : 44
assign_1             : 36
block                : 52 54 55 58 59
block_1              : 21
callfunc             : 48 115
callfunc_1           : 64 69
callfunc_2           : 65
callfunc_3           : 65
cloop                : 46
cond                 : 45
cond_1               : 52 56
cond_2               : 53
cond_3               : 54
dims                 : 8 32 37 60 67 73 123
dims_1               : 39
empty                : 4 6 9 11 26 28 31 33 35 38 41 43 57 61 63 66 68 70 74 76 82 90 95 105 110 120 122 124
exp                  : 93 94 104
exp_1                : 103
exp_2                : 104
expression           : 25 36 39 40 52 54 58 59 62 79 89 121
expression_1         : 88
expression_2         : 89
factor               : 108
factor_1             : 113
factor_2             : 113
factor_3             : 114
funcs                : 3 27
funcs_1              : 23
funcs_2              : 23
funcs_3              : 23
loadfile             : 51
loadfile_1           : 83
loadfile_2           : 83
main                 : 1
main_1               : 125
nloop                : 47
nloop_1              : 59
nloop_2              : 59
params               : 23
params_1             : 29 34
params_2             : 30
params_3             : 30
program_start        : 0
program_start_1      : 1
program_start_2      : 1
read                 : 49
read_1               : 71 75
read_2               : 72
read_3               : 72
rtype                : 23
sexp                 : 88
sexp_1               : 93
sexp_2               : 94
statement            : 22 23 42 125
statement_1          : 42
term                 : 103 109
term_1               : 108
term_2               : 109
type                 : 5 30
vars                 : 2 5 24 126
vars_1               : 5 10
vars_2               : 7
vars_3               : 7
write                : 50
write_1              : 77 81
write_2              : 78
write_3              : 78

Parsing method: LALR

state 0

    (0) S' -> . program_start
    (1) program_start -> . PROGRAM ID SEMICOL program_start_1 program_start_2 main

    PROGRAM         shift and go to state 2

    program_start                  shift and go to state 1

state 1

    (0) S' -> program_start .



state 2

    (1) program_start -> PROGRAM . ID SEMICOL program_start_1 program_start_2 main

    ID              shift and go to state 3


state 3

    (1) program_start -> PROGRAM ID . SEMICOL program_start_1 program_start_2 main

    SEMICOL         shift and go to state 4


state 4

    (1) program_start -> PROGRAM ID SEMICOL . program_start_1 program_start_2 main
    (2) program_start_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (127) empty -> .

    VAR             shift and go to state 7
    FUNC            reduce using rule 127 (empty -> .)
    MAIN            reduce using rule 127 (empty -> .)

    program_start_1                shift and go to state 5
    vars                           shift and go to state 6
    empty                          shift and go to state 8

state 5

    (1) program_start -> PROGRAM ID SEMICOL program_start_1 . program_start_2 main
    (3) program_start_2 -> . funcs
    (4) program_start_2 -> . empty
    (23) funcs -> . FUNC rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3
    (127) empty -> .

    FUNC            shift and go to state 12
    MAIN            reduce using rule 127 (empty -> .)

    program_start_2                shift and go to state 9
    funcs                          shift and go to state 10
    empty                          shift and go to state 11

state 6

    (2) program_start_1 -> vars .

    FUNC            reduce using rule 2 (program_start_1 -> vars .)
    MAIN            reduce using rule 2 (program_start_1 -> vars .)


state 7

    (5) vars -> VAR . type COL vars_1 SEMICOL vars
    (12) type -> . INT
    (13) type -> . FLOAT
    (14) type -> . CHAR
    (15) type -> . BOOL

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    BOOL            shift and go to state 17

    type                           shift and go to state 13

state 8

    (6) vars -> empty .

    FUNC            reduce using rule 6 (vars -> empty .)
    MAIN            reduce using rule 6 (vars -> empty .)
    ID              reduce using rule 6 (vars -> empty .)
    IF              reduce using rule 6 (vars -> empty .)
    WHILE           reduce using rule 6 (vars -> empty .)
    FROM            reduce using rule 6 (vars -> empty .)
    READ            reduce using rule 6 (vars -> empty .)
    WRITE           reduce using rule 6 (vars -> empty .)
    LOADFILE        reduce using rule 6 (vars -> empty .)
    END             reduce using rule 6 (vars -> empty .)
    RETURN          reduce using rule 6 (vars -> empty .)
    RCURLY          reduce using rule 6 (vars -> empty .)


state 9

    (1) program_start -> PROGRAM ID SEMICOL program_start_1 program_start_2 . main
    (125) main -> . MAIN LPAR RPAR LCURLY main_1 statement END SEMICOL RCURLY

    MAIN            shift and go to state 19

    main                           shift and go to state 18

state 10

    (3) program_start_2 -> funcs .

    MAIN            reduce using rule 3 (program_start_2 -> funcs .)


state 11

    (4) program_start_2 -> empty .

    MAIN            reduce using rule 4 (program_start_2 -> empty .)


state 12

    (23) funcs -> FUNC . rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3
    (16) rtype -> . INT
    (17) rtype -> . FLOAT
    (18) rtype -> . CHAR
    (19) rtype -> . BOOL
    (20) rtype -> . VOID

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    BOOL            shift and go to state 24
    VOID            shift and go to state 25

    rtype                          shift and go to state 20

state 13

    (5) vars -> VAR type . COL vars_1 SEMICOL vars

    COL             shift and go to state 26


state 14

    (12) type -> INT .

    COL             reduce using rule 12 (type -> INT .)
    ID              reduce using rule 12 (type -> INT .)


state 15

    (13) type -> FLOAT .

    COL             reduce using rule 13 (type -> FLOAT .)
    ID              reduce using rule 13 (type -> FLOAT .)


state 16

    (14) type -> CHAR .

    COL             reduce using rule 14 (type -> CHAR .)
    ID              reduce using rule 14 (type -> CHAR .)


state 17

    (15) type -> BOOL .

    COL             reduce using rule 15 (type -> BOOL .)
    ID              reduce using rule 15 (type -> BOOL .)


state 18

    (1) program_start -> PROGRAM ID SEMICOL program_start_1 program_start_2 main .

    $end            reduce using rule 1 (program_start -> PROGRAM ID SEMICOL program_start_1 program_start_2 main .)


state 19

    (125) main -> MAIN . LPAR RPAR LCURLY main_1 statement END SEMICOL RCURLY

    LPAR            shift and go to state 27


state 20

    (23) funcs -> FUNC rtype . ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3

    ID              shift and go to state 28


state 21

    (16) rtype -> INT .

    ID              reduce using rule 16 (rtype -> INT .)


state 22

    (17) rtype -> FLOAT .

    ID              reduce using rule 17 (rtype -> FLOAT .)


state 23

    (18) rtype -> CHAR .

    ID              reduce using rule 18 (rtype -> CHAR .)


state 24

    (19) rtype -> BOOL .

    ID              reduce using rule 19 (rtype -> BOOL .)


state 25

    (20) rtype -> VOID .

    ID              reduce using rule 20 (rtype -> VOID .)


state 26

    (5) vars -> VAR type COL . vars_1 SEMICOL vars
    (7) vars_1 -> . ID vars_2 vars_3

    ID              shift and go to state 30

    vars_1                         shift and go to state 29

state 27

    (125) main -> MAIN LPAR . RPAR LCURLY main_1 statement END SEMICOL RCURLY

    RPAR            shift and go to state 31


state 28

    (23) funcs -> FUNC rtype ID . params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3
    (29) params -> . LPAR params_1 RPAR

    LPAR            shift and go to state 33

    params                         shift and go to state 32

state 29

    (5) vars -> VAR type COL vars_1 . SEMICOL vars

    SEMICOL         shift and go to state 34


state 30

    (7) vars_1 -> ID . vars_2 vars_3
    (8) vars_2 -> . dims
    (9) vars_2 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

    LBRACK          shift and go to state 38
    COMMA           reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)

    vars_2                         shift and go to state 35
    dims                           shift and go to state 36
    empty                          shift and go to state 37

state 31

    (125) main -> MAIN LPAR RPAR . LCURLY main_1 statement END SEMICOL RCURLY

    LCURLY          shift and go to state 39


state 32

    (23) funcs -> FUNC rtype ID params . LCURLY funcs_1 statement funcs_2 RCURLY funcs_3

    LCURLY          shift and go to state 40


state 33

    (29) params -> LPAR . params_1 RPAR
    (30) params_1 -> . type ID params_2 params_3
    (31) params_1 -> . empty
    (12) type -> . INT
    (13) type -> . FLOAT
    (14) type -> . CHAR
    (15) type -> . BOOL
    (127) empty -> .

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    BOOL            shift and go to state 17
    RPAR            reduce using rule 127 (empty -> .)

    params_1                       shift and go to state 41
    type                           shift and go to state 42
    empty                          shift and go to state 43

state 34

    (5) vars -> VAR type COL vars_1 SEMICOL . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (127) empty -> .

    VAR             shift and go to state 7
    FUNC            reduce using rule 127 (empty -> .)
    MAIN            reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    WRITE           reduce using rule 127 (empty -> .)
    LOADFILE        reduce using rule 127 (empty -> .)
    END             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)

    vars                           shift and go to state 44
    empty                          shift and go to state 8

state 35

    (7) vars_1 -> ID vars_2 . vars_3
    (10) vars_3 -> . COMMA vars_1
    (11) vars_3 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 46
    SEMICOL         reduce using rule 127 (empty -> .)

    vars_3                         shift and go to state 45
    empty                          shift and go to state 47

state 36

    (8) vars_2 -> dims .

    COMMA           reduce using rule 8 (vars_2 -> dims .)
    SEMICOL         reduce using rule 8 (vars_2 -> dims .)


state 37

    (9) vars_2 -> empty .

    COMMA           reduce using rule 9 (vars_2 -> empty .)
    SEMICOL         reduce using rule 9 (vars_2 -> empty .)


state 38

    (39) dims -> LBRACK . expression dims_1 RBRACK
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)

    expression                     shift and go to state 48
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 39

    (125) main -> MAIN LPAR RPAR LCURLY . main_1 statement END SEMICOL RCURLY
    (126) main_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (127) empty -> .

    VAR             shift and go to state 7
    ID              reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    WRITE           reduce using rule 127 (empty -> .)
    LOADFILE        reduce using rule 127 (empty -> .)
    END             reduce using rule 127 (empty -> .)

    main_1                         shift and go to state 61
    vars                           shift and go to state 62
    empty                          shift and go to state 8

state 40

    (23) funcs -> FUNC rtype ID params LCURLY . funcs_1 statement funcs_2 RCURLY funcs_3
    (24) funcs_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (127) empty -> .

    VAR             shift and go to state 7
    ID              reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    WRITE           reduce using rule 127 (empty -> .)
    LOADFILE        reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)

    funcs_1                        shift and go to state 63
    vars                           shift and go to state 64
    empty                          shift and go to state 8

state 41

    (29) params -> LPAR params_1 . RPAR

    RPAR            shift and go to state 65


state 42

    (30) params_1 -> type . ID params_2 params_3

    ID              shift and go to state 66


state 43

    (31) params_1 -> empty .

    RPAR            reduce using rule 31 (params_1 -> empty .)


state 44

    (5) vars -> VAR type COL vars_1 SEMICOL vars .

    FUNC            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    MAIN            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    ID              reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    IF              reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    WHILE           reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    FROM            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    READ            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    WRITE           reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    LOADFILE        reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    END             reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    RETURN          reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    RCURLY          reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)


state 45

    (7) vars_1 -> ID vars_2 vars_3 .

    SEMICOL         reduce using rule 7 (vars_1 -> ID vars_2 vars_3 .)


state 46

    (10) vars_3 -> COMMA . vars_1
    (7) vars_1 -> . ID vars_2 vars_3

    ID              shift and go to state 30

    vars_1                         shift and go to state 67

state 47

    (11) vars_3 -> empty .

    SEMICOL         reduce using rule 11 (vars_3 -> empty .)


state 48

    (39) dims -> LBRACK expression . dims_1 RBRACK
    (40) dims_1 -> . COMMA expression
    (41) dims_1 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 69
    RBRACK          reduce using rule 127 (empty -> .)

    dims_1                         shift and go to state 68
    empty                          shift and go to state 70

state 49

    (88) expression -> sexp . expression_1
    (89) expression_1 -> . expression_2 expression
    (90) expression_1 -> . empty
    (91) expression_2 -> . OR
    (92) expression_2 -> . AND
    (127) empty -> .

    OR              shift and go to state 74
    AND             shift and go to state 75
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    expression_1                   shift and go to state 71
    expression_2                   shift and go to state 72
    empty                          shift and go to state 73

state 50

    (93) sexp -> exp . sexp_1
    (94) sexp_1 -> . sexp_2 exp
    (95) sexp_1 -> . empty
    (96) sexp_2 -> . ISEQUAL
    (97) sexp_2 -> . EQUAL
    (98) sexp_2 -> . NOTEQUAL
    (99) sexp_2 -> . GREATERTHAN
    (100) sexp_2 -> . GREATERORQUAL
    (101) sexp_2 -> . LESSTHAN
    (102) sexp_2 -> . LESSOREQUAL
    (127) empty -> .

    ISEQUAL         shift and go to state 79
    EQUAL           shift and go to state 80
    NOTEQUAL        shift and go to state 81
    GREATERTHAN     shift and go to state 82
    GREATERORQUAL   shift and go to state 83
    LESSTHAN        shift and go to state 84
    LESSOREQUAL     shift and go to state 85
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    sexp_1                         shift and go to state 76
    sexp_2                         shift and go to state 77
    empty                          shift and go to state 78

state 51

    (103) exp -> term . exp_1
    (104) exp_1 -> . exp_2 exp
    (105) exp_1 -> . empty
    (106) exp_2 -> . PLUS
    (107) exp_2 -> . MINUS
    (127) empty -> .

    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    exp_1                          shift and go to state 86
    exp_2                          shift and go to state 87
    empty                          shift and go to state 88

state 52

    (108) term -> factor . term_1
    (109) term_1 -> . term_2 term
    (110) term_1 -> . empty
    (111) term_2 -> . TIMES
    (112) term_2 -> . DIV
    (127) empty -> .

    TIMES           shift and go to state 94
    DIV             shift and go to state 95
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    term_1                         shift and go to state 91
    term_2                         shift and go to state 92
    empty                          shift and go to state 93

state 53

    (113) factor -> factor_1 . factor_2
    (121) factor_2 -> . LPAR expression RPAR
    (122) factor_2 -> . empty
    (127) empty -> .

    LPAR            shift and go to state 97
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    factor_2                       shift and go to state 96
    empty                          shift and go to state 98

state 54

    (114) factor_1 -> ID . factor_3
    (64) callfunc -> ID . LPAR callfunc_1 RPAR
    (123) factor_3 -> . dims
    (124) factor_3 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

  ! shift/reduce conflict for LPAR resolved as shift
    LPAR            shift and go to state 100
    LBRACK          shift and go to state 38
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

  ! LPAR            [ reduce using rule 127 (empty -> .) ]

    factor_3                       shift and go to state 99
    dims                           shift and go to state 101
    empty                          shift and go to state 102

state 55

    (115) factor_1 -> callfunc .

    LPAR            reduce using rule 115 (factor_1 -> callfunc .)
    TIMES           reduce using rule 115 (factor_1 -> callfunc .)
    DIV             reduce using rule 115 (factor_1 -> callfunc .)
    PLUS            reduce using rule 115 (factor_1 -> callfunc .)
    MINUS           reduce using rule 115 (factor_1 -> callfunc .)
    ISEQUAL         reduce using rule 115 (factor_1 -> callfunc .)
    EQUAL           reduce using rule 115 (factor_1 -> callfunc .)
    NOTEQUAL        reduce using rule 115 (factor_1 -> callfunc .)
    GREATERTHAN     reduce using rule 115 (factor_1 -> callfunc .)
    GREATERORQUAL   reduce using rule 115 (factor_1 -> callfunc .)
    LESSTHAN        reduce using rule 115 (factor_1 -> callfunc .)
    LESSOREQUAL     reduce using rule 115 (factor_1 -> callfunc .)
    OR              reduce using rule 115 (factor_1 -> callfunc .)
    AND             reduce using rule 115 (factor_1 -> callfunc .)
    COMMA           reduce using rule 115 (factor_1 -> callfunc .)
    RBRACK          reduce using rule 115 (factor_1 -> callfunc .)
    RPAR            reduce using rule 115 (factor_1 -> callfunc .)
    SEMICOL         reduce using rule 115 (factor_1 -> callfunc .)
    TO              reduce using rule 115 (factor_1 -> callfunc .)
    LCURLY          reduce using rule 115 (factor_1 -> callfunc .)


state 56

    (116) factor_1 -> CTEI .

    LPAR            reduce using rule 116 (factor_1 -> CTEI .)
    TIMES           reduce using rule 116 (factor_1 -> CTEI .)
    DIV             reduce using rule 116 (factor_1 -> CTEI .)
    PLUS            reduce using rule 116 (factor_1 -> CTEI .)
    MINUS           reduce using rule 116 (factor_1 -> CTEI .)
    ISEQUAL         reduce using rule 116 (factor_1 -> CTEI .)
    EQUAL           reduce using rule 116 (factor_1 -> CTEI .)
    NOTEQUAL        reduce using rule 116 (factor_1 -> CTEI .)
    GREATERTHAN     reduce using rule 116 (factor_1 -> CTEI .)
    GREATERORQUAL   reduce using rule 116 (factor_1 -> CTEI .)
    LESSTHAN        reduce using rule 116 (factor_1 -> CTEI .)
    LESSOREQUAL     reduce using rule 116 (factor_1 -> CTEI .)
    OR              reduce using rule 116 (factor_1 -> CTEI .)
    AND             reduce using rule 116 (factor_1 -> CTEI .)
    COMMA           reduce using rule 116 (factor_1 -> CTEI .)
    RBRACK          reduce using rule 116 (factor_1 -> CTEI .)
    RPAR            reduce using rule 116 (factor_1 -> CTEI .)
    SEMICOL         reduce using rule 116 (factor_1 -> CTEI .)
    TO              reduce using rule 116 (factor_1 -> CTEI .)
    LCURLY          reduce using rule 116 (factor_1 -> CTEI .)


state 57

    (117) factor_1 -> CTEF .

    LPAR            reduce using rule 117 (factor_1 -> CTEF .)
    TIMES           reduce using rule 117 (factor_1 -> CTEF .)
    DIV             reduce using rule 117 (factor_1 -> CTEF .)
    PLUS            reduce using rule 117 (factor_1 -> CTEF .)
    MINUS           reduce using rule 117 (factor_1 -> CTEF .)
    ISEQUAL         reduce using rule 117 (factor_1 -> CTEF .)
    EQUAL           reduce using rule 117 (factor_1 -> CTEF .)
    NOTEQUAL        reduce using rule 117 (factor_1 -> CTEF .)
    GREATERTHAN     reduce using rule 117 (factor_1 -> CTEF .)
    GREATERORQUAL   reduce using rule 117 (factor_1 -> CTEF .)
    LESSTHAN        reduce using rule 117 (factor_1 -> CTEF .)
    LESSOREQUAL     reduce using rule 117 (factor_1 -> CTEF .)
    OR              reduce using rule 117 (factor_1 -> CTEF .)
    AND             reduce using rule 117 (factor_1 -> CTEF .)
    COMMA           reduce using rule 117 (factor_1 -> CTEF .)
    RBRACK          reduce using rule 117 (factor_1 -> CTEF .)
    RPAR            reduce using rule 117 (factor_1 -> CTEF .)
    SEMICOL         reduce using rule 117 (factor_1 -> CTEF .)
    TO              reduce using rule 117 (factor_1 -> CTEF .)
    LCURLY          reduce using rule 117 (factor_1 -> CTEF .)


state 58

    (118) factor_1 -> CTEB .

    LPAR            reduce using rule 118 (factor_1 -> CTEB .)
    TIMES           reduce using rule 118 (factor_1 -> CTEB .)
    DIV             reduce using rule 118 (factor_1 -> CTEB .)
    PLUS            reduce using rule 118 (factor_1 -> CTEB .)
    MINUS           reduce using rule 118 (factor_1 -> CTEB .)
    ISEQUAL         reduce using rule 118 (factor_1 -> CTEB .)
    EQUAL           reduce using rule 118 (factor_1 -> CTEB .)
    NOTEQUAL        reduce using rule 118 (factor_1 -> CTEB .)
    GREATERTHAN     reduce using rule 118 (factor_1 -> CTEB .)
    GREATERORQUAL   reduce using rule 118 (factor_1 -> CTEB .)
    LESSTHAN        reduce using rule 118 (factor_1 -> CTEB .)
    LESSOREQUAL     reduce using rule 118 (factor_1 -> CTEB .)
    OR              reduce using rule 118 (factor_1 -> CTEB .)
    AND             reduce using rule 118 (factor_1 -> CTEB .)
    COMMA           reduce using rule 118 (factor_1 -> CTEB .)
    RBRACK          reduce using rule 118 (factor_1 -> CTEB .)
    RPAR            reduce using rule 118 (factor_1 -> CTEB .)
    SEMICOL         reduce using rule 118 (factor_1 -> CTEB .)
    TO              reduce using rule 118 (factor_1 -> CTEB .)
    LCURLY          reduce using rule 118 (factor_1 -> CTEB .)


state 59

    (119) factor_1 -> CTEC .

    LPAR            reduce using rule 119 (factor_1 -> CTEC .)
    TIMES           reduce using rule 119 (factor_1 -> CTEC .)
    DIV             reduce using rule 119 (factor_1 -> CTEC .)
    PLUS            reduce using rule 119 (factor_1 -> CTEC .)
    MINUS           reduce using rule 119 (factor_1 -> CTEC .)
    ISEQUAL         reduce using rule 119 (factor_1 -> CTEC .)
    EQUAL           reduce using rule 119 (factor_1 -> CTEC .)
    NOTEQUAL        reduce using rule 119 (factor_1 -> CTEC .)
    GREATERTHAN     reduce using rule 119 (factor_1 -> CTEC .)
    GREATERORQUAL   reduce using rule 119 (factor_1 -> CTEC .)
    LESSTHAN        reduce using rule 119 (factor_1 -> CTEC .)
    LESSOREQUAL     reduce using rule 119 (factor_1 -> CTEC .)
    OR              reduce using rule 119 (factor_1 -> CTEC .)
    AND             reduce using rule 119 (factor_1 -> CTEC .)
    COMMA           reduce using rule 119 (factor_1 -> CTEC .)
    RBRACK          reduce using rule 119 (factor_1 -> CTEC .)
    RPAR            reduce using rule 119 (factor_1 -> CTEC .)
    SEMICOL         reduce using rule 119 (factor_1 -> CTEC .)
    TO              reduce using rule 119 (factor_1 -> CTEC .)
    LCURLY          reduce using rule 119 (factor_1 -> CTEC .)


state 60

    (120) factor_1 -> empty .

    LPAR            reduce using rule 120 (factor_1 -> empty .)
    TIMES           reduce using rule 120 (factor_1 -> empty .)
    DIV             reduce using rule 120 (factor_1 -> empty .)
    PLUS            reduce using rule 120 (factor_1 -> empty .)
    MINUS           reduce using rule 120 (factor_1 -> empty .)
    ISEQUAL         reduce using rule 120 (factor_1 -> empty .)
    EQUAL           reduce using rule 120 (factor_1 -> empty .)
    NOTEQUAL        reduce using rule 120 (factor_1 -> empty .)
    GREATERTHAN     reduce using rule 120 (factor_1 -> empty .)
    GREATERORQUAL   reduce using rule 120 (factor_1 -> empty .)
    LESSTHAN        reduce using rule 120 (factor_1 -> empty .)
    LESSOREQUAL     reduce using rule 120 (factor_1 -> empty .)
    OR              reduce using rule 120 (factor_1 -> empty .)
    AND             reduce using rule 120 (factor_1 -> empty .)
    COMMA           reduce using rule 120 (factor_1 -> empty .)
    RBRACK          reduce using rule 120 (factor_1 -> empty .)
    RPAR            reduce using rule 120 (factor_1 -> empty .)
    SEMICOL         reduce using rule 120 (factor_1 -> empty .)
    TO              reduce using rule 120 (factor_1 -> empty .)
    LCURLY          reduce using rule 120 (factor_1 -> empty .)


state 61

    (125) main -> MAIN LPAR RPAR LCURLY main_1 . statement END SEMICOL RCURLY
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . callfunc
    (49) statement_1 -> . read
    (50) statement_1 -> . write
    (51) statement_1 -> . loadfile
    (127) empty -> .
    (36) assign -> . ID assign_1 EQUAL expression SEMICOL
    (52) cond -> . IF LPAR expression RPAR block cond_1
    (58) cloop -> . WHILE LPAR expression RPAR block
    (59) nloop -> . FROM ID nloop_1 nloop_2 TO expression block
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (71) read -> . READ LPAR read_1 RPAR SEMICOL
    (77) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (83) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    END             reduce using rule 127 (empty -> .)
    ID              shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    FROM            shift and go to state 117
    READ            shift and go to state 118
    WRITE           shift and go to state 119
    LOADFILE        shift and go to state 120

    statement                      shift and go to state 103
    statement_1                    shift and go to state 104
    empty                          shift and go to state 105
    assign                         shift and go to state 106
    cond                           shift and go to state 107
    cloop                          shift and go to state 108
    nloop                          shift and go to state 109
    callfunc                       shift and go to state 110
    read                           shift and go to state 111
    write                          shift and go to state 112
    loadfile                       shift and go to state 113

state 62

    (126) main_1 -> vars .

    ID              reduce using rule 126 (main_1 -> vars .)
    IF              reduce using rule 126 (main_1 -> vars .)
    WHILE           reduce using rule 126 (main_1 -> vars .)
    FROM            reduce using rule 126 (main_1 -> vars .)
    READ            reduce using rule 126 (main_1 -> vars .)
    WRITE           reduce using rule 126 (main_1 -> vars .)
    LOADFILE        reduce using rule 126 (main_1 -> vars .)
    END             reduce using rule 126 (main_1 -> vars .)


state 63

    (23) funcs -> FUNC rtype ID params LCURLY funcs_1 . statement funcs_2 RCURLY funcs_3
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . callfunc
    (49) statement_1 -> . read
    (50) statement_1 -> . write
    (51) statement_1 -> . loadfile
    (127) empty -> .
    (36) assign -> . ID assign_1 EQUAL expression SEMICOL
    (52) cond -> . IF LPAR expression RPAR block cond_1
    (58) cloop -> . WHILE LPAR expression RPAR block
    (59) nloop -> . FROM ID nloop_1 nloop_2 TO expression block
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (71) read -> . READ LPAR read_1 RPAR SEMICOL
    (77) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (83) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    RETURN          reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)
    ID              shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    FROM            shift and go to state 117
    READ            shift and go to state 118
    WRITE           shift and go to state 119
    LOADFILE        shift and go to state 120

    statement                      shift and go to state 121
    statement_1                    shift and go to state 104
    empty                          shift and go to state 105
    assign                         shift and go to state 106
    cond                           shift and go to state 107
    cloop                          shift and go to state 108
    nloop                          shift and go to state 109
    callfunc                       shift and go to state 110
    read                           shift and go to state 111
    write                          shift and go to state 112
    loadfile                       shift and go to state 113

state 64

    (24) funcs_1 -> vars .

    ID              reduce using rule 24 (funcs_1 -> vars .)
    IF              reduce using rule 24 (funcs_1 -> vars .)
    WHILE           reduce using rule 24 (funcs_1 -> vars .)
    FROM            reduce using rule 24 (funcs_1 -> vars .)
    READ            reduce using rule 24 (funcs_1 -> vars .)
    WRITE           reduce using rule 24 (funcs_1 -> vars .)
    LOADFILE        reduce using rule 24 (funcs_1 -> vars .)
    RETURN          reduce using rule 24 (funcs_1 -> vars .)
    RCURLY          reduce using rule 24 (funcs_1 -> vars .)


state 65

    (29) params -> LPAR params_1 RPAR .

    LCURLY          reduce using rule 29 (params -> LPAR params_1 RPAR .)


state 66

    (30) params_1 -> type ID . params_2 params_3
    (32) params_2 -> . dims
    (33) params_2 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

    LBRACK          shift and go to state 38
    COMMA           reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    params_2                       shift and go to state 122
    dims                           shift and go to state 123
    empty                          shift and go to state 124

state 67

    (10) vars_3 -> COMMA vars_1 .

    SEMICOL         reduce using rule 10 (vars_3 -> COMMA vars_1 .)


state 68

    (39) dims -> LBRACK expression dims_1 . RBRACK

    RBRACK          shift and go to state 125


state 69

    (40) dims_1 -> COMMA . expression
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)

    expression                     shift and go to state 126
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 70

    (41) dims_1 -> empty .

    RBRACK          reduce using rule 41 (dims_1 -> empty .)


state 71

    (88) expression -> sexp expression_1 .

    COMMA           reduce using rule 88 (expression -> sexp expression_1 .)
    RBRACK          reduce using rule 88 (expression -> sexp expression_1 .)
    RPAR            reduce using rule 88 (expression -> sexp expression_1 .)
    SEMICOL         reduce using rule 88 (expression -> sexp expression_1 .)
    TO              reduce using rule 88 (expression -> sexp expression_1 .)
    LCURLY          reduce using rule 88 (expression -> sexp expression_1 .)


state 72

    (89) expression_1 -> expression_2 . expression
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    expression                     shift and go to state 127
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 73

    (90) expression_1 -> empty .

    COMMA           reduce using rule 90 (expression_1 -> empty .)
    RBRACK          reduce using rule 90 (expression_1 -> empty .)
    RPAR            reduce using rule 90 (expression_1 -> empty .)
    SEMICOL         reduce using rule 90 (expression_1 -> empty .)
    TO              reduce using rule 90 (expression_1 -> empty .)
    LCURLY          reduce using rule 90 (expression_1 -> empty .)


state 74

    (91) expression_2 -> OR .

    ID              reduce using rule 91 (expression_2 -> OR .)
    CTEI            reduce using rule 91 (expression_2 -> OR .)
    CTEF            reduce using rule 91 (expression_2 -> OR .)
    CTEB            reduce using rule 91 (expression_2 -> OR .)
    CTEC            reduce using rule 91 (expression_2 -> OR .)
    OR              reduce using rule 91 (expression_2 -> OR .)
    AND             reduce using rule 91 (expression_2 -> OR .)
    ISEQUAL         reduce using rule 91 (expression_2 -> OR .)
    EQUAL           reduce using rule 91 (expression_2 -> OR .)
    NOTEQUAL        reduce using rule 91 (expression_2 -> OR .)
    GREATERTHAN     reduce using rule 91 (expression_2 -> OR .)
    GREATERORQUAL   reduce using rule 91 (expression_2 -> OR .)
    LESSTHAN        reduce using rule 91 (expression_2 -> OR .)
    LESSOREQUAL     reduce using rule 91 (expression_2 -> OR .)
    PLUS            reduce using rule 91 (expression_2 -> OR .)
    MINUS           reduce using rule 91 (expression_2 -> OR .)
    TIMES           reduce using rule 91 (expression_2 -> OR .)
    DIV             reduce using rule 91 (expression_2 -> OR .)
    LPAR            reduce using rule 91 (expression_2 -> OR .)
    COMMA           reduce using rule 91 (expression_2 -> OR .)
    RBRACK          reduce using rule 91 (expression_2 -> OR .)
    RPAR            reduce using rule 91 (expression_2 -> OR .)
    SEMICOL         reduce using rule 91 (expression_2 -> OR .)
    TO              reduce using rule 91 (expression_2 -> OR .)
    LCURLY          reduce using rule 91 (expression_2 -> OR .)


state 75

    (92) expression_2 -> AND .

    ID              reduce using rule 92 (expression_2 -> AND .)
    CTEI            reduce using rule 92 (expression_2 -> AND .)
    CTEF            reduce using rule 92 (expression_2 -> AND .)
    CTEB            reduce using rule 92 (expression_2 -> AND .)
    CTEC            reduce using rule 92 (expression_2 -> AND .)
    OR              reduce using rule 92 (expression_2 -> AND .)
    AND             reduce using rule 92 (expression_2 -> AND .)
    ISEQUAL         reduce using rule 92 (expression_2 -> AND .)
    EQUAL           reduce using rule 92 (expression_2 -> AND .)
    NOTEQUAL        reduce using rule 92 (expression_2 -> AND .)
    GREATERTHAN     reduce using rule 92 (expression_2 -> AND .)
    GREATERORQUAL   reduce using rule 92 (expression_2 -> AND .)
    LESSTHAN        reduce using rule 92 (expression_2 -> AND .)
    LESSOREQUAL     reduce using rule 92 (expression_2 -> AND .)
    PLUS            reduce using rule 92 (expression_2 -> AND .)
    MINUS           reduce using rule 92 (expression_2 -> AND .)
    TIMES           reduce using rule 92 (expression_2 -> AND .)
    DIV             reduce using rule 92 (expression_2 -> AND .)
    LPAR            reduce using rule 92 (expression_2 -> AND .)
    COMMA           reduce using rule 92 (expression_2 -> AND .)
    RBRACK          reduce using rule 92 (expression_2 -> AND .)
    RPAR            reduce using rule 92 (expression_2 -> AND .)
    SEMICOL         reduce using rule 92 (expression_2 -> AND .)
    TO              reduce using rule 92 (expression_2 -> AND .)
    LCURLY          reduce using rule 92 (expression_2 -> AND .)


state 76

    (93) sexp -> exp sexp_1 .

    OR              reduce using rule 93 (sexp -> exp sexp_1 .)
    AND             reduce using rule 93 (sexp -> exp sexp_1 .)
    COMMA           reduce using rule 93 (sexp -> exp sexp_1 .)
    RBRACK          reduce using rule 93 (sexp -> exp sexp_1 .)
    RPAR            reduce using rule 93 (sexp -> exp sexp_1 .)
    SEMICOL         reduce using rule 93 (sexp -> exp sexp_1 .)
    TO              reduce using rule 93 (sexp -> exp sexp_1 .)
    LCURLY          reduce using rule 93 (sexp -> exp sexp_1 .)


state 77

    (94) sexp_1 -> sexp_2 . exp
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    exp                            shift and go to state 128
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 78

    (95) sexp_1 -> empty .

    OR              reduce using rule 95 (sexp_1 -> empty .)
    AND             reduce using rule 95 (sexp_1 -> empty .)
    COMMA           reduce using rule 95 (sexp_1 -> empty .)
    RBRACK          reduce using rule 95 (sexp_1 -> empty .)
    RPAR            reduce using rule 95 (sexp_1 -> empty .)
    SEMICOL         reduce using rule 95 (sexp_1 -> empty .)
    TO              reduce using rule 95 (sexp_1 -> empty .)
    LCURLY          reduce using rule 95 (sexp_1 -> empty .)


state 79

    (96) sexp_2 -> ISEQUAL .

    ID              reduce using rule 96 (sexp_2 -> ISEQUAL .)
    CTEI            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    CTEF            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    CTEB            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    CTEC            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    PLUS            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    MINUS           reduce using rule 96 (sexp_2 -> ISEQUAL .)
    TIMES           reduce using rule 96 (sexp_2 -> ISEQUAL .)
    DIV             reduce using rule 96 (sexp_2 -> ISEQUAL .)
    LPAR            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    OR              reduce using rule 96 (sexp_2 -> ISEQUAL .)
    AND             reduce using rule 96 (sexp_2 -> ISEQUAL .)
    COMMA           reduce using rule 96 (sexp_2 -> ISEQUAL .)
    RBRACK          reduce using rule 96 (sexp_2 -> ISEQUAL .)
    RPAR            reduce using rule 96 (sexp_2 -> ISEQUAL .)
    SEMICOL         reduce using rule 96 (sexp_2 -> ISEQUAL .)
    TO              reduce using rule 96 (sexp_2 -> ISEQUAL .)
    LCURLY          reduce using rule 96 (sexp_2 -> ISEQUAL .)


state 80

    (97) sexp_2 -> EQUAL .

    ID              reduce using rule 97 (sexp_2 -> EQUAL .)
    CTEI            reduce using rule 97 (sexp_2 -> EQUAL .)
    CTEF            reduce using rule 97 (sexp_2 -> EQUAL .)
    CTEB            reduce using rule 97 (sexp_2 -> EQUAL .)
    CTEC            reduce using rule 97 (sexp_2 -> EQUAL .)
    PLUS            reduce using rule 97 (sexp_2 -> EQUAL .)
    MINUS           reduce using rule 97 (sexp_2 -> EQUAL .)
    TIMES           reduce using rule 97 (sexp_2 -> EQUAL .)
    DIV             reduce using rule 97 (sexp_2 -> EQUAL .)
    LPAR            reduce using rule 97 (sexp_2 -> EQUAL .)
    OR              reduce using rule 97 (sexp_2 -> EQUAL .)
    AND             reduce using rule 97 (sexp_2 -> EQUAL .)
    COMMA           reduce using rule 97 (sexp_2 -> EQUAL .)
    RBRACK          reduce using rule 97 (sexp_2 -> EQUAL .)
    RPAR            reduce using rule 97 (sexp_2 -> EQUAL .)
    SEMICOL         reduce using rule 97 (sexp_2 -> EQUAL .)
    TO              reduce using rule 97 (sexp_2 -> EQUAL .)
    LCURLY          reduce using rule 97 (sexp_2 -> EQUAL .)


state 81

    (98) sexp_2 -> NOTEQUAL .

    ID              reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    CTEI            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    CTEF            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    CTEB            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    CTEC            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    PLUS            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    MINUS           reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    TIMES           reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    DIV             reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    LPAR            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    OR              reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    AND             reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    COMMA           reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    RBRACK          reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    RPAR            reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    SEMICOL         reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    TO              reduce using rule 98 (sexp_2 -> NOTEQUAL .)
    LCURLY          reduce using rule 98 (sexp_2 -> NOTEQUAL .)


state 82

    (99) sexp_2 -> GREATERTHAN .

    ID              reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    CTEI            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    CTEF            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    CTEB            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    CTEC            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    PLUS            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    MINUS           reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    TIMES           reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    DIV             reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    LPAR            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    OR              reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    AND             reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    COMMA           reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    RBRACK          reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    RPAR            reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    SEMICOL         reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    TO              reduce using rule 99 (sexp_2 -> GREATERTHAN .)
    LCURLY          reduce using rule 99 (sexp_2 -> GREATERTHAN .)


state 83

    (100) sexp_2 -> GREATERORQUAL .

    ID              reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    CTEI            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    CTEF            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    CTEB            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    CTEC            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    PLUS            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    MINUS           reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    TIMES           reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    DIV             reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    LPAR            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    OR              reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    AND             reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    COMMA           reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    RBRACK          reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    RPAR            reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    SEMICOL         reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    TO              reduce using rule 100 (sexp_2 -> GREATERORQUAL .)
    LCURLY          reduce using rule 100 (sexp_2 -> GREATERORQUAL .)


state 84

    (101) sexp_2 -> LESSTHAN .

    ID              reduce using rule 101 (sexp_2 -> LESSTHAN .)
    CTEI            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    CTEF            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    CTEB            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    CTEC            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    PLUS            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    MINUS           reduce using rule 101 (sexp_2 -> LESSTHAN .)
    TIMES           reduce using rule 101 (sexp_2 -> LESSTHAN .)
    DIV             reduce using rule 101 (sexp_2 -> LESSTHAN .)
    LPAR            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    OR              reduce using rule 101 (sexp_2 -> LESSTHAN .)
    AND             reduce using rule 101 (sexp_2 -> LESSTHAN .)
    COMMA           reduce using rule 101 (sexp_2 -> LESSTHAN .)
    RBRACK          reduce using rule 101 (sexp_2 -> LESSTHAN .)
    RPAR            reduce using rule 101 (sexp_2 -> LESSTHAN .)
    SEMICOL         reduce using rule 101 (sexp_2 -> LESSTHAN .)
    TO              reduce using rule 101 (sexp_2 -> LESSTHAN .)
    LCURLY          reduce using rule 101 (sexp_2 -> LESSTHAN .)


state 85

    (102) sexp_2 -> LESSOREQUAL .

    ID              reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    CTEI            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    CTEF            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    CTEB            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    CTEC            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    PLUS            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    MINUS           reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    TIMES           reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    DIV             reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    LPAR            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    OR              reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    AND             reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    COMMA           reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    RBRACK          reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    RPAR            reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    SEMICOL         reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    TO              reduce using rule 102 (sexp_2 -> LESSOREQUAL .)
    LCURLY          reduce using rule 102 (sexp_2 -> LESSOREQUAL .)


state 86

    (103) exp -> term exp_1 .

    ISEQUAL         reduce using rule 103 (exp -> term exp_1 .)
    EQUAL           reduce using rule 103 (exp -> term exp_1 .)
    NOTEQUAL        reduce using rule 103 (exp -> term exp_1 .)
    GREATERTHAN     reduce using rule 103 (exp -> term exp_1 .)
    GREATERORQUAL   reduce using rule 103 (exp -> term exp_1 .)
    LESSTHAN        reduce using rule 103 (exp -> term exp_1 .)
    LESSOREQUAL     reduce using rule 103 (exp -> term exp_1 .)
    OR              reduce using rule 103 (exp -> term exp_1 .)
    AND             reduce using rule 103 (exp -> term exp_1 .)
    COMMA           reduce using rule 103 (exp -> term exp_1 .)
    RBRACK          reduce using rule 103 (exp -> term exp_1 .)
    RPAR            reduce using rule 103 (exp -> term exp_1 .)
    SEMICOL         reduce using rule 103 (exp -> term exp_1 .)
    TO              reduce using rule 103 (exp -> term exp_1 .)
    LCURLY          reduce using rule 103 (exp -> term exp_1 .)


state 87

    (104) exp_1 -> exp_2 . exp
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    exp                            shift and go to state 129
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 88

    (105) exp_1 -> empty .

    ISEQUAL         reduce using rule 105 (exp_1 -> empty .)
    EQUAL           reduce using rule 105 (exp_1 -> empty .)
    NOTEQUAL        reduce using rule 105 (exp_1 -> empty .)
    GREATERTHAN     reduce using rule 105 (exp_1 -> empty .)
    GREATERORQUAL   reduce using rule 105 (exp_1 -> empty .)
    LESSTHAN        reduce using rule 105 (exp_1 -> empty .)
    LESSOREQUAL     reduce using rule 105 (exp_1 -> empty .)
    OR              reduce using rule 105 (exp_1 -> empty .)
    AND             reduce using rule 105 (exp_1 -> empty .)
    COMMA           reduce using rule 105 (exp_1 -> empty .)
    RBRACK          reduce using rule 105 (exp_1 -> empty .)
    RPAR            reduce using rule 105 (exp_1 -> empty .)
    SEMICOL         reduce using rule 105 (exp_1 -> empty .)
    TO              reduce using rule 105 (exp_1 -> empty .)
    LCURLY          reduce using rule 105 (exp_1 -> empty .)


state 89

    (106) exp_2 -> PLUS .

    ID              reduce using rule 106 (exp_2 -> PLUS .)
    CTEI            reduce using rule 106 (exp_2 -> PLUS .)
    CTEF            reduce using rule 106 (exp_2 -> PLUS .)
    CTEB            reduce using rule 106 (exp_2 -> PLUS .)
    CTEC            reduce using rule 106 (exp_2 -> PLUS .)
    PLUS            reduce using rule 106 (exp_2 -> PLUS .)
    MINUS           reduce using rule 106 (exp_2 -> PLUS .)
    TIMES           reduce using rule 106 (exp_2 -> PLUS .)
    DIV             reduce using rule 106 (exp_2 -> PLUS .)
    LPAR            reduce using rule 106 (exp_2 -> PLUS .)
    ISEQUAL         reduce using rule 106 (exp_2 -> PLUS .)
    EQUAL           reduce using rule 106 (exp_2 -> PLUS .)
    NOTEQUAL        reduce using rule 106 (exp_2 -> PLUS .)
    GREATERTHAN     reduce using rule 106 (exp_2 -> PLUS .)
    GREATERORQUAL   reduce using rule 106 (exp_2 -> PLUS .)
    LESSTHAN        reduce using rule 106 (exp_2 -> PLUS .)
    LESSOREQUAL     reduce using rule 106 (exp_2 -> PLUS .)
    OR              reduce using rule 106 (exp_2 -> PLUS .)
    AND             reduce using rule 106 (exp_2 -> PLUS .)
    COMMA           reduce using rule 106 (exp_2 -> PLUS .)
    RBRACK          reduce using rule 106 (exp_2 -> PLUS .)
    RPAR            reduce using rule 106 (exp_2 -> PLUS .)
    SEMICOL         reduce using rule 106 (exp_2 -> PLUS .)
    TO              reduce using rule 106 (exp_2 -> PLUS .)
    LCURLY          reduce using rule 106 (exp_2 -> PLUS .)


state 90

    (107) exp_2 -> MINUS .

    ID              reduce using rule 107 (exp_2 -> MINUS .)
    CTEI            reduce using rule 107 (exp_2 -> MINUS .)
    CTEF            reduce using rule 107 (exp_2 -> MINUS .)
    CTEB            reduce using rule 107 (exp_2 -> MINUS .)
    CTEC            reduce using rule 107 (exp_2 -> MINUS .)
    PLUS            reduce using rule 107 (exp_2 -> MINUS .)
    MINUS           reduce using rule 107 (exp_2 -> MINUS .)
    TIMES           reduce using rule 107 (exp_2 -> MINUS .)
    DIV             reduce using rule 107 (exp_2 -> MINUS .)
    LPAR            reduce using rule 107 (exp_2 -> MINUS .)
    ISEQUAL         reduce using rule 107 (exp_2 -> MINUS .)
    EQUAL           reduce using rule 107 (exp_2 -> MINUS .)
    NOTEQUAL        reduce using rule 107 (exp_2 -> MINUS .)
    GREATERTHAN     reduce using rule 107 (exp_2 -> MINUS .)
    GREATERORQUAL   reduce using rule 107 (exp_2 -> MINUS .)
    LESSTHAN        reduce using rule 107 (exp_2 -> MINUS .)
    LESSOREQUAL     reduce using rule 107 (exp_2 -> MINUS .)
    OR              reduce using rule 107 (exp_2 -> MINUS .)
    AND             reduce using rule 107 (exp_2 -> MINUS .)
    COMMA           reduce using rule 107 (exp_2 -> MINUS .)
    RBRACK          reduce using rule 107 (exp_2 -> MINUS .)
    RPAR            reduce using rule 107 (exp_2 -> MINUS .)
    SEMICOL         reduce using rule 107 (exp_2 -> MINUS .)
    TO              reduce using rule 107 (exp_2 -> MINUS .)
    LCURLY          reduce using rule 107 (exp_2 -> MINUS .)


state 91

    (108) term -> factor term_1 .

    PLUS            reduce using rule 108 (term -> factor term_1 .)
    MINUS           reduce using rule 108 (term -> factor term_1 .)
    ISEQUAL         reduce using rule 108 (term -> factor term_1 .)
    EQUAL           reduce using rule 108 (term -> factor term_1 .)
    NOTEQUAL        reduce using rule 108 (term -> factor term_1 .)
    GREATERTHAN     reduce using rule 108 (term -> factor term_1 .)
    GREATERORQUAL   reduce using rule 108 (term -> factor term_1 .)
    LESSTHAN        reduce using rule 108 (term -> factor term_1 .)
    LESSOREQUAL     reduce using rule 108 (term -> factor term_1 .)
    OR              reduce using rule 108 (term -> factor term_1 .)
    AND             reduce using rule 108 (term -> factor term_1 .)
    COMMA           reduce using rule 108 (term -> factor term_1 .)
    RBRACK          reduce using rule 108 (term -> factor term_1 .)
    RPAR            reduce using rule 108 (term -> factor term_1 .)
    SEMICOL         reduce using rule 108 (term -> factor term_1 .)
    TO              reduce using rule 108 (term -> factor term_1 .)
    LCURLY          reduce using rule 108 (term -> factor term_1 .)


state 92

    (109) term_1 -> term_2 . term
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RBRACK          reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    term                           shift and go to state 130
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 93

    (110) term_1 -> empty .

    PLUS            reduce using rule 110 (term_1 -> empty .)
    MINUS           reduce using rule 110 (term_1 -> empty .)
    ISEQUAL         reduce using rule 110 (term_1 -> empty .)
    EQUAL           reduce using rule 110 (term_1 -> empty .)
    NOTEQUAL        reduce using rule 110 (term_1 -> empty .)
    GREATERTHAN     reduce using rule 110 (term_1 -> empty .)
    GREATERORQUAL   reduce using rule 110 (term_1 -> empty .)
    LESSTHAN        reduce using rule 110 (term_1 -> empty .)
    LESSOREQUAL     reduce using rule 110 (term_1 -> empty .)
    OR              reduce using rule 110 (term_1 -> empty .)
    AND             reduce using rule 110 (term_1 -> empty .)
    COMMA           reduce using rule 110 (term_1 -> empty .)
    RBRACK          reduce using rule 110 (term_1 -> empty .)
    RPAR            reduce using rule 110 (term_1 -> empty .)
    SEMICOL         reduce using rule 110 (term_1 -> empty .)
    TO              reduce using rule 110 (term_1 -> empty .)
    LCURLY          reduce using rule 110 (term_1 -> empty .)


state 94

    (111) term_2 -> TIMES .

    ID              reduce using rule 111 (term_2 -> TIMES .)
    CTEI            reduce using rule 111 (term_2 -> TIMES .)
    CTEF            reduce using rule 111 (term_2 -> TIMES .)
    CTEB            reduce using rule 111 (term_2 -> TIMES .)
    CTEC            reduce using rule 111 (term_2 -> TIMES .)
    TIMES           reduce using rule 111 (term_2 -> TIMES .)
    DIV             reduce using rule 111 (term_2 -> TIMES .)
    LPAR            reduce using rule 111 (term_2 -> TIMES .)
    PLUS            reduce using rule 111 (term_2 -> TIMES .)
    MINUS           reduce using rule 111 (term_2 -> TIMES .)
    ISEQUAL         reduce using rule 111 (term_2 -> TIMES .)
    EQUAL           reduce using rule 111 (term_2 -> TIMES .)
    NOTEQUAL        reduce using rule 111 (term_2 -> TIMES .)
    GREATERTHAN     reduce using rule 111 (term_2 -> TIMES .)
    GREATERORQUAL   reduce using rule 111 (term_2 -> TIMES .)
    LESSTHAN        reduce using rule 111 (term_2 -> TIMES .)
    LESSOREQUAL     reduce using rule 111 (term_2 -> TIMES .)
    OR              reduce using rule 111 (term_2 -> TIMES .)
    AND             reduce using rule 111 (term_2 -> TIMES .)
    COMMA           reduce using rule 111 (term_2 -> TIMES .)
    RBRACK          reduce using rule 111 (term_2 -> TIMES .)
    RPAR            reduce using rule 111 (term_2 -> TIMES .)
    SEMICOL         reduce using rule 111 (term_2 -> TIMES .)
    TO              reduce using rule 111 (term_2 -> TIMES .)
    LCURLY          reduce using rule 111 (term_2 -> TIMES .)


state 95

    (112) term_2 -> DIV .

    ID              reduce using rule 112 (term_2 -> DIV .)
    CTEI            reduce using rule 112 (term_2 -> DIV .)
    CTEF            reduce using rule 112 (term_2 -> DIV .)
    CTEB            reduce using rule 112 (term_2 -> DIV .)
    CTEC            reduce using rule 112 (term_2 -> DIV .)
    TIMES           reduce using rule 112 (term_2 -> DIV .)
    DIV             reduce using rule 112 (term_2 -> DIV .)
    LPAR            reduce using rule 112 (term_2 -> DIV .)
    PLUS            reduce using rule 112 (term_2 -> DIV .)
    MINUS           reduce using rule 112 (term_2 -> DIV .)
    ISEQUAL         reduce using rule 112 (term_2 -> DIV .)
    EQUAL           reduce using rule 112 (term_2 -> DIV .)
    NOTEQUAL        reduce using rule 112 (term_2 -> DIV .)
    GREATERTHAN     reduce using rule 112 (term_2 -> DIV .)
    GREATERORQUAL   reduce using rule 112 (term_2 -> DIV .)
    LESSTHAN        reduce using rule 112 (term_2 -> DIV .)
    LESSOREQUAL     reduce using rule 112 (term_2 -> DIV .)
    OR              reduce using rule 112 (term_2 -> DIV .)
    AND             reduce using rule 112 (term_2 -> DIV .)
    COMMA           reduce using rule 112 (term_2 -> DIV .)
    RBRACK          reduce using rule 112 (term_2 -> DIV .)
    RPAR            reduce using rule 112 (term_2 -> DIV .)
    SEMICOL         reduce using rule 112 (term_2 -> DIV .)
    TO              reduce using rule 112 (term_2 -> DIV .)
    LCURLY          reduce using rule 112 (term_2 -> DIV .)


state 96

    (113) factor -> factor_1 factor_2 .

    TIMES           reduce using rule 113 (factor -> factor_1 factor_2 .)
    DIV             reduce using rule 113 (factor -> factor_1 factor_2 .)
    PLUS            reduce using rule 113 (factor -> factor_1 factor_2 .)
    MINUS           reduce using rule 113 (factor -> factor_1 factor_2 .)
    ISEQUAL         reduce using rule 113 (factor -> factor_1 factor_2 .)
    EQUAL           reduce using rule 113 (factor -> factor_1 factor_2 .)
    NOTEQUAL        reduce using rule 113 (factor -> factor_1 factor_2 .)
    GREATERTHAN     reduce using rule 113 (factor -> factor_1 factor_2 .)
    GREATERORQUAL   reduce using rule 113 (factor -> factor_1 factor_2 .)
    LESSTHAN        reduce using rule 113 (factor -> factor_1 factor_2 .)
    LESSOREQUAL     reduce using rule 113 (factor -> factor_1 factor_2 .)
    OR              reduce using rule 113 (factor -> factor_1 factor_2 .)
    AND             reduce using rule 113 (factor -> factor_1 factor_2 .)
    COMMA           reduce using rule 113 (factor -> factor_1 factor_2 .)
    RBRACK          reduce using rule 113 (factor -> factor_1 factor_2 .)
    RPAR            reduce using rule 113 (factor -> factor_1 factor_2 .)
    SEMICOL         reduce using rule 113 (factor -> factor_1 factor_2 .)
    TO              reduce using rule 113 (factor -> factor_1 factor_2 .)
    LCURLY          reduce using rule 113 (factor -> factor_1 factor_2 .)


state 97

    (121) factor_2 -> LPAR . expression RPAR
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    expression                     shift and go to state 131
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 98

    (122) factor_2 -> empty .

    TIMES           reduce using rule 122 (factor_2 -> empty .)
    DIV             reduce using rule 122 (factor_2 -> empty .)
    PLUS            reduce using rule 122 (factor_2 -> empty .)
    MINUS           reduce using rule 122 (factor_2 -> empty .)
    ISEQUAL         reduce using rule 122 (factor_2 -> empty .)
    EQUAL           reduce using rule 122 (factor_2 -> empty .)
    NOTEQUAL        reduce using rule 122 (factor_2 -> empty .)
    GREATERTHAN     reduce using rule 122 (factor_2 -> empty .)
    GREATERORQUAL   reduce using rule 122 (factor_2 -> empty .)
    LESSTHAN        reduce using rule 122 (factor_2 -> empty .)
    LESSOREQUAL     reduce using rule 122 (factor_2 -> empty .)
    OR              reduce using rule 122 (factor_2 -> empty .)
    AND             reduce using rule 122 (factor_2 -> empty .)
    COMMA           reduce using rule 122 (factor_2 -> empty .)
    RBRACK          reduce using rule 122 (factor_2 -> empty .)
    RPAR            reduce using rule 122 (factor_2 -> empty .)
    SEMICOL         reduce using rule 122 (factor_2 -> empty .)
    TO              reduce using rule 122 (factor_2 -> empty .)
    LCURLY          reduce using rule 122 (factor_2 -> empty .)


state 99

    (114) factor_1 -> ID factor_3 .

    LPAR            reduce using rule 114 (factor_1 -> ID factor_3 .)
    TIMES           reduce using rule 114 (factor_1 -> ID factor_3 .)
    DIV             reduce using rule 114 (factor_1 -> ID factor_3 .)
    PLUS            reduce using rule 114 (factor_1 -> ID factor_3 .)
    MINUS           reduce using rule 114 (factor_1 -> ID factor_3 .)
    ISEQUAL         reduce using rule 114 (factor_1 -> ID factor_3 .)
    EQUAL           reduce using rule 114 (factor_1 -> ID factor_3 .)
    NOTEQUAL        reduce using rule 114 (factor_1 -> ID factor_3 .)
    GREATERTHAN     reduce using rule 114 (factor_1 -> ID factor_3 .)
    GREATERORQUAL   reduce using rule 114 (factor_1 -> ID factor_3 .)
    LESSTHAN        reduce using rule 114 (factor_1 -> ID factor_3 .)
    LESSOREQUAL     reduce using rule 114 (factor_1 -> ID factor_3 .)
    OR              reduce using rule 114 (factor_1 -> ID factor_3 .)
    AND             reduce using rule 114 (factor_1 -> ID factor_3 .)
    COMMA           reduce using rule 114 (factor_1 -> ID factor_3 .)
    RBRACK          reduce using rule 114 (factor_1 -> ID factor_3 .)
    RPAR            reduce using rule 114 (factor_1 -> ID factor_3 .)
    SEMICOL         reduce using rule 114 (factor_1 -> ID factor_3 .)
    TO              reduce using rule 114 (factor_1 -> ID factor_3 .)
    LCURLY          reduce using rule 114 (factor_1 -> ID factor_3 .)


state 100

    (64) callfunc -> ID LPAR . callfunc_1 RPAR
    (65) callfunc_1 -> . ID callfunc_2 callfunc_3
    (66) callfunc_1 -> . empty
    (127) empty -> .

    ID              shift and go to state 132
    RPAR            reduce using rule 127 (empty -> .)

    callfunc_1                     shift and go to state 133
    empty                          shift and go to state 134

state 101

    (123) factor_3 -> dims .

    LPAR            reduce using rule 123 (factor_3 -> dims .)
    TIMES           reduce using rule 123 (factor_3 -> dims .)
    DIV             reduce using rule 123 (factor_3 -> dims .)
    PLUS            reduce using rule 123 (factor_3 -> dims .)
    MINUS           reduce using rule 123 (factor_3 -> dims .)
    ISEQUAL         reduce using rule 123 (factor_3 -> dims .)
    EQUAL           reduce using rule 123 (factor_3 -> dims .)
    NOTEQUAL        reduce using rule 123 (factor_3 -> dims .)
    GREATERTHAN     reduce using rule 123 (factor_3 -> dims .)
    GREATERORQUAL   reduce using rule 123 (factor_3 -> dims .)
    LESSTHAN        reduce using rule 123 (factor_3 -> dims .)
    LESSOREQUAL     reduce using rule 123 (factor_3 -> dims .)
    OR              reduce using rule 123 (factor_3 -> dims .)
    AND             reduce using rule 123 (factor_3 -> dims .)
    COMMA           reduce using rule 123 (factor_3 -> dims .)
    RBRACK          reduce using rule 123 (factor_3 -> dims .)
    RPAR            reduce using rule 123 (factor_3 -> dims .)
    SEMICOL         reduce using rule 123 (factor_3 -> dims .)
    TO              reduce using rule 123 (factor_3 -> dims .)
    LCURLY          reduce using rule 123 (factor_3 -> dims .)


state 102

    (124) factor_3 -> empty .

    LPAR            reduce using rule 124 (factor_3 -> empty .)
    TIMES           reduce using rule 124 (factor_3 -> empty .)
    DIV             reduce using rule 124 (factor_3 -> empty .)
    PLUS            reduce using rule 124 (factor_3 -> empty .)
    MINUS           reduce using rule 124 (factor_3 -> empty .)
    ISEQUAL         reduce using rule 124 (factor_3 -> empty .)
    EQUAL           reduce using rule 124 (factor_3 -> empty .)
    NOTEQUAL        reduce using rule 124 (factor_3 -> empty .)
    GREATERTHAN     reduce using rule 124 (factor_3 -> empty .)
    GREATERORQUAL   reduce using rule 124 (factor_3 -> empty .)
    LESSTHAN        reduce using rule 124 (factor_3 -> empty .)
    LESSOREQUAL     reduce using rule 124 (factor_3 -> empty .)
    OR              reduce using rule 124 (factor_3 -> empty .)
    AND             reduce using rule 124 (factor_3 -> empty .)
    COMMA           reduce using rule 124 (factor_3 -> empty .)
    RBRACK          reduce using rule 124 (factor_3 -> empty .)
    RPAR            reduce using rule 124 (factor_3 -> empty .)
    SEMICOL         reduce using rule 124 (factor_3 -> empty .)
    TO              reduce using rule 124 (factor_3 -> empty .)
    LCURLY          reduce using rule 124 (factor_3 -> empty .)


state 103

    (125) main -> MAIN LPAR RPAR LCURLY main_1 statement . END SEMICOL RCURLY

    END             shift and go to state 135


state 104

    (42) statement -> statement_1 . statement
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . callfunc
    (49) statement_1 -> . read
    (50) statement_1 -> . write
    (51) statement_1 -> . loadfile
    (127) empty -> .
    (36) assign -> . ID assign_1 EQUAL expression SEMICOL
    (52) cond -> . IF LPAR expression RPAR block cond_1
    (58) cloop -> . WHILE LPAR expression RPAR block
    (59) nloop -> . FROM ID nloop_1 nloop_2 TO expression block
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (71) read -> . READ LPAR read_1 RPAR SEMICOL
    (77) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (83) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    END             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)
    ID              shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    FROM            shift and go to state 117
    READ            shift and go to state 118
    WRITE           shift and go to state 119
    LOADFILE        shift and go to state 120

    statement_1                    shift and go to state 104
    statement                      shift and go to state 136
    empty                          shift and go to state 105
    assign                         shift and go to state 106
    cond                           shift and go to state 107
    cloop                          shift and go to state 108
    nloop                          shift and go to state 109
    callfunc                       shift and go to state 110
    read                           shift and go to state 111
    write                          shift and go to state 112
    loadfile                       shift and go to state 113

state 105

    (43) statement -> empty .

    END             reduce using rule 43 (statement -> empty .)
    RETURN          reduce using rule 43 (statement -> empty .)
    RCURLY          reduce using rule 43 (statement -> empty .)


state 106

    (44) statement_1 -> assign .

    ID              reduce using rule 44 (statement_1 -> assign .)
    IF              reduce using rule 44 (statement_1 -> assign .)
    WHILE           reduce using rule 44 (statement_1 -> assign .)
    FROM            reduce using rule 44 (statement_1 -> assign .)
    READ            reduce using rule 44 (statement_1 -> assign .)
    WRITE           reduce using rule 44 (statement_1 -> assign .)
    LOADFILE        reduce using rule 44 (statement_1 -> assign .)
    END             reduce using rule 44 (statement_1 -> assign .)
    RETURN          reduce using rule 44 (statement_1 -> assign .)
    RCURLY          reduce using rule 44 (statement_1 -> assign .)


state 107

    (45) statement_1 -> cond .

    ID              reduce using rule 45 (statement_1 -> cond .)
    IF              reduce using rule 45 (statement_1 -> cond .)
    WHILE           reduce using rule 45 (statement_1 -> cond .)
    FROM            reduce using rule 45 (statement_1 -> cond .)
    READ            reduce using rule 45 (statement_1 -> cond .)
    WRITE           reduce using rule 45 (statement_1 -> cond .)
    LOADFILE        reduce using rule 45 (statement_1 -> cond .)
    END             reduce using rule 45 (statement_1 -> cond .)
    RETURN          reduce using rule 45 (statement_1 -> cond .)
    RCURLY          reduce using rule 45 (statement_1 -> cond .)


state 108

    (46) statement_1 -> cloop .

    ID              reduce using rule 46 (statement_1 -> cloop .)
    IF              reduce using rule 46 (statement_1 -> cloop .)
    WHILE           reduce using rule 46 (statement_1 -> cloop .)
    FROM            reduce using rule 46 (statement_1 -> cloop .)
    READ            reduce using rule 46 (statement_1 -> cloop .)
    WRITE           reduce using rule 46 (statement_1 -> cloop .)
    LOADFILE        reduce using rule 46 (statement_1 -> cloop .)
    END             reduce using rule 46 (statement_1 -> cloop .)
    RETURN          reduce using rule 46 (statement_1 -> cloop .)
    RCURLY          reduce using rule 46 (statement_1 -> cloop .)


state 109

    (47) statement_1 -> nloop .

    ID              reduce using rule 47 (statement_1 -> nloop .)
    IF              reduce using rule 47 (statement_1 -> nloop .)
    WHILE           reduce using rule 47 (statement_1 -> nloop .)
    FROM            reduce using rule 47 (statement_1 -> nloop .)
    READ            reduce using rule 47 (statement_1 -> nloop .)
    WRITE           reduce using rule 47 (statement_1 -> nloop .)
    LOADFILE        reduce using rule 47 (statement_1 -> nloop .)
    END             reduce using rule 47 (statement_1 -> nloop .)
    RETURN          reduce using rule 47 (statement_1 -> nloop .)
    RCURLY          reduce using rule 47 (statement_1 -> nloop .)


state 110

    (48) statement_1 -> callfunc .

    ID              reduce using rule 48 (statement_1 -> callfunc .)
    IF              reduce using rule 48 (statement_1 -> callfunc .)
    WHILE           reduce using rule 48 (statement_1 -> callfunc .)
    FROM            reduce using rule 48 (statement_1 -> callfunc .)
    READ            reduce using rule 48 (statement_1 -> callfunc .)
    WRITE           reduce using rule 48 (statement_1 -> callfunc .)
    LOADFILE        reduce using rule 48 (statement_1 -> callfunc .)
    END             reduce using rule 48 (statement_1 -> callfunc .)
    RETURN          reduce using rule 48 (statement_1 -> callfunc .)
    RCURLY          reduce using rule 48 (statement_1 -> callfunc .)


state 111

    (49) statement_1 -> read .

    ID              reduce using rule 49 (statement_1 -> read .)
    IF              reduce using rule 49 (statement_1 -> read .)
    WHILE           reduce using rule 49 (statement_1 -> read .)
    FROM            reduce using rule 49 (statement_1 -> read .)
    READ            reduce using rule 49 (statement_1 -> read .)
    WRITE           reduce using rule 49 (statement_1 -> read .)
    LOADFILE        reduce using rule 49 (statement_1 -> read .)
    END             reduce using rule 49 (statement_1 -> read .)
    RETURN          reduce using rule 49 (statement_1 -> read .)
    RCURLY          reduce using rule 49 (statement_1 -> read .)


state 112

    (50) statement_1 -> write .

    ID              reduce using rule 50 (statement_1 -> write .)
    IF              reduce using rule 50 (statement_1 -> write .)
    WHILE           reduce using rule 50 (statement_1 -> write .)
    FROM            reduce using rule 50 (statement_1 -> write .)
    READ            reduce using rule 50 (statement_1 -> write .)
    WRITE           reduce using rule 50 (statement_1 -> write .)
    LOADFILE        reduce using rule 50 (statement_1 -> write .)
    END             reduce using rule 50 (statement_1 -> write .)
    RETURN          reduce using rule 50 (statement_1 -> write .)
    RCURLY          reduce using rule 50 (statement_1 -> write .)


state 113

    (51) statement_1 -> loadfile .

    ID              reduce using rule 51 (statement_1 -> loadfile .)
    IF              reduce using rule 51 (statement_1 -> loadfile .)
    WHILE           reduce using rule 51 (statement_1 -> loadfile .)
    FROM            reduce using rule 51 (statement_1 -> loadfile .)
    READ            reduce using rule 51 (statement_1 -> loadfile .)
    WRITE           reduce using rule 51 (statement_1 -> loadfile .)
    LOADFILE        reduce using rule 51 (statement_1 -> loadfile .)
    END             reduce using rule 51 (statement_1 -> loadfile .)
    RETURN          reduce using rule 51 (statement_1 -> loadfile .)
    RCURLY          reduce using rule 51 (statement_1 -> loadfile .)


state 114

    (36) assign -> ID . assign_1 EQUAL expression SEMICOL
    (64) callfunc -> ID . LPAR callfunc_1 RPAR
    (37) assign_1 -> . dims
    (38) assign_1 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

    LPAR            shift and go to state 100
    LBRACK          shift and go to state 38
    EQUAL           reduce using rule 127 (empty -> .)

    assign_1                       shift and go to state 137
    dims                           shift and go to state 138
    empty                          shift and go to state 139

state 115

    (52) cond -> IF . LPAR expression RPAR block cond_1

    LPAR            shift and go to state 140


state 116

    (58) cloop -> WHILE . LPAR expression RPAR block

    LPAR            shift and go to state 141


state 117

    (59) nloop -> FROM . ID nloop_1 nloop_2 TO expression block

    ID              shift and go to state 142


state 118

    (71) read -> READ . LPAR read_1 RPAR SEMICOL

    LPAR            shift and go to state 143


state 119

    (77) write -> WRITE . LPAR write_1 RPAR SEMICOL

    LPAR            shift and go to state 144


state 120

    (83) loadfile -> LOADFILE . LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    LPAR            shift and go to state 145


state 121

    (23) funcs -> FUNC rtype ID params LCURLY funcs_1 statement . funcs_2 RCURLY funcs_3
    (25) funcs_2 -> . RETURN expression SEMICOL
    (26) funcs_2 -> . empty
    (127) empty -> .

    RETURN          shift and go to state 147
    RCURLY          reduce using rule 127 (empty -> .)

    funcs_2                        shift and go to state 146
    empty                          shift and go to state 148

state 122

    (30) params_1 -> type ID params_2 . params_3
    (34) params_3 -> . COMMA params_1
    (35) params_3 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 150
    RPAR            reduce using rule 127 (empty -> .)

    params_3                       shift and go to state 149
    empty                          shift and go to state 151

state 123

    (32) params_2 -> dims .

    COMMA           reduce using rule 32 (params_2 -> dims .)
    RPAR            reduce using rule 32 (params_2 -> dims .)


state 124

    (33) params_2 -> empty .

    COMMA           reduce using rule 33 (params_2 -> empty .)
    RPAR            reduce using rule 33 (params_2 -> empty .)


state 125

    (39) dims -> LBRACK expression dims_1 RBRACK .

    COMMA           reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    SEMICOL         reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    LPAR            reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    TIMES           reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    DIV             reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    PLUS            reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    MINUS           reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    ISEQUAL         reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    EQUAL           reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    NOTEQUAL        reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    GREATERTHAN     reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    GREATERORQUAL   reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    LESSTHAN        reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    LESSOREQUAL     reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    OR              reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    AND             reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    RBRACK          reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    RPAR            reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    TO              reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)
    LCURLY          reduce using rule 39 (dims -> LBRACK expression dims_1 RBRACK .)


state 126

    (40) dims_1 -> COMMA expression .

    RBRACK          reduce using rule 40 (dims_1 -> COMMA expression .)


state 127

    (89) expression_1 -> expression_2 expression .

    COMMA           reduce using rule 89 (expression_1 -> expression_2 expression .)
    RBRACK          reduce using rule 89 (expression_1 -> expression_2 expression .)
    RPAR            reduce using rule 89 (expression_1 -> expression_2 expression .)
    SEMICOL         reduce using rule 89 (expression_1 -> expression_2 expression .)
    TO              reduce using rule 89 (expression_1 -> expression_2 expression .)
    LCURLY          reduce using rule 89 (expression_1 -> expression_2 expression .)


state 128

    (94) sexp_1 -> sexp_2 exp .

    OR              reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    AND             reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    COMMA           reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    RBRACK          reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    RPAR            reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    SEMICOL         reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    TO              reduce using rule 94 (sexp_1 -> sexp_2 exp .)
    LCURLY          reduce using rule 94 (sexp_1 -> sexp_2 exp .)


state 129

    (104) exp_1 -> exp_2 exp .

    ISEQUAL         reduce using rule 104 (exp_1 -> exp_2 exp .)
    EQUAL           reduce using rule 104 (exp_1 -> exp_2 exp .)
    NOTEQUAL        reduce using rule 104 (exp_1 -> exp_2 exp .)
    GREATERTHAN     reduce using rule 104 (exp_1 -> exp_2 exp .)
    GREATERORQUAL   reduce using rule 104 (exp_1 -> exp_2 exp .)
    LESSTHAN        reduce using rule 104 (exp_1 -> exp_2 exp .)
    LESSOREQUAL     reduce using rule 104 (exp_1 -> exp_2 exp .)
    OR              reduce using rule 104 (exp_1 -> exp_2 exp .)
    AND             reduce using rule 104 (exp_1 -> exp_2 exp .)
    COMMA           reduce using rule 104 (exp_1 -> exp_2 exp .)
    RBRACK          reduce using rule 104 (exp_1 -> exp_2 exp .)
    RPAR            reduce using rule 104 (exp_1 -> exp_2 exp .)
    SEMICOL         reduce using rule 104 (exp_1 -> exp_2 exp .)
    TO              reduce using rule 104 (exp_1 -> exp_2 exp .)
    LCURLY          reduce using rule 104 (exp_1 -> exp_2 exp .)


state 130

    (109) term_1 -> term_2 term .

    PLUS            reduce using rule 109 (term_1 -> term_2 term .)
    MINUS           reduce using rule 109 (term_1 -> term_2 term .)
    ISEQUAL         reduce using rule 109 (term_1 -> term_2 term .)
    EQUAL           reduce using rule 109 (term_1 -> term_2 term .)
    NOTEQUAL        reduce using rule 109 (term_1 -> term_2 term .)
    GREATERTHAN     reduce using rule 109 (term_1 -> term_2 term .)
    GREATERORQUAL   reduce using rule 109 (term_1 -> term_2 term .)
    LESSTHAN        reduce using rule 109 (term_1 -> term_2 term .)
    LESSOREQUAL     reduce using rule 109 (term_1 -> term_2 term .)
    OR              reduce using rule 109 (term_1 -> term_2 term .)
    AND             reduce using rule 109 (term_1 -> term_2 term .)
    COMMA           reduce using rule 109 (term_1 -> term_2 term .)
    RBRACK          reduce using rule 109 (term_1 -> term_2 term .)
    RPAR            reduce using rule 109 (term_1 -> term_2 term .)
    SEMICOL         reduce using rule 109 (term_1 -> term_2 term .)
    TO              reduce using rule 109 (term_1 -> term_2 term .)
    LCURLY          reduce using rule 109 (term_1 -> term_2 term .)


state 131

    (121) factor_2 -> LPAR expression . RPAR

    RPAR            shift and go to state 152


state 132

    (65) callfunc_1 -> ID . callfunc_2 callfunc_3
    (67) callfunc_2 -> . dims
    (68) callfunc_2 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

    LBRACK          shift and go to state 38
    COMMA           reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    callfunc_2                     shift and go to state 153
    dims                           shift and go to state 154
    empty                          shift and go to state 155

state 133

    (64) callfunc -> ID LPAR callfunc_1 . RPAR

    RPAR            shift and go to state 156


state 134

    (66) callfunc_1 -> empty .

    RPAR            reduce using rule 66 (callfunc_1 -> empty .)


state 135

    (125) main -> MAIN LPAR RPAR LCURLY main_1 statement END . SEMICOL RCURLY

    SEMICOL         shift and go to state 157


state 136

    (42) statement -> statement_1 statement .

    END             reduce using rule 42 (statement -> statement_1 statement .)
    RETURN          reduce using rule 42 (statement -> statement_1 statement .)
    RCURLY          reduce using rule 42 (statement -> statement_1 statement .)


state 137

    (36) assign -> ID assign_1 . EQUAL expression SEMICOL

    EQUAL           shift and go to state 158


state 138

    (37) assign_1 -> dims .

    EQUAL           reduce using rule 37 (assign_1 -> dims .)


state 139

    (38) assign_1 -> empty .

    EQUAL           reduce using rule 38 (assign_1 -> empty .)


state 140

    (52) cond -> IF LPAR . expression RPAR block cond_1
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    expression                     shift and go to state 159
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 141

    (58) cloop -> WHILE LPAR . expression RPAR block
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    expression                     shift and go to state 160
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 142

    (59) nloop -> FROM ID . nloop_1 nloop_2 TO expression block
    (60) nloop_1 -> . dims
    (61) nloop_1 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

    LBRACK          shift and go to state 38
    EQUAL           reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)

    nloop_1                        shift and go to state 161
    dims                           shift and go to state 162
    empty                          shift and go to state 163

state 143

    (71) read -> READ LPAR . read_1 RPAR SEMICOL
    (72) read_1 -> . ID read_2 read_3

    ID              shift and go to state 165

    read_1                         shift and go to state 164

state 144

    (77) write -> WRITE LPAR . write_1 RPAR SEMICOL
    (78) write_1 -> . write_2 write_3
    (79) write_2 -> . expression
    (80) write_2 -> . CTES
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    CTES            shift and go to state 169
    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    write_1                        shift and go to state 166
    write_2                        shift and go to state 167
    expression                     shift and go to state 168
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 145

    (83) loadfile -> LOADFILE LPAR . ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    ID              shift and go to state 170


state 146

    (23) funcs -> FUNC rtype ID params LCURLY funcs_1 statement funcs_2 . RCURLY funcs_3

    RCURLY          shift and go to state 171


state 147

    (25) funcs_2 -> RETURN . expression SEMICOL
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)

    expression                     shift and go to state 172
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 148

    (26) funcs_2 -> empty .

    RCURLY          reduce using rule 26 (funcs_2 -> empty .)


state 149

    (30) params_1 -> type ID params_2 params_3 .

    RPAR            reduce using rule 30 (params_1 -> type ID params_2 params_3 .)


state 150

    (34) params_3 -> COMMA . params_1
    (30) params_1 -> . type ID params_2 params_3
    (31) params_1 -> . empty
    (12) type -> . INT
    (13) type -> . FLOAT
    (14) type -> . CHAR
    (15) type -> . BOOL
    (127) empty -> .

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    BOOL            shift and go to state 17
    RPAR            reduce using rule 127 (empty -> .)

    params_1                       shift and go to state 173
    type                           shift and go to state 42
    empty                          shift and go to state 43

state 151

    (35) params_3 -> empty .

    RPAR            reduce using rule 35 (params_3 -> empty .)


state 152

    (121) factor_2 -> LPAR expression RPAR .

    TIMES           reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    DIV             reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    PLUS            reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    MINUS           reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    ISEQUAL         reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    EQUAL           reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    NOTEQUAL        reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    GREATERTHAN     reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    GREATERORQUAL   reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    LESSTHAN        reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    LESSOREQUAL     reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    OR              reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    AND             reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    COMMA           reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    RBRACK          reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    RPAR            reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    SEMICOL         reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    TO              reduce using rule 121 (factor_2 -> LPAR expression RPAR .)
    LCURLY          reduce using rule 121 (factor_2 -> LPAR expression RPAR .)


state 153

    (65) callfunc_1 -> ID callfunc_2 . callfunc_3
    (69) callfunc_3 -> . COMMA callfunc_1
    (70) callfunc_3 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 175
    RPAR            reduce using rule 127 (empty -> .)

    callfunc_3                     shift and go to state 174
    empty                          shift and go to state 176

state 154

    (67) callfunc_2 -> dims .

    COMMA           reduce using rule 67 (callfunc_2 -> dims .)
    RPAR            reduce using rule 67 (callfunc_2 -> dims .)


state 155

    (68) callfunc_2 -> empty .

    COMMA           reduce using rule 68 (callfunc_2 -> empty .)
    RPAR            reduce using rule 68 (callfunc_2 -> empty .)


state 156

    (64) callfunc -> ID LPAR callfunc_1 RPAR .

    LPAR            reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    TIMES           reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    DIV             reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    PLUS            reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    MINUS           reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    ISEQUAL         reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    EQUAL           reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    NOTEQUAL        reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    GREATERTHAN     reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    GREATERORQUAL   reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    LESSTHAN        reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    LESSOREQUAL     reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    OR              reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    AND             reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    COMMA           reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    RBRACK          reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    ID              reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    IF              reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    WHILE           reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    FROM            reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    READ            reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    WRITE           reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    LOADFILE        reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    END             reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    RETURN          reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    RCURLY          reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    RPAR            reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    SEMICOL         reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    TO              reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)
    LCURLY          reduce using rule 64 (callfunc -> ID LPAR callfunc_1 RPAR .)


state 157

    (125) main -> MAIN LPAR RPAR LCURLY main_1 statement END SEMICOL . RCURLY

    RCURLY          shift and go to state 177


state 158

    (36) assign -> ID assign_1 EQUAL . expression SEMICOL
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    SEMICOL         reduce using rule 127 (empty -> .)

    expression                     shift and go to state 178
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 159

    (52) cond -> IF LPAR expression . RPAR block cond_1

    RPAR            shift and go to state 179


state 160

    (58) cloop -> WHILE LPAR expression . RPAR block

    RPAR            shift and go to state 180


state 161

    (59) nloop -> FROM ID nloop_1 . nloop_2 TO expression block
    (62) nloop_2 -> . EQUAL expression
    (63) nloop_2 -> . empty
    (127) empty -> .

    EQUAL           shift and go to state 182
    TO              reduce using rule 127 (empty -> .)

    nloop_2                        shift and go to state 181
    empty                          shift and go to state 183

state 162

    (60) nloop_1 -> dims .

    EQUAL           reduce using rule 60 (nloop_1 -> dims .)
    TO              reduce using rule 60 (nloop_1 -> dims .)


state 163

    (61) nloop_1 -> empty .

    EQUAL           reduce using rule 61 (nloop_1 -> empty .)
    TO              reduce using rule 61 (nloop_1 -> empty .)


state 164

    (71) read -> READ LPAR read_1 . RPAR SEMICOL

    RPAR            shift and go to state 184


state 165

    (72) read_1 -> ID . read_2 read_3
    (73) read_2 -> . dims
    (74) read_2 -> . empty
    (39) dims -> . LBRACK expression dims_1 RBRACK
    (127) empty -> .

    LBRACK          shift and go to state 38
    COMMA           reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    read_2                         shift and go to state 185
    dims                           shift and go to state 186
    empty                          shift and go to state 187

state 166

    (77) write -> WRITE LPAR write_1 . RPAR SEMICOL

    RPAR            shift and go to state 188


state 167

    (78) write_1 -> write_2 . write_3
    (81) write_3 -> . COMMA write_1
    (82) write_3 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 190
    RPAR            reduce using rule 127 (empty -> .)

    write_3                        shift and go to state 189
    empty                          shift and go to state 191

state 168

    (79) write_2 -> expression .

    COMMA           reduce using rule 79 (write_2 -> expression .)
    RPAR            reduce using rule 79 (write_2 -> expression .)


state 169

    (80) write_2 -> CTES .

    COMMA           reduce using rule 80 (write_2 -> CTES .)
    RPAR            reduce using rule 80 (write_2 -> CTES .)


state 170

    (83) loadfile -> LOADFILE LPAR ID . COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 192


state 171

    (23) funcs -> FUNC rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY . funcs_3
    (27) funcs_3 -> . funcs
    (28) funcs_3 -> . empty
    (23) funcs -> . FUNC rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3
    (127) empty -> .

    FUNC            shift and go to state 12
    MAIN            reduce using rule 127 (empty -> .)

    funcs_3                        shift and go to state 193
    funcs                          shift and go to state 194
    empty                          shift and go to state 195

state 172

    (25) funcs_2 -> RETURN expression . SEMICOL

    SEMICOL         shift and go to state 196


state 173

    (34) params_3 -> COMMA params_1 .

    RPAR            reduce using rule 34 (params_3 -> COMMA params_1 .)


state 174

    (65) callfunc_1 -> ID callfunc_2 callfunc_3 .

    RPAR            reduce using rule 65 (callfunc_1 -> ID callfunc_2 callfunc_3 .)


state 175

    (69) callfunc_3 -> COMMA . callfunc_1
    (65) callfunc_1 -> . ID callfunc_2 callfunc_3
    (66) callfunc_1 -> . empty
    (127) empty -> .

    ID              shift and go to state 132
    RPAR            reduce using rule 127 (empty -> .)

    callfunc_1                     shift and go to state 197
    empty                          shift and go to state 134

state 176

    (70) callfunc_3 -> empty .

    RPAR            reduce using rule 70 (callfunc_3 -> empty .)


state 177

    (125) main -> MAIN LPAR RPAR LCURLY main_1 statement END SEMICOL RCURLY .

    $end            reduce using rule 125 (main -> MAIN LPAR RPAR LCURLY main_1 statement END SEMICOL RCURLY .)


state 178

    (36) assign -> ID assign_1 EQUAL expression . SEMICOL

    SEMICOL         shift and go to state 198


state 179

    (52) cond -> IF LPAR expression RPAR . block cond_1
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 200

    block                          shift and go to state 199

state 180

    (58) cloop -> WHILE LPAR expression RPAR . block
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 200

    block                          shift and go to state 201

state 181

    (59) nloop -> FROM ID nloop_1 nloop_2 . TO expression block

    TO              shift and go to state 202


state 182

    (62) nloop_2 -> EQUAL . expression
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)

    expression                     shift and go to state 203
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 183

    (63) nloop_2 -> empty .

    TO              reduce using rule 63 (nloop_2 -> empty .)


state 184

    (71) read -> READ LPAR read_1 RPAR . SEMICOL

    SEMICOL         shift and go to state 204


state 185

    (72) read_1 -> ID read_2 . read_3
    (75) read_3 -> . COMMA read_1
    (76) read_3 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 206
    RPAR            reduce using rule 127 (empty -> .)

    read_3                         shift and go to state 205
    empty                          shift and go to state 207

state 186

    (73) read_2 -> dims .

    COMMA           reduce using rule 73 (read_2 -> dims .)
    RPAR            reduce using rule 73 (read_2 -> dims .)


state 187

    (74) read_2 -> empty .

    COMMA           reduce using rule 74 (read_2 -> empty .)
    RPAR            reduce using rule 74 (read_2 -> empty .)


state 188

    (77) write -> WRITE LPAR write_1 RPAR . SEMICOL

    SEMICOL         shift and go to state 208


state 189

    (78) write_1 -> write_2 write_3 .

    RPAR            reduce using rule 78 (write_1 -> write_2 write_3 .)


state 190

    (81) write_3 -> COMMA . write_1
    (78) write_1 -> . write_2 write_3
    (79) write_2 -> . expression
    (80) write_2 -> . CTES
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    CTES            shift and go to state 169
    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    write_1                        shift and go to state 209
    write_2                        shift and go to state 167
    expression                     shift and go to state 168
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 191

    (82) write_3 -> empty .

    RPAR            reduce using rule 82 (write_3 -> empty .)


state 192

    (83) loadfile -> LOADFILE LPAR ID COMMA . CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    CTES            shift and go to state 210


state 193

    (23) funcs -> FUNC rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3 .

    MAIN            reduce using rule 23 (funcs -> FUNC rtype ID params LCURLY funcs_1 statement funcs_2 RCURLY funcs_3 .)


state 194

    (27) funcs_3 -> funcs .

    MAIN            reduce using rule 27 (funcs_3 -> funcs .)


state 195

    (28) funcs_3 -> empty .

    MAIN            reduce using rule 28 (funcs_3 -> empty .)


state 196

    (25) funcs_2 -> RETURN expression SEMICOL .

    RCURLY          reduce using rule 25 (funcs_2 -> RETURN expression SEMICOL .)


state 197

    (69) callfunc_3 -> COMMA callfunc_1 .

    RPAR            reduce using rule 69 (callfunc_3 -> COMMA callfunc_1 .)


state 198

    (36) assign -> ID assign_1 EQUAL expression SEMICOL .

    ID              reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    IF              reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    WHILE           reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    FROM            reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    READ            reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    WRITE           reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    LOADFILE        reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    END             reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    RETURN          reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)
    RCURLY          reduce using rule 36 (assign -> ID assign_1 EQUAL expression SEMICOL .)


state 199

    (52) cond -> IF LPAR expression RPAR block . cond_1
    (53) cond_1 -> . ELSE cond_2

    ELSE            shift and go to state 212

    cond_1                         shift and go to state 211

state 200

    (21) block -> LCURLY . block_1 RCURLY
    (22) block_1 -> . statement
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . callfunc
    (49) statement_1 -> . read
    (50) statement_1 -> . write
    (51) statement_1 -> . loadfile
    (127) empty -> .
    (36) assign -> . ID assign_1 EQUAL expression SEMICOL
    (52) cond -> . IF LPAR expression RPAR block cond_1
    (58) cloop -> . WHILE LPAR expression RPAR block
    (59) nloop -> . FROM ID nloop_1 nloop_2 TO expression block
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (71) read -> . READ LPAR read_1 RPAR SEMICOL
    (77) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (83) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    RCURLY          reduce using rule 127 (empty -> .)
    ID              shift and go to state 114
    IF              shift and go to state 115
    WHILE           shift and go to state 116
    FROM            shift and go to state 117
    READ            shift and go to state 118
    WRITE           shift and go to state 119
    LOADFILE        shift and go to state 120

    block_1                        shift and go to state 213
    statement                      shift and go to state 214
    statement_1                    shift and go to state 104
    empty                          shift and go to state 105
    assign                         shift and go to state 106
    cond                           shift and go to state 107
    cloop                          shift and go to state 108
    nloop                          shift and go to state 109
    callfunc                       shift and go to state 110
    read                           shift and go to state 111
    write                          shift and go to state 112
    loadfile                       shift and go to state 113

state 201

    (58) cloop -> WHILE LPAR expression RPAR block .

    ID              reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    IF              reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    WHILE           reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    FROM            reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    READ            reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    WRITE           reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    LOADFILE        reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    END             reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    RETURN          reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)
    RCURLY          reduce using rule 58 (cloop -> WHILE LPAR expression RPAR block .)


state 202

    (59) nloop -> FROM ID nloop_1 nloop_2 TO . expression block
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    LCURLY          reduce using rule 127 (empty -> .)

    expression                     shift and go to state 215
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 203

    (62) nloop_2 -> EQUAL expression .

    TO              reduce using rule 62 (nloop_2 -> EQUAL expression .)


state 204

    (71) read -> READ LPAR read_1 RPAR SEMICOL .

    ID              reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    IF              reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    WHILE           reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    FROM            reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    READ            reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    WRITE           reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    LOADFILE        reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    END             reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    RETURN          reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)
    RCURLY          reduce using rule 71 (read -> READ LPAR read_1 RPAR SEMICOL .)


state 205

    (72) read_1 -> ID read_2 read_3 .

    RPAR            reduce using rule 72 (read_1 -> ID read_2 read_3 .)


state 206

    (75) read_3 -> COMMA . read_1
    (72) read_1 -> . ID read_2 read_3

    ID              shift and go to state 165

    read_1                         shift and go to state 216

state 207

    (76) read_3 -> empty .

    RPAR            reduce using rule 76 (read_3 -> empty .)


state 208

    (77) write -> WRITE LPAR write_1 RPAR SEMICOL .

    ID              reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    IF              reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    WHILE           reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    FROM            reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    READ            reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    WRITE           reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    LOADFILE        reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    END             reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    RETURN          reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    RCURLY          reduce using rule 77 (write -> WRITE LPAR write_1 RPAR SEMICOL .)


state 209

    (81) write_3 -> COMMA write_1 .

    RPAR            reduce using rule 81 (write_3 -> COMMA write_1 .)


state 210

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES . COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 217


state 211

    (52) cond -> IF LPAR expression RPAR block cond_1 .

    ID              reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    IF              reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    WHILE           reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    FROM            reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    READ            reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    WRITE           reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    LOADFILE        reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    END             reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    RETURN          reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)
    RCURLY          reduce using rule 52 (cond -> IF LPAR expression RPAR block cond_1 .)


state 212

    (53) cond_1 -> ELSE . cond_2
    (54) cond_2 -> . IF LPAR expression RPAR block cond_3
    (55) cond_2 -> . block
    (21) block -> . LCURLY block_1 RCURLY

    IF              shift and go to state 219
    LCURLY          shift and go to state 200

    cond_2                         shift and go to state 218
    block                          shift and go to state 220

state 213

    (21) block -> LCURLY block_1 . RCURLY

    RCURLY          shift and go to state 221


state 214

    (22) block_1 -> statement .

    RCURLY          reduce using rule 22 (block_1 -> statement .)


state 215

    (59) nloop -> FROM ID nloop_1 nloop_2 TO expression . block
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 200

    block                          shift and go to state 222

state 216

    (75) read_3 -> COMMA read_1 .

    RPAR            reduce using rule 75 (read_3 -> COMMA read_1 .)


state 217

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA . loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (84) loadfile_1 -> . CTEI
    (85) loadfile_1 -> . ID

    CTEI            shift and go to state 225
    ID              shift and go to state 223

    loadfile_1                     shift and go to state 224

state 218

    (53) cond_1 -> ELSE cond_2 .

    ID              reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    IF              reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    WHILE           reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    FROM            reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    READ            reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    WRITE           reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    LOADFILE        reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    END             reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    RETURN          reduce using rule 53 (cond_1 -> ELSE cond_2 .)
    RCURLY          reduce using rule 53 (cond_1 -> ELSE cond_2 .)


state 219

    (54) cond_2 -> IF . LPAR expression RPAR block cond_3

    LPAR            shift and go to state 226


state 220

    (55) cond_2 -> block .

    ID              reduce using rule 55 (cond_2 -> block .)
    IF              reduce using rule 55 (cond_2 -> block .)
    WHILE           reduce using rule 55 (cond_2 -> block .)
    FROM            reduce using rule 55 (cond_2 -> block .)
    READ            reduce using rule 55 (cond_2 -> block .)
    WRITE           reduce using rule 55 (cond_2 -> block .)
    LOADFILE        reduce using rule 55 (cond_2 -> block .)
    END             reduce using rule 55 (cond_2 -> block .)
    RETURN          reduce using rule 55 (cond_2 -> block .)
    RCURLY          reduce using rule 55 (cond_2 -> block .)


state 221

    (21) block -> LCURLY block_1 RCURLY .

    ELSE            reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    ID              reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    IF              reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    WHILE           reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    FROM            reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    READ            reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    WRITE           reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    LOADFILE        reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    END             reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    RETURN          reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    RCURLY          reduce using rule 21 (block -> LCURLY block_1 RCURLY .)


state 222

    (59) nloop -> FROM ID nloop_1 nloop_2 TO expression block .

    ID              reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    IF              reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    WHILE           reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    FROM            reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    READ            reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    WRITE           reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    LOADFILE        reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    END             reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    RETURN          reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)
    RCURLY          reduce using rule 59 (nloop -> FROM ID nloop_1 nloop_2 TO expression block .)


state 223

    (85) loadfile_1 -> ID .

    COMMA           reduce using rule 85 (loadfile_1 -> ID .)


state 224

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 . COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 227


state 225

    (84) loadfile_1 -> CTEI .

    COMMA           reduce using rule 84 (loadfile_1 -> CTEI .)


state 226

    (54) cond_2 -> IF LPAR . expression RPAR block cond_3
    (88) expression -> . sexp expression_1
    (93) sexp -> . exp sexp_1
    (103) exp -> . term exp_1
    (108) term -> . factor term_1
    (113) factor -> . factor_1 factor_2
    (114) factor_1 -> . ID factor_3
    (115) factor_1 -> . callfunc
    (116) factor_1 -> . CTEI
    (117) factor_1 -> . CTEF
    (118) factor_1 -> . CTEB
    (119) factor_1 -> . CTEC
    (120) factor_1 -> . empty
    (64) callfunc -> . ID LPAR callfunc_1 RPAR
    (127) empty -> .

    ID              shift and go to state 54
    CTEI            shift and go to state 56
    CTEF            shift and go to state 57
    CTEB            shift and go to state 58
    CTEC            shift and go to state 59
    LPAR            reduce using rule 127 (empty -> .)
    TIMES           reduce using rule 127 (empty -> .)
    DIV             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    ISEQUAL         reduce using rule 127 (empty -> .)
    EQUAL           reduce using rule 127 (empty -> .)
    NOTEQUAL        reduce using rule 127 (empty -> .)
    GREATERTHAN     reduce using rule 127 (empty -> .)
    GREATERORQUAL   reduce using rule 127 (empty -> .)
    LESSTHAN        reduce using rule 127 (empty -> .)
    LESSOREQUAL     reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RPAR            reduce using rule 127 (empty -> .)

    expression                     shift and go to state 228
    sexp                           shift and go to state 49
    exp                            shift and go to state 50
    term                           shift and go to state 51
    factor                         shift and go to state 52
    factor_1                       shift and go to state 53
    callfunc                       shift and go to state 55
    empty                          shift and go to state 60

state 227

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA . loadfile_2 RPAR SEMICOL
    (86) loadfile_2 -> . CTEI
    (87) loadfile_2 -> . ID

    CTEI            shift and go to state 231
    ID              shift and go to state 229

    loadfile_2                     shift and go to state 230

state 228

    (54) cond_2 -> IF LPAR expression . RPAR block cond_3

    RPAR            shift and go to state 232


state 229

    (87) loadfile_2 -> ID .

    RPAR            reduce using rule 87 (loadfile_2 -> ID .)


state 230

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 . RPAR SEMICOL

    RPAR            shift and go to state 233


state 231

    (86) loadfile_2 -> CTEI .

    RPAR            reduce using rule 86 (loadfile_2 -> CTEI .)


state 232

    (54) cond_2 -> IF LPAR expression RPAR . block cond_3
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 200

    block                          shift and go to state 234

state 233

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR . SEMICOL

    SEMICOL         shift and go to state 235


state 234

    (54) cond_2 -> IF LPAR expression RPAR block . cond_3
    (56) cond_3 -> . cond_1
    (57) cond_3 -> . empty
    (53) cond_1 -> . ELSE cond_2
    (127) empty -> .

    ELSE            shift and go to state 212
    ID              reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    WRITE           reduce using rule 127 (empty -> .)
    LOADFILE        reduce using rule 127 (empty -> .)
    END             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)

    cond_3                         shift and go to state 236
    cond_1                         shift and go to state 237
    empty                          shift and go to state 238

state 235

    (83) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .

    ID              reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    IF              reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    WHILE           reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    FROM            reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    READ            reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    WRITE           reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    LOADFILE        reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    END             reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    RETURN          reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    RCURLY          reduce using rule 83 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)


state 236

    (54) cond_2 -> IF LPAR expression RPAR block cond_3 .

    ID              reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    IF              reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    WHILE           reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    FROM            reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    READ            reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    WRITE           reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    LOADFILE        reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    END             reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    RETURN          reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)
    RCURLY          reduce using rule 54 (cond_2 -> IF LPAR expression RPAR block cond_3 .)


state 237

    (56) cond_3 -> cond_1 .

    ID              reduce using rule 56 (cond_3 -> cond_1 .)
    IF              reduce using rule 56 (cond_3 -> cond_1 .)
    WHILE           reduce using rule 56 (cond_3 -> cond_1 .)
    FROM            reduce using rule 56 (cond_3 -> cond_1 .)
    READ            reduce using rule 56 (cond_3 -> cond_1 .)
    WRITE           reduce using rule 56 (cond_3 -> cond_1 .)
    LOADFILE        reduce using rule 56 (cond_3 -> cond_1 .)
    END             reduce using rule 56 (cond_3 -> cond_1 .)
    RETURN          reduce using rule 56 (cond_3 -> cond_1 .)
    RCURLY          reduce using rule 56 (cond_3 -> cond_1 .)


state 238

    (57) cond_3 -> empty .

    ID              reduce using rule 57 (cond_3 -> empty .)
    IF              reduce using rule 57 (cond_3 -> empty .)
    WHILE           reduce using rule 57 (cond_3 -> empty .)
    FROM            reduce using rule 57 (cond_3 -> empty .)
    READ            reduce using rule 57 (cond_3 -> empty .)
    WRITE           reduce using rule 57 (cond_3 -> empty .)
    LOADFILE        reduce using rule 57 (cond_3 -> empty .)
    END             reduce using rule 57 (cond_3 -> empty .)
    RETURN          reduce using rule 57 (cond_3 -> empty .)
    RCURLY          reduce using rule 57 (cond_3 -> empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAR in state 54 resolved as shift
