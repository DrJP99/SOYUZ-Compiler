Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program_start
Rule 1     program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main
Rule 2     program_start_1 -> vars
Rule 3     program_start_2 -> funcs
Rule 4     program_start_2 -> empty
Rule 5     vars -> VAR type COL vars_1 SEMICOL vars
Rule 6     vars -> empty
Rule 7     vars_1 -> ID see_id vars_2 push_var vars_3
Rule 8     vars_2 -> dims_assign
Rule 9     vars_2 -> empty
Rule 10    vars_3 -> COMMA vars_1
Rule 11    vars_3 -> empty
Rule 12    dims_assign -> LBRACK see_dims_a CTEI see_dims_num dims_assign_1 RBRACK
Rule 13    dims_assign_1 -> COMMA see_dims_a CTEI see_dims_num
Rule 14    dims_assign_1 -> empty
Rule 15    type -> INT
Rule 16    type -> FLOAT
Rule 17    type -> CHAR
Rule 18    type -> BOOL
Rule 19    rtype -> INT
Rule 20    rtype -> FLOAT
Rule 21    rtype -> CHAR
Rule 22    rtype -> BOOL
Rule 23    rtype -> VOID
Rule 24    block -> LCURLY block_1 RCURLY
Rule 25    block_1 -> statement
Rule 26    funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
Rule 27    funcs_1 -> vars
Rule 28    funcs_2 -> RETURN expression SEMICOL
Rule 29    funcs_2 -> empty
Rule 30    funcs_3 -> funcs
Rule 31    funcs_3 -> empty
Rule 32    params -> LPAR params_1 RPAR
Rule 33    params_1 -> type ID see_id params_2 see_end_param reset_dims params_3
Rule 34    params_1 -> empty
Rule 35    params_2 -> dims
Rule 36    params_2 -> empty
Rule 37    params_3 -> COMMA params_1
Rule 38    params_3 -> empty
Rule 39    assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
Rule 40    assign_1 -> dims
Rule 41    assign_1 -> empty
Rule 42    dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
Rule 43    dims_1 -> COMMA see_dims_s expression generate_g_verify_s
Rule 44    dims_1 -> empty
Rule 45    statement -> statement_1 statement
Rule 46    statement -> empty
Rule 47    statement_1 -> assign
Rule 48    statement_1 -> cond
Rule 49    statement_1 -> cloop
Rule 50    statement_1 -> nloop
Rule 51    statement_1 -> read
Rule 52    statement_1 -> write
Rule 53    statement_1 -> loadfile
Rule 54    statement_1 -> callfunc SEMICOL
Rule 55    cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if
Rule 56    cond_1 -> ELSE generate_g_else cond_2
Rule 57    cond_2 -> cond_3
Rule 58    cond_2 -> block
Rule 59    cond_3 -> cond
Rule 60    cond_3 -> empty
Rule 61    cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
Rule 62    nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
Rule 63    nloop_1 -> dims
Rule 64    nloop_1 -> empty
Rule 65    nloop_2 -> push_id EQUAL push_equal expression generate_assign
Rule 66    nloop_2 -> empty
Rule 67    callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
Rule 68    callfunc_1 -> expression verify_params callfunc_3
Rule 69    callfunc_1 -> empty
Rule 70    callfunc_3 -> COMMA increase_p_count callfunc_1
Rule 71    callfunc_3 -> empty
Rule 72    read -> READ LPAR read_1 RPAR SEMICOL
Rule 73    read_1 -> ID see_id read_2 push_id generate_g_read read_3
Rule 74    read_2 -> dims reset_dims
Rule 75    read_2 -> empty
Rule 76    read_3 -> COMMA read_1
Rule 77    read_3 -> empty
Rule 78    write -> WRITE LPAR write_1 RPAR SEMICOL
Rule 79    write_1 -> write_2 generate_g_write write_3
Rule 80    write_2 -> expression
Rule 81    write_2 -> CTES push_string
Rule 82    write_3 -> COMMA write_1
Rule 83    write_3 -> empty
Rule 84    loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
Rule 85    loadfile_1 -> CTEI
Rule 86    loadfile_1 -> ID
Rule 87    loadfile_2 -> CTEI
Rule 88    loadfile_2 -> ID
Rule 89    expression -> sexp check_and_or expression_1
Rule 90    expression_1 -> expression_2 push_and_or expression
Rule 91    expression_1 -> empty
Rule 92    expression_2 -> OR
Rule 93    expression_2 -> AND
Rule 94    sexp -> exp check_relational sexp_1
Rule 95    sexp_1 -> sexp_2 push_relational sexp
Rule 96    sexp_1 -> empty
Rule 97    sexp_2 -> ISEQUAL
Rule 98    sexp_2 -> EQUAL
Rule 99    sexp_2 -> NOTEQUAL
Rule 100   sexp_2 -> GREATERTHAN
Rule 101   sexp_2 -> GREATERORQUAL
Rule 102   sexp_2 -> LESSTHAN
Rule 103   sexp_2 -> LESSOREQUAL
Rule 104   exp -> term check_sum exp_1
Rule 105   exp_1 -> exp_2 push_sum exp
Rule 106   exp_1 -> empty
Rule 107   exp_2 -> PLUS
Rule 108   exp_2 -> MINUS
Rule 109   term -> factor check_mul_div term_1
Rule 110   term_1 -> term_2 push_mul_div term
Rule 111   term_1 -> empty
Rule 112   term_2 -> TIMES
Rule 113   term_2 -> DIV
Rule 114   factor -> factor_1
Rule 115   factor -> factor_2
Rule 116   factor_1 -> ID see_id push_id factor_3 print_value reset_dims
Rule 117   factor_1 -> callfunc
Rule 118   factor_1 -> CTEI push_int
Rule 119   factor_1 -> CTEF push_float
Rule 120   factor_1 -> CTEB push_bool
Rule 121   factor_1 -> CTEC push_char
Rule 122   factor_1 -> MINUS factor_1
Rule 123   factor_2 -> LPAR add_ff expression RPAR pop_ff
Rule 124   factor_3 -> dims
Rule 125   factor_3 -> empty
Rule 126   main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
Rule 127   main_1 -> vars
Rule 128   see_id -> empty
Rule 129   see_dims -> empty
Rule 130   see_dims_s -> empty
Rule 131   generate_g_verify_f -> empty
Rule 132   generate_g_verify_s -> empty
Rule 133   dims_end -> empty
Rule 134   see_dims_a -> empty
Rule 135   see_dims_num -> empty
Rule 136   push_var -> empty
Rule 137   see_func_start -> empty
Rule 138   see_func_end -> empty
Rule 139   set_func_init -> empty
Rule 140   see_end_param -> empty
Rule 141   reset_dims -> empty
Rule 142   print_value -> empty
Rule 143   check_and_or -> empty
Rule 144   push_and_or -> empty
Rule 145   check_relational -> empty
Rule 146   push_relational -> empty
Rule 147   check_sum -> empty
Rule 148   push_sum -> empty
Rule 149   check_mul_div -> empty
Rule 150   push_mul_div -> empty
Rule 151   add_ff -> empty
Rule 152   pop_ff -> empty
Rule 153   push_int -> empty
Rule 154   push_float -> empty
Rule 155   push_bool -> empty
Rule 156   push_char -> empty
Rule 157   push_string -> empty
Rule 158   push_id -> empty
Rule 159   push_equal -> empty
Rule 160   generate_assign -> empty
Rule 161   generate_g_if -> empty
Rule 162   finish_if -> empty
Rule 163   generate_g_else -> empty
Rule 164   generate_g_read -> empty
Rule 165   generate_g_write -> empty
Rule 166   cloop_push_jump -> empty
Rule 167   generate_g_cloop_start -> empty
Rule 168   generate_g_cloop_end -> empty
Rule 169   generate_g_nloop_s -> empty
Rule 170   generate_g_nloop_e -> empty
Rule 171   generate_end -> empty
Rule 172   verify_func -> empty
Rule 173   activate_record -> empty
Rule 174   verify_params -> empty
Rule 175   increase_p_count -> empty
Rule 176   verify_p_num -> empty
Rule 177   main_goto -> empty
Rule 178   fill_main_goto -> empty
Rule 179   empty -> <empty>

Terminals, with rules where they appear

AND                  : 93
BOOL                 : 18 22
CHAR                 : 17 21
COL                  : 5
COMMA                : 10 13 37 43 70 76 82 84 84 84
COMMENT              : 
CTEB                 : 120
CTEC                 : 121
CTEF                 : 119
CTEI                 : 12 13 85 87 118
CTES                 : 81 84
DIV                  : 113
ELSE                 : 56
END                  : 126
EQUAL                : 39 65 98
FLOAT                : 16 20
FROM                 : 62
FUNC                 : 26
GREATERORQUAL        : 101
GREATERTHAN          : 100
ID                   : 1 7 26 33 39 62 67 73 84 86 88 116
IF                   : 55
INT                  : 15 19
ISEQUAL              : 97
LBRACK               : 12 42
LCURLY               : 24 26 126
LESSOREQUAL          : 103
LESSTHAN             : 102
LOADFILE             : 84
LPAR                 : 32 55 61 67 72 78 84 123 126
MAIN                 : 126
MINUS                : 108 122
NOTEQUAL             : 99
OR                   : 92
PLUS                 : 107
PROGRAM              : 1
RBRACK               : 12 42
RCURLY               : 24 26 126
READ                 : 72
RETURN               : 28
RPAR                 : 32 55 61 67 72 78 84 123 126
SEMICOL              : 1 5 28 39 54 72 78 84 126
TIMES                : 112
TO                   : 62
VAR                  : 5
VOID                 : 23
WHILE                : 61
WRITE                : 78
error                : 

Nonterminals, with rules where they appear

activate_record      : 67
add_ff               : 123
assign               : 47
assign_1             : 39
block                : 55 58 61 62
block_1              : 24
callfunc             : 54 117
callfunc_1           : 67 70
callfunc_3           : 68
check_and_or         : 89
check_mul_div        : 109
check_relational     : 94
check_sum            : 104
cloop                : 49
cloop_push_jump      : 61
cond                 : 48 59
cond_1               : 55
cond_2               : 56
cond_3               : 57
dims                 : 35 40 63 74 124
dims_1               : 42
dims_assign          : 8
dims_assign_1        : 12
dims_end             : 42
empty                : 4 6 9 11 14 29 31 34 36 38 41 44 46 60 64 66 69 71 75 77 83 91 96 106 111 125 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178
exp                  : 94 105
exp_1                : 104
exp_2                : 105
expression           : 28 39 42 43 55 61 62 65 68 80 90 123
expression_1         : 89
expression_2         : 90
factor               : 109
factor_1             : 114 122
factor_2             : 115
factor_3             : 116
fill_main_goto       : 126
finish_if            : 55
funcs                : 3 30
funcs_1              : 26
funcs_2              : 26
funcs_3              : 26
generate_assign      : 39 65
generate_end         : 126
generate_g_cloop_end : 61
generate_g_cloop_start : 61
generate_g_else      : 56
generate_g_if        : 55
generate_g_nloop_e   : 62
generate_g_nloop_s   : 62
generate_g_read      : 73
generate_g_verify_f  : 42
generate_g_verify_s  : 43
generate_g_write     : 79
increase_p_count     : 70
loadfile             : 53
loadfile_1           : 84
loadfile_2           : 84
main                 : 1
main_1               : 126
main_goto            : 1
nloop                : 50
nloop_1              : 62
nloop_2              : 62
params               : 26
params_1             : 32 37
params_2             : 33
params_3             : 33
pop_ff               : 123
print_value          : 116
program_start        : 0
program_start_1      : 1
program_start_2      : 1
push_and_or          : 90
push_bool            : 120
push_char            : 121
push_equal           : 39 65
push_float           : 119
push_id              : 39 62 65 73 116
push_int             : 118
push_mul_div         : 110
push_relational      : 95
push_string          : 81
push_sum             : 105
push_var             : 7
read                 : 51
read_1               : 72 76
read_2               : 73
read_3               : 73
reset_dims           : 33 74 116
rtype                : 26
see_dims             : 42
see_dims_a           : 12 13
see_dims_num         : 12 13
see_dims_s           : 43
see_end_param        : 33
see_func_end         : 26 126
see_func_start       : 26 126
see_id               : 7 26 33 39 62 67 73 116 126
set_func_init        : 26 126
sexp                 : 89 95
sexp_1               : 94
sexp_2               : 95
statement            : 25 26 45 126
statement_1          : 45
term                 : 104 110
term_1               : 109
term_2               : 110
type                 : 5 33
vars                 : 2 5 27 127
vars_1               : 5 10
vars_2               : 7
vars_3               : 7
verify_func          : 67
verify_p_num         : 67
verify_params        : 68
write                : 52
write_1              : 78 82
write_2              : 79
write_3              : 79

Parsing method: LALR

state 0

    (0) S' -> . program_start
    (1) program_start -> . main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main
    (177) main_goto -> . empty
    (179) empty -> .

    PROGRAM         reduce using rule 179 (empty -> .)

    program_start                  shift and go to state 1
    main_goto                      shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program_start .



state 2

    (1) program_start -> main_goto . PROGRAM ID SEMICOL program_start_1 program_start_2 main

    PROGRAM         shift and go to state 4


state 3

    (177) main_goto -> empty .

    PROGRAM         reduce using rule 177 (main_goto -> empty .)


state 4

    (1) program_start -> main_goto PROGRAM . ID SEMICOL program_start_1 program_start_2 main

    ID              shift and go to state 5


state 5

    (1) program_start -> main_goto PROGRAM ID . SEMICOL program_start_1 program_start_2 main

    SEMICOL         shift and go to state 6


state 6

    (1) program_start -> main_goto PROGRAM ID SEMICOL . program_start_1 program_start_2 main
    (2) program_start_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (179) empty -> .

    VAR             shift and go to state 9
    FUNC            reduce using rule 179 (empty -> .)
    MAIN            reduce using rule 179 (empty -> .)

    program_start_1                shift and go to state 7
    vars                           shift and go to state 8
    empty                          shift and go to state 10

state 7

    (1) program_start -> main_goto PROGRAM ID SEMICOL program_start_1 . program_start_2 main
    (3) program_start_2 -> . funcs
    (4) program_start_2 -> . empty
    (26) funcs -> . FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (179) empty -> .

    FUNC            shift and go to state 14
    MAIN            reduce using rule 179 (empty -> .)

    program_start_2                shift and go to state 11
    funcs                          shift and go to state 12
    empty                          shift and go to state 13

state 8

    (2) program_start_1 -> vars .

    FUNC            reduce using rule 2 (program_start_1 -> vars .)
    MAIN            reduce using rule 2 (program_start_1 -> vars .)


state 9

    (5) vars -> VAR . type COL vars_1 SEMICOL vars
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . CHAR
    (18) type -> . BOOL

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19

    type                           shift and go to state 15

state 10

    (6) vars -> empty .

    FUNC            reduce using rule 6 (vars -> empty .)
    MAIN            reduce using rule 6 (vars -> empty .)
    ID              reduce using rule 6 (vars -> empty .)
    IF              reduce using rule 6 (vars -> empty .)
    WHILE           reduce using rule 6 (vars -> empty .)
    FROM            reduce using rule 6 (vars -> empty .)
    READ            reduce using rule 6 (vars -> empty .)
    WRITE           reduce using rule 6 (vars -> empty .)
    LOADFILE        reduce using rule 6 (vars -> empty .)
    END             reduce using rule 6 (vars -> empty .)
    RETURN          reduce using rule 6 (vars -> empty .)
    RCURLY          reduce using rule 6 (vars -> empty .)


state 11

    (1) program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 . main
    (126) main -> . MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 12

    (3) program_start_2 -> funcs .

    MAIN            reduce using rule 3 (program_start_2 -> funcs .)


state 13

    (4) program_start_2 -> empty .

    MAIN            reduce using rule 4 (program_start_2 -> empty .)


state 14

    (26) funcs -> FUNC . rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (19) rtype -> . INT
    (20) rtype -> . FLOAT
    (21) rtype -> . CHAR
    (22) rtype -> . BOOL
    (23) rtype -> . VOID

    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    CHAR            shift and go to state 25
    BOOL            shift and go to state 26
    VOID            shift and go to state 27

    rtype                          shift and go to state 22

state 15

    (5) vars -> VAR type . COL vars_1 SEMICOL vars

    COL             shift and go to state 28


state 16

    (15) type -> INT .

    COL             reduce using rule 15 (type -> INT .)
    ID              reduce using rule 15 (type -> INT .)


state 17

    (16) type -> FLOAT .

    COL             reduce using rule 16 (type -> FLOAT .)
    ID              reduce using rule 16 (type -> FLOAT .)


state 18

    (17) type -> CHAR .

    COL             reduce using rule 17 (type -> CHAR .)
    ID              reduce using rule 17 (type -> CHAR .)


state 19

    (18) type -> BOOL .

    COL             reduce using rule 18 (type -> BOOL .)
    ID              reduce using rule 18 (type -> BOOL .)


state 20

    (1) program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main .

    $end            reduce using rule 1 (program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main .)


state 21

    (126) main -> MAIN . see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (128) see_id -> . empty
    (179) empty -> .

    LPAR            reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 29
    empty                          shift and go to state 30

state 22

    (26) funcs -> FUNC rtype . ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3

    ID              shift and go to state 31


state 23

    (19) rtype -> INT .

    ID              reduce using rule 19 (rtype -> INT .)


state 24

    (20) rtype -> FLOAT .

    ID              reduce using rule 20 (rtype -> FLOAT .)


state 25

    (21) rtype -> CHAR .

    ID              reduce using rule 21 (rtype -> CHAR .)


state 26

    (22) rtype -> BOOL .

    ID              reduce using rule 22 (rtype -> BOOL .)


state 27

    (23) rtype -> VOID .

    ID              reduce using rule 23 (rtype -> VOID .)


state 28

    (5) vars -> VAR type COL . vars_1 SEMICOL vars
    (7) vars_1 -> . ID see_id vars_2 push_var vars_3

    ID              shift and go to state 33

    vars_1                         shift and go to state 32

state 29

    (126) main -> MAIN see_id . LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    LPAR            shift and go to state 34


state 30

    (128) see_id -> empty .

    LPAR            reduce using rule 128 (see_id -> empty .)
    LBRACK          reduce using rule 128 (see_id -> empty .)
    COMMA           reduce using rule 128 (see_id -> empty .)
    SEMICOL         reduce using rule 128 (see_id -> empty .)
    RPAR            reduce using rule 128 (see_id -> empty .)
    EQUAL           reduce using rule 128 (see_id -> empty .)
    TO              reduce using rule 128 (see_id -> empty .)
    TIMES           reduce using rule 128 (see_id -> empty .)
    DIV             reduce using rule 128 (see_id -> empty .)
    PLUS            reduce using rule 128 (see_id -> empty .)
    MINUS           reduce using rule 128 (see_id -> empty .)
    ISEQUAL         reduce using rule 128 (see_id -> empty .)
    NOTEQUAL        reduce using rule 128 (see_id -> empty .)
    GREATERTHAN     reduce using rule 128 (see_id -> empty .)
    GREATERORQUAL   reduce using rule 128 (see_id -> empty .)
    LESSTHAN        reduce using rule 128 (see_id -> empty .)
    LESSOREQUAL     reduce using rule 128 (see_id -> empty .)
    OR              reduce using rule 128 (see_id -> empty .)
    AND             reduce using rule 128 (see_id -> empty .)
    RBRACK          reduce using rule 128 (see_id -> empty .)
    LCURLY          reduce using rule 128 (see_id -> empty .)


state 31

    (26) funcs -> FUNC rtype ID . see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (128) see_id -> . empty
    (179) empty -> .

    LPAR            reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 35
    empty                          shift and go to state 30

state 32

    (5) vars -> VAR type COL vars_1 . SEMICOL vars

    SEMICOL         shift and go to state 36


state 33

    (7) vars_1 -> ID . see_id vars_2 push_var vars_3
    (128) see_id -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 37
    empty                          shift and go to state 30

state 34

    (126) main -> MAIN see_id LPAR . RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    RPAR            shift and go to state 38


state 35

    (26) funcs -> FUNC rtype ID see_id . see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (137) see_func_start -> . empty
    (179) empty -> .

    LPAR            reduce using rule 179 (empty -> .)

    see_func_start                 shift and go to state 39
    empty                          shift and go to state 40

state 36

    (5) vars -> VAR type COL vars_1 SEMICOL . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (179) empty -> .

    VAR             shift and go to state 9
    FUNC            reduce using rule 179 (empty -> .)
    MAIN            reduce using rule 179 (empty -> .)
    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)

    vars                           shift and go to state 41
    empty                          shift and go to state 10

state 37

    (7) vars_1 -> ID see_id . vars_2 push_var vars_3
    (8) vars_2 -> . dims_assign
    (9) vars_2 -> . empty
    (12) dims_assign -> . LBRACK see_dims_a CTEI see_dims_num dims_assign_1 RBRACK
    (179) empty -> .

    LBRACK          shift and go to state 45
    COMMA           reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)

    vars_2                         shift and go to state 42
    dims_assign                    shift and go to state 43
    empty                          shift and go to state 44

state 38

    (126) main -> MAIN see_id LPAR RPAR . LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    LCURLY          shift and go to state 46


state 39

    (26) funcs -> FUNC rtype ID see_id see_func_start . params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (32) params -> . LPAR params_1 RPAR

    LPAR            shift and go to state 48

    params                         shift and go to state 47

state 40

    (137) see_func_start -> empty .

    LPAR            reduce using rule 137 (see_func_start -> empty .)
    VAR             reduce using rule 137 (see_func_start -> empty .)
    ID              reduce using rule 137 (see_func_start -> empty .)
    IF              reduce using rule 137 (see_func_start -> empty .)
    WHILE           reduce using rule 137 (see_func_start -> empty .)
    FROM            reduce using rule 137 (see_func_start -> empty .)
    READ            reduce using rule 137 (see_func_start -> empty .)
    WRITE           reduce using rule 137 (see_func_start -> empty .)
    LOADFILE        reduce using rule 137 (see_func_start -> empty .)
    END             reduce using rule 137 (see_func_start -> empty .)


state 41

    (5) vars -> VAR type COL vars_1 SEMICOL vars .

    FUNC            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    MAIN            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    ID              reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    IF              reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    WHILE           reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    FROM            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    READ            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    WRITE           reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    LOADFILE        reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    END             reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    RETURN          reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    RCURLY          reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)


state 42

    (7) vars_1 -> ID see_id vars_2 . push_var vars_3
    (136) push_var -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)

    push_var                       shift and go to state 49
    empty                          shift and go to state 50

state 43

    (8) vars_2 -> dims_assign .

    COMMA           reduce using rule 8 (vars_2 -> dims_assign .)
    SEMICOL         reduce using rule 8 (vars_2 -> dims_assign .)


state 44

    (9) vars_2 -> empty .

    COMMA           reduce using rule 9 (vars_2 -> empty .)
    SEMICOL         reduce using rule 9 (vars_2 -> empty .)


state 45

    (12) dims_assign -> LBRACK . see_dims_a CTEI see_dims_num dims_assign_1 RBRACK
    (134) see_dims_a -> . empty
    (179) empty -> .

    CTEI            reduce using rule 179 (empty -> .)

    see_dims_a                     shift and go to state 51
    empty                          shift and go to state 52

state 46

    (126) main -> MAIN see_id LPAR RPAR LCURLY . see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (137) see_func_start -> . empty
    (179) empty -> .

    VAR             reduce using rule 179 (empty -> .)
    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    see_func_start                 shift and go to state 53
    empty                          shift and go to state 40

state 47

    (26) funcs -> FUNC rtype ID see_id see_func_start params . LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3

    LCURLY          shift and go to state 54


state 48

    (32) params -> LPAR . params_1 RPAR
    (33) params_1 -> . type ID see_id params_2 see_end_param reset_dims params_3
    (34) params_1 -> . empty
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . CHAR
    (18) type -> . BOOL
    (179) empty -> .

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19
    RPAR            reduce using rule 179 (empty -> .)

    params_1                       shift and go to state 55
    type                           shift and go to state 56
    empty                          shift and go to state 57

state 49

    (7) vars_1 -> ID see_id vars_2 push_var . vars_3
    (10) vars_3 -> . COMMA vars_1
    (11) vars_3 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 59
    SEMICOL         reduce using rule 179 (empty -> .)

    vars_3                         shift and go to state 58
    empty                          shift and go to state 60

state 50

    (136) push_var -> empty .

    COMMA           reduce using rule 136 (push_var -> empty .)
    SEMICOL         reduce using rule 136 (push_var -> empty .)


state 51

    (12) dims_assign -> LBRACK see_dims_a . CTEI see_dims_num dims_assign_1 RBRACK

    CTEI            shift and go to state 61


state 52

    (134) see_dims_a -> empty .

    CTEI            reduce using rule 134 (see_dims_a -> empty .)


state 53

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start . main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (127) main_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (179) empty -> .

    VAR             shift and go to state 9
    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    main_1                         shift and go to state 62
    vars                           shift and go to state 63
    empty                          shift and go to state 10

state 54

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY . funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (27) funcs_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (179) empty -> .

    VAR             shift and go to state 9
    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)

    funcs_1                        shift and go to state 64
    vars                           shift and go to state 65
    empty                          shift and go to state 10

state 55

    (32) params -> LPAR params_1 . RPAR

    RPAR            shift and go to state 66


state 56

    (33) params_1 -> type . ID see_id params_2 see_end_param reset_dims params_3

    ID              shift and go to state 67


state 57

    (34) params_1 -> empty .

    RPAR            reduce using rule 34 (params_1 -> empty .)


state 58

    (7) vars_1 -> ID see_id vars_2 push_var vars_3 .

    SEMICOL         reduce using rule 7 (vars_1 -> ID see_id vars_2 push_var vars_3 .)


state 59

    (10) vars_3 -> COMMA . vars_1
    (7) vars_1 -> . ID see_id vars_2 push_var vars_3

    ID              shift and go to state 33

    vars_1                         shift and go to state 68

state 60

    (11) vars_3 -> empty .

    SEMICOL         reduce using rule 11 (vars_3 -> empty .)


state 61

    (12) dims_assign -> LBRACK see_dims_a CTEI . see_dims_num dims_assign_1 RBRACK
    (135) see_dims_num -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)

    see_dims_num                   shift and go to state 69
    empty                          shift and go to state 70

state 62

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 . set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (139) set_func_init -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    set_func_init                  shift and go to state 71
    empty                          shift and go to state 72

state 63

    (127) main_1 -> vars .

    ID              reduce using rule 127 (main_1 -> vars .)
    IF              reduce using rule 127 (main_1 -> vars .)
    WHILE           reduce using rule 127 (main_1 -> vars .)
    FROM            reduce using rule 127 (main_1 -> vars .)
    READ            reduce using rule 127 (main_1 -> vars .)
    WRITE           reduce using rule 127 (main_1 -> vars .)
    LOADFILE        reduce using rule 127 (main_1 -> vars .)
    END             reduce using rule 127 (main_1 -> vars .)


state 64

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 . set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (139) set_func_init -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)

    set_func_init                  shift and go to state 73
    empty                          shift and go to state 72

state 65

    (27) funcs_1 -> vars .

    ID              reduce using rule 27 (funcs_1 -> vars .)
    IF              reduce using rule 27 (funcs_1 -> vars .)
    WHILE           reduce using rule 27 (funcs_1 -> vars .)
    FROM            reduce using rule 27 (funcs_1 -> vars .)
    READ            reduce using rule 27 (funcs_1 -> vars .)
    WRITE           reduce using rule 27 (funcs_1 -> vars .)
    LOADFILE        reduce using rule 27 (funcs_1 -> vars .)
    RETURN          reduce using rule 27 (funcs_1 -> vars .)
    RCURLY          reduce using rule 27 (funcs_1 -> vars .)


state 66

    (32) params -> LPAR params_1 RPAR .

    LCURLY          reduce using rule 32 (params -> LPAR params_1 RPAR .)


state 67

    (33) params_1 -> type ID . see_id params_2 see_end_param reset_dims params_3
    (128) see_id -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 74
    empty                          shift and go to state 30

state 68

    (10) vars_3 -> COMMA vars_1 .

    SEMICOL         reduce using rule 10 (vars_3 -> COMMA vars_1 .)


state 69

    (12) dims_assign -> LBRACK see_dims_a CTEI see_dims_num . dims_assign_1 RBRACK
    (13) dims_assign_1 -> . COMMA see_dims_a CTEI see_dims_num
    (14) dims_assign_1 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 76
    RBRACK          reduce using rule 179 (empty -> .)

    dims_assign_1                  shift and go to state 75
    empty                          shift and go to state 77

state 70

    (135) see_dims_num -> empty .

    COMMA           reduce using rule 135 (see_dims_num -> empty .)
    RBRACK          reduce using rule 135 (see_dims_num -> empty .)


state 71

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init . fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (178) fill_main_goto -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    fill_main_goto                 shift and go to state 78
    empty                          shift and go to state 79

state 72

    (139) set_func_init -> empty .

    ID              reduce using rule 139 (set_func_init -> empty .)
    IF              reduce using rule 139 (set_func_init -> empty .)
    WHILE           reduce using rule 139 (set_func_init -> empty .)
    FROM            reduce using rule 139 (set_func_init -> empty .)
    READ            reduce using rule 139 (set_func_init -> empty .)
    WRITE           reduce using rule 139 (set_func_init -> empty .)
    LOADFILE        reduce using rule 139 (set_func_init -> empty .)
    END             reduce using rule 139 (set_func_init -> empty .)
    RETURN          reduce using rule 139 (set_func_init -> empty .)
    RCURLY          reduce using rule 139 (set_func_init -> empty .)


state 73

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init . statement funcs_2 see_func_end RCURLY funcs_3
    (45) statement -> . statement_1 statement
    (46) statement -> . empty
    (47) statement_1 -> . assign
    (48) statement_1 -> . cond
    (49) statement_1 -> . cloop
    (50) statement_1 -> . nloop
    (51) statement_1 -> . read
    (52) statement_1 -> . write
    (53) statement_1 -> . loadfile
    (54) statement_1 -> . callfunc SEMICOL
    (179) empty -> .
    (39) assign -> . ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (55) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (61) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (62) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (72) read -> . READ LPAR read_1 RPAR SEMICOL
    (78) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (84) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    ID              shift and go to state 80
    IF              shift and go to state 92
    WHILE           shift and go to state 93
    FROM            shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    LOADFILE        shift and go to state 97

    statement                      shift and go to state 81
    statement_1                    shift and go to state 82
    empty                          shift and go to state 83
    assign                         shift and go to state 84
    cond                           shift and go to state 85
    cloop                          shift and go to state 86
    nloop                          shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    loadfile                       shift and go to state 90
    callfunc                       shift and go to state 91

state 74

    (33) params_1 -> type ID see_id . params_2 see_end_param reset_dims params_3
    (35) params_2 -> . dims
    (36) params_2 -> . empty
    (42) dims -> . LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
    (179) empty -> .

    LBRACK          shift and go to state 101
    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    params_2                       shift and go to state 98
    dims                           shift and go to state 99
    empty                          shift and go to state 100

state 75

    (12) dims_assign -> LBRACK see_dims_a CTEI see_dims_num dims_assign_1 . RBRACK

    RBRACK          shift and go to state 102


state 76

    (13) dims_assign_1 -> COMMA . see_dims_a CTEI see_dims_num
    (134) see_dims_a -> . empty
    (179) empty -> .

    CTEI            reduce using rule 179 (empty -> .)

    see_dims_a                     shift and go to state 103
    empty                          shift and go to state 52

state 77

    (14) dims_assign_1 -> empty .

    RBRACK          reduce using rule 14 (dims_assign_1 -> empty .)


state 78

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto . statement END SEMICOL RCURLY see_func_end generate_end
    (45) statement -> . statement_1 statement
    (46) statement -> . empty
    (47) statement_1 -> . assign
    (48) statement_1 -> . cond
    (49) statement_1 -> . cloop
    (50) statement_1 -> . nloop
    (51) statement_1 -> . read
    (52) statement_1 -> . write
    (53) statement_1 -> . loadfile
    (54) statement_1 -> . callfunc SEMICOL
    (179) empty -> .
    (39) assign -> . ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (55) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (61) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (62) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (72) read -> . READ LPAR read_1 RPAR SEMICOL
    (78) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (84) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    END             reduce using rule 179 (empty -> .)
    ID              shift and go to state 80
    IF              shift and go to state 92
    WHILE           shift and go to state 93
    FROM            shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    LOADFILE        shift and go to state 97

    statement                      shift and go to state 104
    statement_1                    shift and go to state 82
    empty                          shift and go to state 83
    assign                         shift and go to state 84
    cond                           shift and go to state 85
    cloop                          shift and go to state 86
    nloop                          shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    loadfile                       shift and go to state 90
    callfunc                       shift and go to state 91

state 79

    (178) fill_main_goto -> empty .

    ID              reduce using rule 178 (fill_main_goto -> empty .)
    IF              reduce using rule 178 (fill_main_goto -> empty .)
    WHILE           reduce using rule 178 (fill_main_goto -> empty .)
    FROM            reduce using rule 178 (fill_main_goto -> empty .)
    READ            reduce using rule 178 (fill_main_goto -> empty .)
    WRITE           reduce using rule 178 (fill_main_goto -> empty .)
    LOADFILE        reduce using rule 178 (fill_main_goto -> empty .)
    END             reduce using rule 178 (fill_main_goto -> empty .)


state 80

    (39) assign -> ID . see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (67) callfunc -> ID . see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (128) see_id -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 105
    empty                          shift and go to state 30

state 81

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement . funcs_2 see_func_end RCURLY funcs_3
    (28) funcs_2 -> . RETURN expression SEMICOL
    (29) funcs_2 -> . empty
    (179) empty -> .

    RETURN          shift and go to state 107
    RCURLY          reduce using rule 179 (empty -> .)

    funcs_2                        shift and go to state 106
    empty                          shift and go to state 108

state 82

    (45) statement -> statement_1 . statement
    (45) statement -> . statement_1 statement
    (46) statement -> . empty
    (47) statement_1 -> . assign
    (48) statement_1 -> . cond
    (49) statement_1 -> . cloop
    (50) statement_1 -> . nloop
    (51) statement_1 -> . read
    (52) statement_1 -> . write
    (53) statement_1 -> . loadfile
    (54) statement_1 -> . callfunc SEMICOL
    (179) empty -> .
    (39) assign -> . ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (55) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (61) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (62) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (72) read -> . READ LPAR read_1 RPAR SEMICOL
    (78) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (84) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)
    ID              shift and go to state 80
    IF              shift and go to state 92
    WHILE           shift and go to state 93
    FROM            shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    LOADFILE        shift and go to state 97

    statement_1                    shift and go to state 82
    statement                      shift and go to state 109
    empty                          shift and go to state 83
    assign                         shift and go to state 84
    cond                           shift and go to state 85
    cloop                          shift and go to state 86
    nloop                          shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    loadfile                       shift and go to state 90
    callfunc                       shift and go to state 91

state 83

    (46) statement -> empty .

    RETURN          reduce using rule 46 (statement -> empty .)
    RCURLY          reduce using rule 46 (statement -> empty .)
    END             reduce using rule 46 (statement -> empty .)


state 84

    (47) statement_1 -> assign .

    ID              reduce using rule 47 (statement_1 -> assign .)
    IF              reduce using rule 47 (statement_1 -> assign .)
    WHILE           reduce using rule 47 (statement_1 -> assign .)
    FROM            reduce using rule 47 (statement_1 -> assign .)
    READ            reduce using rule 47 (statement_1 -> assign .)
    WRITE           reduce using rule 47 (statement_1 -> assign .)
    LOADFILE        reduce using rule 47 (statement_1 -> assign .)
    RETURN          reduce using rule 47 (statement_1 -> assign .)
    RCURLY          reduce using rule 47 (statement_1 -> assign .)
    END             reduce using rule 47 (statement_1 -> assign .)


state 85

    (48) statement_1 -> cond .

    ID              reduce using rule 48 (statement_1 -> cond .)
    IF              reduce using rule 48 (statement_1 -> cond .)
    WHILE           reduce using rule 48 (statement_1 -> cond .)
    FROM            reduce using rule 48 (statement_1 -> cond .)
    READ            reduce using rule 48 (statement_1 -> cond .)
    WRITE           reduce using rule 48 (statement_1 -> cond .)
    LOADFILE        reduce using rule 48 (statement_1 -> cond .)
    RETURN          reduce using rule 48 (statement_1 -> cond .)
    RCURLY          reduce using rule 48 (statement_1 -> cond .)
    END             reduce using rule 48 (statement_1 -> cond .)


state 86

    (49) statement_1 -> cloop .

    ID              reduce using rule 49 (statement_1 -> cloop .)
    IF              reduce using rule 49 (statement_1 -> cloop .)
    WHILE           reduce using rule 49 (statement_1 -> cloop .)
    FROM            reduce using rule 49 (statement_1 -> cloop .)
    READ            reduce using rule 49 (statement_1 -> cloop .)
    WRITE           reduce using rule 49 (statement_1 -> cloop .)
    LOADFILE        reduce using rule 49 (statement_1 -> cloop .)
    RETURN          reduce using rule 49 (statement_1 -> cloop .)
    RCURLY          reduce using rule 49 (statement_1 -> cloop .)
    END             reduce using rule 49 (statement_1 -> cloop .)


state 87

    (50) statement_1 -> nloop .

    ID              reduce using rule 50 (statement_1 -> nloop .)
    IF              reduce using rule 50 (statement_1 -> nloop .)
    WHILE           reduce using rule 50 (statement_1 -> nloop .)
    FROM            reduce using rule 50 (statement_1 -> nloop .)
    READ            reduce using rule 50 (statement_1 -> nloop .)
    WRITE           reduce using rule 50 (statement_1 -> nloop .)
    LOADFILE        reduce using rule 50 (statement_1 -> nloop .)
    RETURN          reduce using rule 50 (statement_1 -> nloop .)
    RCURLY          reduce using rule 50 (statement_1 -> nloop .)
    END             reduce using rule 50 (statement_1 -> nloop .)


state 88

    (51) statement_1 -> read .

    ID              reduce using rule 51 (statement_1 -> read .)
    IF              reduce using rule 51 (statement_1 -> read .)
    WHILE           reduce using rule 51 (statement_1 -> read .)
    FROM            reduce using rule 51 (statement_1 -> read .)
    READ            reduce using rule 51 (statement_1 -> read .)
    WRITE           reduce using rule 51 (statement_1 -> read .)
    LOADFILE        reduce using rule 51 (statement_1 -> read .)
    RETURN          reduce using rule 51 (statement_1 -> read .)
    RCURLY          reduce using rule 51 (statement_1 -> read .)
    END             reduce using rule 51 (statement_1 -> read .)


state 89

    (52) statement_1 -> write .

    ID              reduce using rule 52 (statement_1 -> write .)
    IF              reduce using rule 52 (statement_1 -> write .)
    WHILE           reduce using rule 52 (statement_1 -> write .)
    FROM            reduce using rule 52 (statement_1 -> write .)
    READ            reduce using rule 52 (statement_1 -> write .)
    WRITE           reduce using rule 52 (statement_1 -> write .)
    LOADFILE        reduce using rule 52 (statement_1 -> write .)
    RETURN          reduce using rule 52 (statement_1 -> write .)
    RCURLY          reduce using rule 52 (statement_1 -> write .)
    END             reduce using rule 52 (statement_1 -> write .)


state 90

    (53) statement_1 -> loadfile .

    ID              reduce using rule 53 (statement_1 -> loadfile .)
    IF              reduce using rule 53 (statement_1 -> loadfile .)
    WHILE           reduce using rule 53 (statement_1 -> loadfile .)
    FROM            reduce using rule 53 (statement_1 -> loadfile .)
    READ            reduce using rule 53 (statement_1 -> loadfile .)
    WRITE           reduce using rule 53 (statement_1 -> loadfile .)
    LOADFILE        reduce using rule 53 (statement_1 -> loadfile .)
    RETURN          reduce using rule 53 (statement_1 -> loadfile .)
    RCURLY          reduce using rule 53 (statement_1 -> loadfile .)
    END             reduce using rule 53 (statement_1 -> loadfile .)


state 91

    (54) statement_1 -> callfunc . SEMICOL

    SEMICOL         shift and go to state 110


state 92

    (55) cond -> IF . LPAR expression RPAR generate_g_if block cond_1 finish_if

    LPAR            shift and go to state 111


state 93

    (61) cloop -> WHILE . cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (166) cloop_push_jump -> . empty
    (179) empty -> .

    LPAR            reduce using rule 179 (empty -> .)

    cloop_push_jump                shift and go to state 112
    empty                          shift and go to state 113

state 94

    (62) nloop -> FROM . ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e

    ID              shift and go to state 114


state 95

    (72) read -> READ . LPAR read_1 RPAR SEMICOL

    LPAR            shift and go to state 115


state 96

    (78) write -> WRITE . LPAR write_1 RPAR SEMICOL

    LPAR            shift and go to state 116


state 97

    (84) loadfile -> LOADFILE . LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    LPAR            shift and go to state 117


state 98

    (33) params_1 -> type ID see_id params_2 . see_end_param reset_dims params_3
    (140) see_end_param -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    see_end_param                  shift and go to state 118
    empty                          shift and go to state 119

state 99

    (35) params_2 -> dims .

    COMMA           reduce using rule 35 (params_2 -> dims .)
    RPAR            reduce using rule 35 (params_2 -> dims .)


state 100

    (36) params_2 -> empty .

    COMMA           reduce using rule 36 (params_2 -> empty .)
    RPAR            reduce using rule 36 (params_2 -> empty .)


state 101

    (42) dims -> LBRACK . see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
    (129) see_dims -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    see_dims                       shift and go to state 120
    empty                          shift and go to state 121

state 102

    (12) dims_assign -> LBRACK see_dims_a CTEI see_dims_num dims_assign_1 RBRACK .

    COMMA           reduce using rule 12 (dims_assign -> LBRACK see_dims_a CTEI see_dims_num dims_assign_1 RBRACK .)
    SEMICOL         reduce using rule 12 (dims_assign -> LBRACK see_dims_a CTEI see_dims_num dims_assign_1 RBRACK .)


state 103

    (13) dims_assign_1 -> COMMA see_dims_a . CTEI see_dims_num

    CTEI            shift and go to state 122


state 104

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement . END SEMICOL RCURLY see_func_end generate_end

    END             shift and go to state 123


state 105

    (39) assign -> ID see_id . push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (67) callfunc -> ID see_id . verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (158) push_id -> . empty
    (172) verify_func -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_id                        shift and go to state 124
    verify_func                    shift and go to state 125
    empty                          shift and go to state 126

state 106

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 . see_func_end RCURLY funcs_3
    (138) see_func_end -> . empty
    (179) empty -> .

    RCURLY          reduce using rule 179 (empty -> .)

    see_func_end                   shift and go to state 127
    empty                          shift and go to state 128

state 107

    (28) funcs_2 -> RETURN . expression SEMICOL
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 129
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 108

    (29) funcs_2 -> empty .

    RCURLY          reduce using rule 29 (funcs_2 -> empty .)


state 109

    (45) statement -> statement_1 statement .

    RETURN          reduce using rule 45 (statement -> statement_1 statement .)
    RCURLY          reduce using rule 45 (statement -> statement_1 statement .)
    END             reduce using rule 45 (statement -> statement_1 statement .)


state 110

    (54) statement_1 -> callfunc SEMICOL .

    ID              reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    IF              reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    WHILE           reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    FROM            reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    READ            reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    WRITE           reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    LOADFILE        reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    RETURN          reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    RCURLY          reduce using rule 54 (statement_1 -> callfunc SEMICOL .)
    END             reduce using rule 54 (statement_1 -> callfunc SEMICOL .)


state 111

    (55) cond -> IF LPAR . expression RPAR generate_g_if block cond_1 finish_if
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 144
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 112

    (61) cloop -> WHILE cloop_push_jump . LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end

    LPAR            shift and go to state 145


state 113

    (166) cloop_push_jump -> empty .

    LPAR            reduce using rule 166 (cloop_push_jump -> empty .)


state 114

    (62) nloop -> FROM ID . see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (128) see_id -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 146
    empty                          shift and go to state 30

state 115

    (72) read -> READ LPAR . read_1 RPAR SEMICOL
    (73) read_1 -> . ID see_id read_2 push_id generate_g_read read_3

    ID              shift and go to state 148

    read_1                         shift and go to state 147

state 116

    (78) write -> WRITE LPAR . write_1 RPAR SEMICOL
    (79) write_1 -> . write_2 generate_g_write write_3
    (80) write_2 -> . expression
    (81) write_2 -> . CTES push_string
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    CTES            shift and go to state 152
    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    write_1                        shift and go to state 149
    write_2                        shift and go to state 150
    expression                     shift and go to state 151
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 117

    (84) loadfile -> LOADFILE LPAR . ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    ID              shift and go to state 153


state 118

    (33) params_1 -> type ID see_id params_2 see_end_param . reset_dims params_3
    (141) reset_dims -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    reset_dims                     shift and go to state 154
    empty                          shift and go to state 155

state 119

    (140) see_end_param -> empty .

    COMMA           reduce using rule 140 (see_end_param -> empty .)
    RPAR            reduce using rule 140 (see_end_param -> empty .)


state 120

    (42) dims -> LBRACK see_dims . expression generate_g_verify_f dims_1 RBRACK dims_end
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 156
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 121

    (129) see_dims -> empty .

    ID              reduce using rule 129 (see_dims -> empty .)
    CTEI            reduce using rule 129 (see_dims -> empty .)
    CTEF            reduce using rule 129 (see_dims -> empty .)
    CTEB            reduce using rule 129 (see_dims -> empty .)
    CTEC            reduce using rule 129 (see_dims -> empty .)
    MINUS           reduce using rule 129 (see_dims -> empty .)
    LPAR            reduce using rule 129 (see_dims -> empty .)


state 122

    (13) dims_assign_1 -> COMMA see_dims_a CTEI . see_dims_num
    (135) see_dims_num -> . empty
    (179) empty -> .

    RBRACK          reduce using rule 179 (empty -> .)

    see_dims_num                   shift and go to state 157
    empty                          shift and go to state 70

state 123

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END . SEMICOL RCURLY see_func_end generate_end

    SEMICOL         shift and go to state 158


state 124

    (39) assign -> ID see_id push_id . assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (40) assign_1 -> . dims
    (41) assign_1 -> . empty
    (42) dims -> . LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
    (179) empty -> .

    LBRACK          shift and go to state 101
    EQUAL           reduce using rule 179 (empty -> .)

    assign_1                       shift and go to state 159
    dims                           shift and go to state 160
    empty                          shift and go to state 161

state 125

    (67) callfunc -> ID see_id verify_func . LPAR activate_record callfunc_1 verify_p_num RPAR

    LPAR            shift and go to state 162


state 126

    (158) push_id -> empty .
    (172) verify_func -> empty .

    LBRACK          reduce using rule 158 (push_id -> empty .)
    EQUAL           reduce using rule 158 (push_id -> empty .)
    TIMES           reduce using rule 158 (push_id -> empty .)
    DIV             reduce using rule 158 (push_id -> empty .)
    PLUS            reduce using rule 158 (push_id -> empty .)
    MINUS           reduce using rule 158 (push_id -> empty .)
    ISEQUAL         reduce using rule 158 (push_id -> empty .)
    NOTEQUAL        reduce using rule 158 (push_id -> empty .)
    GREATERTHAN     reduce using rule 158 (push_id -> empty .)
    GREATERORQUAL   reduce using rule 158 (push_id -> empty .)
    LESSTHAN        reduce using rule 158 (push_id -> empty .)
    LESSOREQUAL     reduce using rule 158 (push_id -> empty .)
    OR              reduce using rule 158 (push_id -> empty .)
    AND             reduce using rule 158 (push_id -> empty .)
    SEMICOL         reduce using rule 158 (push_id -> empty .)
    RPAR            reduce using rule 158 (push_id -> empty .)
    COMMA           reduce using rule 158 (push_id -> empty .)
    RBRACK          reduce using rule 158 (push_id -> empty .)
    LCURLY          reduce using rule 158 (push_id -> empty .)
    TO              reduce using rule 158 (push_id -> empty .)
    LPAR            reduce using rule 172 (verify_func -> empty .)


state 127

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end . RCURLY funcs_3

    RCURLY          shift and go to state 163


state 128

    (138) see_func_end -> empty .

    RCURLY          reduce using rule 138 (see_func_end -> empty .)
    $end            reduce using rule 138 (see_func_end -> empty .)


state 129

    (28) funcs_2 -> RETURN expression . SEMICOL

    SEMICOL         shift and go to state 164


state 130

    (89) expression -> sexp . check_and_or expression_1
    (143) check_and_or -> . empty
    (179) empty -> .

    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    check_and_or                   shift and go to state 165
    empty                          shift and go to state 166

state 131

    (94) sexp -> exp . check_relational sexp_1
    (145) check_relational -> . empty
    (179) empty -> .

    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    check_relational               shift and go to state 167
    empty                          shift and go to state 168

state 132

    (104) exp -> term . check_sum exp_1
    (147) check_sum -> . empty
    (179) empty -> .

    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    check_sum                      shift and go to state 169
    empty                          shift and go to state 170

state 133

    (109) term -> factor . check_mul_div term_1
    (149) check_mul_div -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    check_mul_div                  shift and go to state 171
    empty                          shift and go to state 172

state 134

    (114) factor -> factor_1 .

    TIMES           reduce using rule 114 (factor -> factor_1 .)
    DIV             reduce using rule 114 (factor -> factor_1 .)
    PLUS            reduce using rule 114 (factor -> factor_1 .)
    MINUS           reduce using rule 114 (factor -> factor_1 .)
    ISEQUAL         reduce using rule 114 (factor -> factor_1 .)
    EQUAL           reduce using rule 114 (factor -> factor_1 .)
    NOTEQUAL        reduce using rule 114 (factor -> factor_1 .)
    GREATERTHAN     reduce using rule 114 (factor -> factor_1 .)
    GREATERORQUAL   reduce using rule 114 (factor -> factor_1 .)
    LESSTHAN        reduce using rule 114 (factor -> factor_1 .)
    LESSOREQUAL     reduce using rule 114 (factor -> factor_1 .)
    OR              reduce using rule 114 (factor -> factor_1 .)
    AND             reduce using rule 114 (factor -> factor_1 .)
    SEMICOL         reduce using rule 114 (factor -> factor_1 .)
    RPAR            reduce using rule 114 (factor -> factor_1 .)
    COMMA           reduce using rule 114 (factor -> factor_1 .)
    RBRACK          reduce using rule 114 (factor -> factor_1 .)
    LCURLY          reduce using rule 114 (factor -> factor_1 .)
    TO              reduce using rule 114 (factor -> factor_1 .)


state 135

    (115) factor -> factor_2 .

    TIMES           reduce using rule 115 (factor -> factor_2 .)
    DIV             reduce using rule 115 (factor -> factor_2 .)
    PLUS            reduce using rule 115 (factor -> factor_2 .)
    MINUS           reduce using rule 115 (factor -> factor_2 .)
    ISEQUAL         reduce using rule 115 (factor -> factor_2 .)
    EQUAL           reduce using rule 115 (factor -> factor_2 .)
    NOTEQUAL        reduce using rule 115 (factor -> factor_2 .)
    GREATERTHAN     reduce using rule 115 (factor -> factor_2 .)
    GREATERORQUAL   reduce using rule 115 (factor -> factor_2 .)
    LESSTHAN        reduce using rule 115 (factor -> factor_2 .)
    LESSOREQUAL     reduce using rule 115 (factor -> factor_2 .)
    OR              reduce using rule 115 (factor -> factor_2 .)
    AND             reduce using rule 115 (factor -> factor_2 .)
    SEMICOL         reduce using rule 115 (factor -> factor_2 .)
    RPAR            reduce using rule 115 (factor -> factor_2 .)
    COMMA           reduce using rule 115 (factor -> factor_2 .)
    RBRACK          reduce using rule 115 (factor -> factor_2 .)
    LCURLY          reduce using rule 115 (factor -> factor_2 .)
    TO              reduce using rule 115 (factor -> factor_2 .)


state 136

    (116) factor_1 -> ID . see_id push_id factor_3 print_value reset_dims
    (67) callfunc -> ID . see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (128) see_id -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)
    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 173
    empty                          shift and go to state 30

state 137

    (117) factor_1 -> callfunc .

    TIMES           reduce using rule 117 (factor_1 -> callfunc .)
    DIV             reduce using rule 117 (factor_1 -> callfunc .)
    PLUS            reduce using rule 117 (factor_1 -> callfunc .)
    MINUS           reduce using rule 117 (factor_1 -> callfunc .)
    ISEQUAL         reduce using rule 117 (factor_1 -> callfunc .)
    EQUAL           reduce using rule 117 (factor_1 -> callfunc .)
    NOTEQUAL        reduce using rule 117 (factor_1 -> callfunc .)
    GREATERTHAN     reduce using rule 117 (factor_1 -> callfunc .)
    GREATERORQUAL   reduce using rule 117 (factor_1 -> callfunc .)
    LESSTHAN        reduce using rule 117 (factor_1 -> callfunc .)
    LESSOREQUAL     reduce using rule 117 (factor_1 -> callfunc .)
    OR              reduce using rule 117 (factor_1 -> callfunc .)
    AND             reduce using rule 117 (factor_1 -> callfunc .)
    SEMICOL         reduce using rule 117 (factor_1 -> callfunc .)
    RPAR            reduce using rule 117 (factor_1 -> callfunc .)
    COMMA           reduce using rule 117 (factor_1 -> callfunc .)
    RBRACK          reduce using rule 117 (factor_1 -> callfunc .)
    LCURLY          reduce using rule 117 (factor_1 -> callfunc .)
    TO              reduce using rule 117 (factor_1 -> callfunc .)


state 138

    (118) factor_1 -> CTEI . push_int
    (153) push_int -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    push_int                       shift and go to state 174
    empty                          shift and go to state 175

state 139

    (119) factor_1 -> CTEF . push_float
    (154) push_float -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    push_float                     shift and go to state 176
    empty                          shift and go to state 177

state 140

    (120) factor_1 -> CTEB . push_bool
    (155) push_bool -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    push_bool                      shift and go to state 178
    empty                          shift and go to state 179

state 141

    (121) factor_1 -> CTEC . push_char
    (156) push_char -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    push_char                      shift and go to state 180
    empty                          shift and go to state 181

state 142

    (122) factor_1 -> MINUS . factor_1
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142

    factor_1                       shift and go to state 182
    callfunc                       shift and go to state 137

state 143

    (123) factor_2 -> LPAR . add_ff expression RPAR pop_ff
    (151) add_ff -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    add_ff                         shift and go to state 183
    empty                          shift and go to state 184

state 144

    (55) cond -> IF LPAR expression . RPAR generate_g_if block cond_1 finish_if

    RPAR            shift and go to state 185


state 145

    (61) cloop -> WHILE cloop_push_jump LPAR . expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 186
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 146

    (62) nloop -> FROM ID see_id . nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (63) nloop_1 -> . dims
    (64) nloop_1 -> . empty
    (42) dims -> . LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
    (179) empty -> .

    LBRACK          shift and go to state 101
    TO              reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)

    nloop_1                        shift and go to state 187
    dims                           shift and go to state 188
    empty                          shift and go to state 189

state 147

    (72) read -> READ LPAR read_1 . RPAR SEMICOL

    RPAR            shift and go to state 190


state 148

    (73) read_1 -> ID . see_id read_2 push_id generate_g_read read_3
    (128) see_id -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    see_id                         shift and go to state 191
    empty                          shift and go to state 30

state 149

    (78) write -> WRITE LPAR write_1 . RPAR SEMICOL

    RPAR            shift and go to state 192


state 150

    (79) write_1 -> write_2 . generate_g_write write_3
    (165) generate_g_write -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    generate_g_write               shift and go to state 193
    empty                          shift and go to state 194

state 151

    (80) write_2 -> expression .

    COMMA           reduce using rule 80 (write_2 -> expression .)
    RPAR            reduce using rule 80 (write_2 -> expression .)


state 152

    (81) write_2 -> CTES . push_string
    (157) push_string -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    push_string                    shift and go to state 195
    empty                          shift and go to state 196

state 153

    (84) loadfile -> LOADFILE LPAR ID . COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 197


state 154

    (33) params_1 -> type ID see_id params_2 see_end_param reset_dims . params_3
    (37) params_3 -> . COMMA params_1
    (38) params_3 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 199
    RPAR            reduce using rule 179 (empty -> .)

    params_3                       shift and go to state 198
    empty                          shift and go to state 200

state 155

    (141) reset_dims -> empty .

    COMMA           reduce using rule 141 (reset_dims -> empty .)
    RPAR            reduce using rule 141 (reset_dims -> empty .)
    TIMES           reduce using rule 141 (reset_dims -> empty .)
    DIV             reduce using rule 141 (reset_dims -> empty .)
    PLUS            reduce using rule 141 (reset_dims -> empty .)
    MINUS           reduce using rule 141 (reset_dims -> empty .)
    ISEQUAL         reduce using rule 141 (reset_dims -> empty .)
    EQUAL           reduce using rule 141 (reset_dims -> empty .)
    NOTEQUAL        reduce using rule 141 (reset_dims -> empty .)
    GREATERTHAN     reduce using rule 141 (reset_dims -> empty .)
    GREATERORQUAL   reduce using rule 141 (reset_dims -> empty .)
    LESSTHAN        reduce using rule 141 (reset_dims -> empty .)
    LESSOREQUAL     reduce using rule 141 (reset_dims -> empty .)
    OR              reduce using rule 141 (reset_dims -> empty .)
    AND             reduce using rule 141 (reset_dims -> empty .)
    SEMICOL         reduce using rule 141 (reset_dims -> empty .)
    RBRACK          reduce using rule 141 (reset_dims -> empty .)
    LCURLY          reduce using rule 141 (reset_dims -> empty .)
    TO              reduce using rule 141 (reset_dims -> empty .)


state 156

    (42) dims -> LBRACK see_dims expression . generate_g_verify_f dims_1 RBRACK dims_end
    (131) generate_g_verify_f -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)

    generate_g_verify_f            shift and go to state 201
    empty                          shift and go to state 202

state 157

    (13) dims_assign_1 -> COMMA see_dims_a CTEI see_dims_num .

    RBRACK          reduce using rule 13 (dims_assign_1 -> COMMA see_dims_a CTEI see_dims_num .)


state 158

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL . RCURLY see_func_end generate_end

    RCURLY          shift and go to state 203


state 159

    (39) assign -> ID see_id push_id assign_1 . EQUAL push_equal expression generate_assign SEMICOL

    EQUAL           shift and go to state 204


state 160

    (40) assign_1 -> dims .

    EQUAL           reduce using rule 40 (assign_1 -> dims .)


state 161

    (41) assign_1 -> empty .

    EQUAL           reduce using rule 41 (assign_1 -> empty .)


state 162

    (67) callfunc -> ID see_id verify_func LPAR . activate_record callfunc_1 verify_p_num RPAR
    (173) activate_record -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    activate_record                shift and go to state 205
    empty                          shift and go to state 206

state 163

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY . funcs_3
    (30) funcs_3 -> . funcs
    (31) funcs_3 -> . empty
    (26) funcs -> . FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (179) empty -> .

    FUNC            shift and go to state 14
    MAIN            reduce using rule 179 (empty -> .)

    funcs_3                        shift and go to state 207
    funcs                          shift and go to state 208
    empty                          shift and go to state 209

state 164

    (28) funcs_2 -> RETURN expression SEMICOL .

    RCURLY          reduce using rule 28 (funcs_2 -> RETURN expression SEMICOL .)


state 165

    (89) expression -> sexp check_and_or . expression_1
    (90) expression_1 -> . expression_2 push_and_or expression
    (91) expression_1 -> . empty
    (92) expression_2 -> . OR
    (93) expression_2 -> . AND
    (179) empty -> .

    OR              shift and go to state 213
    AND             shift and go to state 214
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    expression_1                   shift and go to state 210
    expression_2                   shift and go to state 211
    empty                          shift and go to state 212

state 166

    (143) check_and_or -> empty .

    OR              reduce using rule 143 (check_and_or -> empty .)
    AND             reduce using rule 143 (check_and_or -> empty .)
    SEMICOL         reduce using rule 143 (check_and_or -> empty .)
    RPAR            reduce using rule 143 (check_and_or -> empty .)
    COMMA           reduce using rule 143 (check_and_or -> empty .)
    RBRACK          reduce using rule 143 (check_and_or -> empty .)
    LCURLY          reduce using rule 143 (check_and_or -> empty .)
    TO              reduce using rule 143 (check_and_or -> empty .)


state 167

    (94) sexp -> exp check_relational . sexp_1
    (95) sexp_1 -> . sexp_2 push_relational sexp
    (96) sexp_1 -> . empty
    (97) sexp_2 -> . ISEQUAL
    (98) sexp_2 -> . EQUAL
    (99) sexp_2 -> . NOTEQUAL
    (100) sexp_2 -> . GREATERTHAN
    (101) sexp_2 -> . GREATERORQUAL
    (102) sexp_2 -> . LESSTHAN
    (103) sexp_2 -> . LESSOREQUAL
    (179) empty -> .

    ISEQUAL         shift and go to state 218
    EQUAL           shift and go to state 219
    NOTEQUAL        shift and go to state 220
    GREATERTHAN     shift and go to state 221
    GREATERORQUAL   shift and go to state 222
    LESSTHAN        shift and go to state 223
    LESSOREQUAL     shift and go to state 224
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    sexp_1                         shift and go to state 215
    sexp_2                         shift and go to state 216
    empty                          shift and go to state 217

state 168

    (145) check_relational -> empty .

    ISEQUAL         reduce using rule 145 (check_relational -> empty .)
    EQUAL           reduce using rule 145 (check_relational -> empty .)
    NOTEQUAL        reduce using rule 145 (check_relational -> empty .)
    GREATERTHAN     reduce using rule 145 (check_relational -> empty .)
    GREATERORQUAL   reduce using rule 145 (check_relational -> empty .)
    LESSTHAN        reduce using rule 145 (check_relational -> empty .)
    LESSOREQUAL     reduce using rule 145 (check_relational -> empty .)
    OR              reduce using rule 145 (check_relational -> empty .)
    AND             reduce using rule 145 (check_relational -> empty .)
    SEMICOL         reduce using rule 145 (check_relational -> empty .)
    RPAR            reduce using rule 145 (check_relational -> empty .)
    COMMA           reduce using rule 145 (check_relational -> empty .)
    RBRACK          reduce using rule 145 (check_relational -> empty .)
    LCURLY          reduce using rule 145 (check_relational -> empty .)
    TO              reduce using rule 145 (check_relational -> empty .)


state 169

    (104) exp -> term check_sum . exp_1
    (105) exp_1 -> . exp_2 push_sum exp
    (106) exp_1 -> . empty
    (107) exp_2 -> . PLUS
    (108) exp_2 -> . MINUS
    (179) empty -> .

    PLUS            shift and go to state 228
    MINUS           shift and go to state 229
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    exp_1                          shift and go to state 225
    exp_2                          shift and go to state 226
    empty                          shift and go to state 227

state 170

    (147) check_sum -> empty .

    PLUS            reduce using rule 147 (check_sum -> empty .)
    MINUS           reduce using rule 147 (check_sum -> empty .)
    ISEQUAL         reduce using rule 147 (check_sum -> empty .)
    EQUAL           reduce using rule 147 (check_sum -> empty .)
    NOTEQUAL        reduce using rule 147 (check_sum -> empty .)
    GREATERTHAN     reduce using rule 147 (check_sum -> empty .)
    GREATERORQUAL   reduce using rule 147 (check_sum -> empty .)
    LESSTHAN        reduce using rule 147 (check_sum -> empty .)
    LESSOREQUAL     reduce using rule 147 (check_sum -> empty .)
    OR              reduce using rule 147 (check_sum -> empty .)
    AND             reduce using rule 147 (check_sum -> empty .)
    SEMICOL         reduce using rule 147 (check_sum -> empty .)
    RPAR            reduce using rule 147 (check_sum -> empty .)
    COMMA           reduce using rule 147 (check_sum -> empty .)
    RBRACK          reduce using rule 147 (check_sum -> empty .)
    LCURLY          reduce using rule 147 (check_sum -> empty .)
    TO              reduce using rule 147 (check_sum -> empty .)


state 171

    (109) term -> factor check_mul_div . term_1
    (110) term_1 -> . term_2 push_mul_div term
    (111) term_1 -> . empty
    (112) term_2 -> . TIMES
    (113) term_2 -> . DIV
    (179) empty -> .

    TIMES           shift and go to state 233
    DIV             shift and go to state 234
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    term_1                         shift and go to state 230
    term_2                         shift and go to state 231
    empty                          shift and go to state 232

state 172

    (149) check_mul_div -> empty .

    TIMES           reduce using rule 149 (check_mul_div -> empty .)
    DIV             reduce using rule 149 (check_mul_div -> empty .)
    PLUS            reduce using rule 149 (check_mul_div -> empty .)
    MINUS           reduce using rule 149 (check_mul_div -> empty .)
    ISEQUAL         reduce using rule 149 (check_mul_div -> empty .)
    EQUAL           reduce using rule 149 (check_mul_div -> empty .)
    NOTEQUAL        reduce using rule 149 (check_mul_div -> empty .)
    GREATERTHAN     reduce using rule 149 (check_mul_div -> empty .)
    GREATERORQUAL   reduce using rule 149 (check_mul_div -> empty .)
    LESSTHAN        reduce using rule 149 (check_mul_div -> empty .)
    LESSOREQUAL     reduce using rule 149 (check_mul_div -> empty .)
    OR              reduce using rule 149 (check_mul_div -> empty .)
    AND             reduce using rule 149 (check_mul_div -> empty .)
    SEMICOL         reduce using rule 149 (check_mul_div -> empty .)
    RPAR            reduce using rule 149 (check_mul_div -> empty .)
    COMMA           reduce using rule 149 (check_mul_div -> empty .)
    RBRACK          reduce using rule 149 (check_mul_div -> empty .)
    LCURLY          reduce using rule 149 (check_mul_div -> empty .)
    TO              reduce using rule 149 (check_mul_div -> empty .)


state 173

    (116) factor_1 -> ID see_id . push_id factor_3 print_value reset_dims
    (67) callfunc -> ID see_id . verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (158) push_id -> . empty
    (172) verify_func -> . empty
    (179) empty -> .

    LBRACK          reduce using rule 179 (empty -> .)
    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_id                        shift and go to state 235
    verify_func                    shift and go to state 125
    empty                          shift and go to state 126

state 174

    (118) factor_1 -> CTEI push_int .

    TIMES           reduce using rule 118 (factor_1 -> CTEI push_int .)
    DIV             reduce using rule 118 (factor_1 -> CTEI push_int .)
    PLUS            reduce using rule 118 (factor_1 -> CTEI push_int .)
    MINUS           reduce using rule 118 (factor_1 -> CTEI push_int .)
    ISEQUAL         reduce using rule 118 (factor_1 -> CTEI push_int .)
    EQUAL           reduce using rule 118 (factor_1 -> CTEI push_int .)
    NOTEQUAL        reduce using rule 118 (factor_1 -> CTEI push_int .)
    GREATERTHAN     reduce using rule 118 (factor_1 -> CTEI push_int .)
    GREATERORQUAL   reduce using rule 118 (factor_1 -> CTEI push_int .)
    LESSTHAN        reduce using rule 118 (factor_1 -> CTEI push_int .)
    LESSOREQUAL     reduce using rule 118 (factor_1 -> CTEI push_int .)
    OR              reduce using rule 118 (factor_1 -> CTEI push_int .)
    AND             reduce using rule 118 (factor_1 -> CTEI push_int .)
    SEMICOL         reduce using rule 118 (factor_1 -> CTEI push_int .)
    RPAR            reduce using rule 118 (factor_1 -> CTEI push_int .)
    COMMA           reduce using rule 118 (factor_1 -> CTEI push_int .)
    RBRACK          reduce using rule 118 (factor_1 -> CTEI push_int .)
    LCURLY          reduce using rule 118 (factor_1 -> CTEI push_int .)
    TO              reduce using rule 118 (factor_1 -> CTEI push_int .)


state 175

    (153) push_int -> empty .

    TIMES           reduce using rule 153 (push_int -> empty .)
    DIV             reduce using rule 153 (push_int -> empty .)
    PLUS            reduce using rule 153 (push_int -> empty .)
    MINUS           reduce using rule 153 (push_int -> empty .)
    ISEQUAL         reduce using rule 153 (push_int -> empty .)
    EQUAL           reduce using rule 153 (push_int -> empty .)
    NOTEQUAL        reduce using rule 153 (push_int -> empty .)
    GREATERTHAN     reduce using rule 153 (push_int -> empty .)
    GREATERORQUAL   reduce using rule 153 (push_int -> empty .)
    LESSTHAN        reduce using rule 153 (push_int -> empty .)
    LESSOREQUAL     reduce using rule 153 (push_int -> empty .)
    OR              reduce using rule 153 (push_int -> empty .)
    AND             reduce using rule 153 (push_int -> empty .)
    SEMICOL         reduce using rule 153 (push_int -> empty .)
    RPAR            reduce using rule 153 (push_int -> empty .)
    COMMA           reduce using rule 153 (push_int -> empty .)
    RBRACK          reduce using rule 153 (push_int -> empty .)
    LCURLY          reduce using rule 153 (push_int -> empty .)
    TO              reduce using rule 153 (push_int -> empty .)


state 176

    (119) factor_1 -> CTEF push_float .

    TIMES           reduce using rule 119 (factor_1 -> CTEF push_float .)
    DIV             reduce using rule 119 (factor_1 -> CTEF push_float .)
    PLUS            reduce using rule 119 (factor_1 -> CTEF push_float .)
    MINUS           reduce using rule 119 (factor_1 -> CTEF push_float .)
    ISEQUAL         reduce using rule 119 (factor_1 -> CTEF push_float .)
    EQUAL           reduce using rule 119 (factor_1 -> CTEF push_float .)
    NOTEQUAL        reduce using rule 119 (factor_1 -> CTEF push_float .)
    GREATERTHAN     reduce using rule 119 (factor_1 -> CTEF push_float .)
    GREATERORQUAL   reduce using rule 119 (factor_1 -> CTEF push_float .)
    LESSTHAN        reduce using rule 119 (factor_1 -> CTEF push_float .)
    LESSOREQUAL     reduce using rule 119 (factor_1 -> CTEF push_float .)
    OR              reduce using rule 119 (factor_1 -> CTEF push_float .)
    AND             reduce using rule 119 (factor_1 -> CTEF push_float .)
    SEMICOL         reduce using rule 119 (factor_1 -> CTEF push_float .)
    RPAR            reduce using rule 119 (factor_1 -> CTEF push_float .)
    COMMA           reduce using rule 119 (factor_1 -> CTEF push_float .)
    RBRACK          reduce using rule 119 (factor_1 -> CTEF push_float .)
    LCURLY          reduce using rule 119 (factor_1 -> CTEF push_float .)
    TO              reduce using rule 119 (factor_1 -> CTEF push_float .)


state 177

    (154) push_float -> empty .

    TIMES           reduce using rule 154 (push_float -> empty .)
    DIV             reduce using rule 154 (push_float -> empty .)
    PLUS            reduce using rule 154 (push_float -> empty .)
    MINUS           reduce using rule 154 (push_float -> empty .)
    ISEQUAL         reduce using rule 154 (push_float -> empty .)
    EQUAL           reduce using rule 154 (push_float -> empty .)
    NOTEQUAL        reduce using rule 154 (push_float -> empty .)
    GREATERTHAN     reduce using rule 154 (push_float -> empty .)
    GREATERORQUAL   reduce using rule 154 (push_float -> empty .)
    LESSTHAN        reduce using rule 154 (push_float -> empty .)
    LESSOREQUAL     reduce using rule 154 (push_float -> empty .)
    OR              reduce using rule 154 (push_float -> empty .)
    AND             reduce using rule 154 (push_float -> empty .)
    SEMICOL         reduce using rule 154 (push_float -> empty .)
    RPAR            reduce using rule 154 (push_float -> empty .)
    COMMA           reduce using rule 154 (push_float -> empty .)
    RBRACK          reduce using rule 154 (push_float -> empty .)
    LCURLY          reduce using rule 154 (push_float -> empty .)
    TO              reduce using rule 154 (push_float -> empty .)


state 178

    (120) factor_1 -> CTEB push_bool .

    TIMES           reduce using rule 120 (factor_1 -> CTEB push_bool .)
    DIV             reduce using rule 120 (factor_1 -> CTEB push_bool .)
    PLUS            reduce using rule 120 (factor_1 -> CTEB push_bool .)
    MINUS           reduce using rule 120 (factor_1 -> CTEB push_bool .)
    ISEQUAL         reduce using rule 120 (factor_1 -> CTEB push_bool .)
    EQUAL           reduce using rule 120 (factor_1 -> CTEB push_bool .)
    NOTEQUAL        reduce using rule 120 (factor_1 -> CTEB push_bool .)
    GREATERTHAN     reduce using rule 120 (factor_1 -> CTEB push_bool .)
    GREATERORQUAL   reduce using rule 120 (factor_1 -> CTEB push_bool .)
    LESSTHAN        reduce using rule 120 (factor_1 -> CTEB push_bool .)
    LESSOREQUAL     reduce using rule 120 (factor_1 -> CTEB push_bool .)
    OR              reduce using rule 120 (factor_1 -> CTEB push_bool .)
    AND             reduce using rule 120 (factor_1 -> CTEB push_bool .)
    SEMICOL         reduce using rule 120 (factor_1 -> CTEB push_bool .)
    RPAR            reduce using rule 120 (factor_1 -> CTEB push_bool .)
    COMMA           reduce using rule 120 (factor_1 -> CTEB push_bool .)
    RBRACK          reduce using rule 120 (factor_1 -> CTEB push_bool .)
    LCURLY          reduce using rule 120 (factor_1 -> CTEB push_bool .)
    TO              reduce using rule 120 (factor_1 -> CTEB push_bool .)


state 179

    (155) push_bool -> empty .

    TIMES           reduce using rule 155 (push_bool -> empty .)
    DIV             reduce using rule 155 (push_bool -> empty .)
    PLUS            reduce using rule 155 (push_bool -> empty .)
    MINUS           reduce using rule 155 (push_bool -> empty .)
    ISEQUAL         reduce using rule 155 (push_bool -> empty .)
    EQUAL           reduce using rule 155 (push_bool -> empty .)
    NOTEQUAL        reduce using rule 155 (push_bool -> empty .)
    GREATERTHAN     reduce using rule 155 (push_bool -> empty .)
    GREATERORQUAL   reduce using rule 155 (push_bool -> empty .)
    LESSTHAN        reduce using rule 155 (push_bool -> empty .)
    LESSOREQUAL     reduce using rule 155 (push_bool -> empty .)
    OR              reduce using rule 155 (push_bool -> empty .)
    AND             reduce using rule 155 (push_bool -> empty .)
    SEMICOL         reduce using rule 155 (push_bool -> empty .)
    RPAR            reduce using rule 155 (push_bool -> empty .)
    COMMA           reduce using rule 155 (push_bool -> empty .)
    RBRACK          reduce using rule 155 (push_bool -> empty .)
    LCURLY          reduce using rule 155 (push_bool -> empty .)
    TO              reduce using rule 155 (push_bool -> empty .)


state 180

    (121) factor_1 -> CTEC push_char .

    TIMES           reduce using rule 121 (factor_1 -> CTEC push_char .)
    DIV             reduce using rule 121 (factor_1 -> CTEC push_char .)
    PLUS            reduce using rule 121 (factor_1 -> CTEC push_char .)
    MINUS           reduce using rule 121 (factor_1 -> CTEC push_char .)
    ISEQUAL         reduce using rule 121 (factor_1 -> CTEC push_char .)
    EQUAL           reduce using rule 121 (factor_1 -> CTEC push_char .)
    NOTEQUAL        reduce using rule 121 (factor_1 -> CTEC push_char .)
    GREATERTHAN     reduce using rule 121 (factor_1 -> CTEC push_char .)
    GREATERORQUAL   reduce using rule 121 (factor_1 -> CTEC push_char .)
    LESSTHAN        reduce using rule 121 (factor_1 -> CTEC push_char .)
    LESSOREQUAL     reduce using rule 121 (factor_1 -> CTEC push_char .)
    OR              reduce using rule 121 (factor_1 -> CTEC push_char .)
    AND             reduce using rule 121 (factor_1 -> CTEC push_char .)
    SEMICOL         reduce using rule 121 (factor_1 -> CTEC push_char .)
    RPAR            reduce using rule 121 (factor_1 -> CTEC push_char .)
    COMMA           reduce using rule 121 (factor_1 -> CTEC push_char .)
    RBRACK          reduce using rule 121 (factor_1 -> CTEC push_char .)
    LCURLY          reduce using rule 121 (factor_1 -> CTEC push_char .)
    TO              reduce using rule 121 (factor_1 -> CTEC push_char .)


state 181

    (156) push_char -> empty .

    TIMES           reduce using rule 156 (push_char -> empty .)
    DIV             reduce using rule 156 (push_char -> empty .)
    PLUS            reduce using rule 156 (push_char -> empty .)
    MINUS           reduce using rule 156 (push_char -> empty .)
    ISEQUAL         reduce using rule 156 (push_char -> empty .)
    EQUAL           reduce using rule 156 (push_char -> empty .)
    NOTEQUAL        reduce using rule 156 (push_char -> empty .)
    GREATERTHAN     reduce using rule 156 (push_char -> empty .)
    GREATERORQUAL   reduce using rule 156 (push_char -> empty .)
    LESSTHAN        reduce using rule 156 (push_char -> empty .)
    LESSOREQUAL     reduce using rule 156 (push_char -> empty .)
    OR              reduce using rule 156 (push_char -> empty .)
    AND             reduce using rule 156 (push_char -> empty .)
    SEMICOL         reduce using rule 156 (push_char -> empty .)
    RPAR            reduce using rule 156 (push_char -> empty .)
    COMMA           reduce using rule 156 (push_char -> empty .)
    RBRACK          reduce using rule 156 (push_char -> empty .)
    LCURLY          reduce using rule 156 (push_char -> empty .)
    TO              reduce using rule 156 (push_char -> empty .)


state 182

    (122) factor_1 -> MINUS factor_1 .

    TIMES           reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    DIV             reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    PLUS            reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    MINUS           reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    ISEQUAL         reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    EQUAL           reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    NOTEQUAL        reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    GREATERTHAN     reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    GREATERORQUAL   reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    LESSTHAN        reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    LESSOREQUAL     reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    OR              reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    AND             reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    SEMICOL         reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    RPAR            reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    COMMA           reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    RBRACK          reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    LCURLY          reduce using rule 122 (factor_1 -> MINUS factor_1 .)
    TO              reduce using rule 122 (factor_1 -> MINUS factor_1 .)


state 183

    (123) factor_2 -> LPAR add_ff . expression RPAR pop_ff
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 236
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 184

    (151) add_ff -> empty .

    ID              reduce using rule 151 (add_ff -> empty .)
    CTEI            reduce using rule 151 (add_ff -> empty .)
    CTEF            reduce using rule 151 (add_ff -> empty .)
    CTEB            reduce using rule 151 (add_ff -> empty .)
    CTEC            reduce using rule 151 (add_ff -> empty .)
    MINUS           reduce using rule 151 (add_ff -> empty .)
    LPAR            reduce using rule 151 (add_ff -> empty .)


state 185

    (55) cond -> IF LPAR expression RPAR . generate_g_if block cond_1 finish_if
    (161) generate_g_if -> . empty
    (179) empty -> .

    LCURLY          reduce using rule 179 (empty -> .)

    generate_g_if                  shift and go to state 237
    empty                          shift and go to state 238

state 186

    (61) cloop -> WHILE cloop_push_jump LPAR expression . generate_g_cloop_start RPAR block generate_g_cloop_end
    (167) generate_g_cloop_start -> . empty
    (179) empty -> .

    RPAR            reduce using rule 179 (empty -> .)

    generate_g_cloop_start         shift and go to state 239
    empty                          shift and go to state 240

state 187

    (62) nloop -> FROM ID see_id nloop_1 . push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (158) push_id -> . empty
    (179) empty -> .

    TO              reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)

    push_id                        shift and go to state 241
    empty                          shift and go to state 242

state 188

    (63) nloop_1 -> dims .

    TO              reduce using rule 63 (nloop_1 -> dims .)
    EQUAL           reduce using rule 63 (nloop_1 -> dims .)


state 189

    (64) nloop_1 -> empty .

    TO              reduce using rule 64 (nloop_1 -> empty .)
    EQUAL           reduce using rule 64 (nloop_1 -> empty .)


state 190

    (72) read -> READ LPAR read_1 RPAR . SEMICOL

    SEMICOL         shift and go to state 243


state 191

    (73) read_1 -> ID see_id . read_2 push_id generate_g_read read_3
    (74) read_2 -> . dims reset_dims
    (75) read_2 -> . empty
    (42) dims -> . LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
    (179) empty -> .

    LBRACK          shift and go to state 101
    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    read_2                         shift and go to state 244
    dims                           shift and go to state 245
    empty                          shift and go to state 246

state 192

    (78) write -> WRITE LPAR write_1 RPAR . SEMICOL

    SEMICOL         shift and go to state 247


state 193

    (79) write_1 -> write_2 generate_g_write . write_3
    (82) write_3 -> . COMMA write_1
    (83) write_3 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 249
    RPAR            reduce using rule 179 (empty -> .)

    write_3                        shift and go to state 248
    empty                          shift and go to state 250

state 194

    (165) generate_g_write -> empty .

    COMMA           reduce using rule 165 (generate_g_write -> empty .)
    RPAR            reduce using rule 165 (generate_g_write -> empty .)


state 195

    (81) write_2 -> CTES push_string .

    COMMA           reduce using rule 81 (write_2 -> CTES push_string .)
    RPAR            reduce using rule 81 (write_2 -> CTES push_string .)


state 196

    (157) push_string -> empty .

    COMMA           reduce using rule 157 (push_string -> empty .)
    RPAR            reduce using rule 157 (push_string -> empty .)


state 197

    (84) loadfile -> LOADFILE LPAR ID COMMA . CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    CTES            shift and go to state 251


state 198

    (33) params_1 -> type ID see_id params_2 see_end_param reset_dims params_3 .

    RPAR            reduce using rule 33 (params_1 -> type ID see_id params_2 see_end_param reset_dims params_3 .)


state 199

    (37) params_3 -> COMMA . params_1
    (33) params_1 -> . type ID see_id params_2 see_end_param reset_dims params_3
    (34) params_1 -> . empty
    (15) type -> . INT
    (16) type -> . FLOAT
    (17) type -> . CHAR
    (18) type -> . BOOL
    (179) empty -> .

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19
    RPAR            reduce using rule 179 (empty -> .)

    params_1                       shift and go to state 252
    type                           shift and go to state 56
    empty                          shift and go to state 57

state 200

    (38) params_3 -> empty .

    RPAR            reduce using rule 38 (params_3 -> empty .)


state 201

    (42) dims -> LBRACK see_dims expression generate_g_verify_f . dims_1 RBRACK dims_end
    (43) dims_1 -> . COMMA see_dims_s expression generate_g_verify_s
    (44) dims_1 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 254
    RBRACK          reduce using rule 179 (empty -> .)

    dims_1                         shift and go to state 253
    empty                          shift and go to state 255

state 202

    (131) generate_g_verify_f -> empty .

    COMMA           reduce using rule 131 (generate_g_verify_f -> empty .)
    RBRACK          reduce using rule 131 (generate_g_verify_f -> empty .)


state 203

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY . see_func_end generate_end
    (138) see_func_end -> . empty
    (179) empty -> .

    $end            reduce using rule 179 (empty -> .)

    see_func_end                   shift and go to state 256
    empty                          shift and go to state 128

state 204

    (39) assign -> ID see_id push_id assign_1 EQUAL . push_equal expression generate_assign SEMICOL
    (159) push_equal -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_equal                     shift and go to state 257
    empty                          shift and go to state 258

state 205

    (67) callfunc -> ID see_id verify_func LPAR activate_record . callfunc_1 verify_p_num RPAR
    (68) callfunc_1 -> . expression verify_params callfunc_3
    (69) callfunc_1 -> . empty
    (89) expression -> . sexp check_and_or expression_1
    (179) empty -> .
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RPAR            reduce using rule 179 (empty -> .)
    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    callfunc_1                     shift and go to state 259
    expression                     shift and go to state 260
    empty                          shift and go to state 261
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 206

    (173) activate_record -> empty .

    ID              reduce using rule 173 (activate_record -> empty .)
    CTEI            reduce using rule 173 (activate_record -> empty .)
    CTEF            reduce using rule 173 (activate_record -> empty .)
    CTEB            reduce using rule 173 (activate_record -> empty .)
    CTEC            reduce using rule 173 (activate_record -> empty .)
    MINUS           reduce using rule 173 (activate_record -> empty .)
    LPAR            reduce using rule 173 (activate_record -> empty .)
    RPAR            reduce using rule 173 (activate_record -> empty .)


state 207

    (26) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3 .

    MAIN            reduce using rule 26 (funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3 .)


state 208

    (30) funcs_3 -> funcs .

    MAIN            reduce using rule 30 (funcs_3 -> funcs .)


state 209

    (31) funcs_3 -> empty .

    MAIN            reduce using rule 31 (funcs_3 -> empty .)


state 210

    (89) expression -> sexp check_and_or expression_1 .

    SEMICOL         reduce using rule 89 (expression -> sexp check_and_or expression_1 .)
    RPAR            reduce using rule 89 (expression -> sexp check_and_or expression_1 .)
    COMMA           reduce using rule 89 (expression -> sexp check_and_or expression_1 .)
    RBRACK          reduce using rule 89 (expression -> sexp check_and_or expression_1 .)
    LCURLY          reduce using rule 89 (expression -> sexp check_and_or expression_1 .)
    TO              reduce using rule 89 (expression -> sexp check_and_or expression_1 .)


state 211

    (90) expression_1 -> expression_2 . push_and_or expression
    (144) push_and_or -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_and_or                    shift and go to state 262
    empty                          shift and go to state 263

state 212

    (91) expression_1 -> empty .

    SEMICOL         reduce using rule 91 (expression_1 -> empty .)
    RPAR            reduce using rule 91 (expression_1 -> empty .)
    COMMA           reduce using rule 91 (expression_1 -> empty .)
    RBRACK          reduce using rule 91 (expression_1 -> empty .)
    LCURLY          reduce using rule 91 (expression_1 -> empty .)
    TO              reduce using rule 91 (expression_1 -> empty .)


state 213

    (92) expression_2 -> OR .

    ID              reduce using rule 92 (expression_2 -> OR .)
    CTEI            reduce using rule 92 (expression_2 -> OR .)
    CTEF            reduce using rule 92 (expression_2 -> OR .)
    CTEB            reduce using rule 92 (expression_2 -> OR .)
    CTEC            reduce using rule 92 (expression_2 -> OR .)
    MINUS           reduce using rule 92 (expression_2 -> OR .)
    LPAR            reduce using rule 92 (expression_2 -> OR .)


state 214

    (93) expression_2 -> AND .

    ID              reduce using rule 93 (expression_2 -> AND .)
    CTEI            reduce using rule 93 (expression_2 -> AND .)
    CTEF            reduce using rule 93 (expression_2 -> AND .)
    CTEB            reduce using rule 93 (expression_2 -> AND .)
    CTEC            reduce using rule 93 (expression_2 -> AND .)
    MINUS           reduce using rule 93 (expression_2 -> AND .)
    LPAR            reduce using rule 93 (expression_2 -> AND .)


state 215

    (94) sexp -> exp check_relational sexp_1 .

    OR              reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    AND             reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    SEMICOL         reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    RPAR            reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    COMMA           reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    RBRACK          reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    LCURLY          reduce using rule 94 (sexp -> exp check_relational sexp_1 .)
    TO              reduce using rule 94 (sexp -> exp check_relational sexp_1 .)


state 216

    (95) sexp_1 -> sexp_2 . push_relational sexp
    (146) push_relational -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_relational                shift and go to state 264
    empty                          shift and go to state 265

state 217

    (96) sexp_1 -> empty .

    OR              reduce using rule 96 (sexp_1 -> empty .)
    AND             reduce using rule 96 (sexp_1 -> empty .)
    SEMICOL         reduce using rule 96 (sexp_1 -> empty .)
    RPAR            reduce using rule 96 (sexp_1 -> empty .)
    COMMA           reduce using rule 96 (sexp_1 -> empty .)
    RBRACK          reduce using rule 96 (sexp_1 -> empty .)
    LCURLY          reduce using rule 96 (sexp_1 -> empty .)
    TO              reduce using rule 96 (sexp_1 -> empty .)


state 218

    (97) sexp_2 -> ISEQUAL .

    ID              reduce using rule 97 (sexp_2 -> ISEQUAL .)
    CTEI            reduce using rule 97 (sexp_2 -> ISEQUAL .)
    CTEF            reduce using rule 97 (sexp_2 -> ISEQUAL .)
    CTEB            reduce using rule 97 (sexp_2 -> ISEQUAL .)
    CTEC            reduce using rule 97 (sexp_2 -> ISEQUAL .)
    MINUS           reduce using rule 97 (sexp_2 -> ISEQUAL .)
    LPAR            reduce using rule 97 (sexp_2 -> ISEQUAL .)


state 219

    (98) sexp_2 -> EQUAL .

    ID              reduce using rule 98 (sexp_2 -> EQUAL .)
    CTEI            reduce using rule 98 (sexp_2 -> EQUAL .)
    CTEF            reduce using rule 98 (sexp_2 -> EQUAL .)
    CTEB            reduce using rule 98 (sexp_2 -> EQUAL .)
    CTEC            reduce using rule 98 (sexp_2 -> EQUAL .)
    MINUS           reduce using rule 98 (sexp_2 -> EQUAL .)
    LPAR            reduce using rule 98 (sexp_2 -> EQUAL .)


state 220

    (99) sexp_2 -> NOTEQUAL .

    ID              reduce using rule 99 (sexp_2 -> NOTEQUAL .)
    CTEI            reduce using rule 99 (sexp_2 -> NOTEQUAL .)
    CTEF            reduce using rule 99 (sexp_2 -> NOTEQUAL .)
    CTEB            reduce using rule 99 (sexp_2 -> NOTEQUAL .)
    CTEC            reduce using rule 99 (sexp_2 -> NOTEQUAL .)
    MINUS           reduce using rule 99 (sexp_2 -> NOTEQUAL .)
    LPAR            reduce using rule 99 (sexp_2 -> NOTEQUAL .)


state 221

    (100) sexp_2 -> GREATERTHAN .

    ID              reduce using rule 100 (sexp_2 -> GREATERTHAN .)
    CTEI            reduce using rule 100 (sexp_2 -> GREATERTHAN .)
    CTEF            reduce using rule 100 (sexp_2 -> GREATERTHAN .)
    CTEB            reduce using rule 100 (sexp_2 -> GREATERTHAN .)
    CTEC            reduce using rule 100 (sexp_2 -> GREATERTHAN .)
    MINUS           reduce using rule 100 (sexp_2 -> GREATERTHAN .)
    LPAR            reduce using rule 100 (sexp_2 -> GREATERTHAN .)


state 222

    (101) sexp_2 -> GREATERORQUAL .

    ID              reduce using rule 101 (sexp_2 -> GREATERORQUAL .)
    CTEI            reduce using rule 101 (sexp_2 -> GREATERORQUAL .)
    CTEF            reduce using rule 101 (sexp_2 -> GREATERORQUAL .)
    CTEB            reduce using rule 101 (sexp_2 -> GREATERORQUAL .)
    CTEC            reduce using rule 101 (sexp_2 -> GREATERORQUAL .)
    MINUS           reduce using rule 101 (sexp_2 -> GREATERORQUAL .)
    LPAR            reduce using rule 101 (sexp_2 -> GREATERORQUAL .)


state 223

    (102) sexp_2 -> LESSTHAN .

    ID              reduce using rule 102 (sexp_2 -> LESSTHAN .)
    CTEI            reduce using rule 102 (sexp_2 -> LESSTHAN .)
    CTEF            reduce using rule 102 (sexp_2 -> LESSTHAN .)
    CTEB            reduce using rule 102 (sexp_2 -> LESSTHAN .)
    CTEC            reduce using rule 102 (sexp_2 -> LESSTHAN .)
    MINUS           reduce using rule 102 (sexp_2 -> LESSTHAN .)
    LPAR            reduce using rule 102 (sexp_2 -> LESSTHAN .)


state 224

    (103) sexp_2 -> LESSOREQUAL .

    ID              reduce using rule 103 (sexp_2 -> LESSOREQUAL .)
    CTEI            reduce using rule 103 (sexp_2 -> LESSOREQUAL .)
    CTEF            reduce using rule 103 (sexp_2 -> LESSOREQUAL .)
    CTEB            reduce using rule 103 (sexp_2 -> LESSOREQUAL .)
    CTEC            reduce using rule 103 (sexp_2 -> LESSOREQUAL .)
    MINUS           reduce using rule 103 (sexp_2 -> LESSOREQUAL .)
    LPAR            reduce using rule 103 (sexp_2 -> LESSOREQUAL .)


state 225

    (104) exp -> term check_sum exp_1 .

    ISEQUAL         reduce using rule 104 (exp -> term check_sum exp_1 .)
    EQUAL           reduce using rule 104 (exp -> term check_sum exp_1 .)
    NOTEQUAL        reduce using rule 104 (exp -> term check_sum exp_1 .)
    GREATERTHAN     reduce using rule 104 (exp -> term check_sum exp_1 .)
    GREATERORQUAL   reduce using rule 104 (exp -> term check_sum exp_1 .)
    LESSTHAN        reduce using rule 104 (exp -> term check_sum exp_1 .)
    LESSOREQUAL     reduce using rule 104 (exp -> term check_sum exp_1 .)
    OR              reduce using rule 104 (exp -> term check_sum exp_1 .)
    AND             reduce using rule 104 (exp -> term check_sum exp_1 .)
    SEMICOL         reduce using rule 104 (exp -> term check_sum exp_1 .)
    RPAR            reduce using rule 104 (exp -> term check_sum exp_1 .)
    COMMA           reduce using rule 104 (exp -> term check_sum exp_1 .)
    RBRACK          reduce using rule 104 (exp -> term check_sum exp_1 .)
    LCURLY          reduce using rule 104 (exp -> term check_sum exp_1 .)
    TO              reduce using rule 104 (exp -> term check_sum exp_1 .)


state 226

    (105) exp_1 -> exp_2 . push_sum exp
    (148) push_sum -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_sum                       shift and go to state 266
    empty                          shift and go to state 267

state 227

    (106) exp_1 -> empty .

    ISEQUAL         reduce using rule 106 (exp_1 -> empty .)
    EQUAL           reduce using rule 106 (exp_1 -> empty .)
    NOTEQUAL        reduce using rule 106 (exp_1 -> empty .)
    GREATERTHAN     reduce using rule 106 (exp_1 -> empty .)
    GREATERORQUAL   reduce using rule 106 (exp_1 -> empty .)
    LESSTHAN        reduce using rule 106 (exp_1 -> empty .)
    LESSOREQUAL     reduce using rule 106 (exp_1 -> empty .)
    OR              reduce using rule 106 (exp_1 -> empty .)
    AND             reduce using rule 106 (exp_1 -> empty .)
    SEMICOL         reduce using rule 106 (exp_1 -> empty .)
    RPAR            reduce using rule 106 (exp_1 -> empty .)
    COMMA           reduce using rule 106 (exp_1 -> empty .)
    RBRACK          reduce using rule 106 (exp_1 -> empty .)
    LCURLY          reduce using rule 106 (exp_1 -> empty .)
    TO              reduce using rule 106 (exp_1 -> empty .)


state 228

    (107) exp_2 -> PLUS .

    ID              reduce using rule 107 (exp_2 -> PLUS .)
    CTEI            reduce using rule 107 (exp_2 -> PLUS .)
    CTEF            reduce using rule 107 (exp_2 -> PLUS .)
    CTEB            reduce using rule 107 (exp_2 -> PLUS .)
    CTEC            reduce using rule 107 (exp_2 -> PLUS .)
    MINUS           reduce using rule 107 (exp_2 -> PLUS .)
    LPAR            reduce using rule 107 (exp_2 -> PLUS .)


state 229

    (108) exp_2 -> MINUS .

    ID              reduce using rule 108 (exp_2 -> MINUS .)
    CTEI            reduce using rule 108 (exp_2 -> MINUS .)
    CTEF            reduce using rule 108 (exp_2 -> MINUS .)
    CTEB            reduce using rule 108 (exp_2 -> MINUS .)
    CTEC            reduce using rule 108 (exp_2 -> MINUS .)
    MINUS           reduce using rule 108 (exp_2 -> MINUS .)
    LPAR            reduce using rule 108 (exp_2 -> MINUS .)


state 230

    (109) term -> factor check_mul_div term_1 .

    PLUS            reduce using rule 109 (term -> factor check_mul_div term_1 .)
    MINUS           reduce using rule 109 (term -> factor check_mul_div term_1 .)
    ISEQUAL         reduce using rule 109 (term -> factor check_mul_div term_1 .)
    EQUAL           reduce using rule 109 (term -> factor check_mul_div term_1 .)
    NOTEQUAL        reduce using rule 109 (term -> factor check_mul_div term_1 .)
    GREATERTHAN     reduce using rule 109 (term -> factor check_mul_div term_1 .)
    GREATERORQUAL   reduce using rule 109 (term -> factor check_mul_div term_1 .)
    LESSTHAN        reduce using rule 109 (term -> factor check_mul_div term_1 .)
    LESSOREQUAL     reduce using rule 109 (term -> factor check_mul_div term_1 .)
    OR              reduce using rule 109 (term -> factor check_mul_div term_1 .)
    AND             reduce using rule 109 (term -> factor check_mul_div term_1 .)
    SEMICOL         reduce using rule 109 (term -> factor check_mul_div term_1 .)
    RPAR            reduce using rule 109 (term -> factor check_mul_div term_1 .)
    COMMA           reduce using rule 109 (term -> factor check_mul_div term_1 .)
    RBRACK          reduce using rule 109 (term -> factor check_mul_div term_1 .)
    LCURLY          reduce using rule 109 (term -> factor check_mul_div term_1 .)
    TO              reduce using rule 109 (term -> factor check_mul_div term_1 .)


state 231

    (110) term_1 -> term_2 . push_mul_div term
    (150) push_mul_div -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_mul_div                   shift and go to state 268
    empty                          shift and go to state 269

state 232

    (111) term_1 -> empty .

    PLUS            reduce using rule 111 (term_1 -> empty .)
    MINUS           reduce using rule 111 (term_1 -> empty .)
    ISEQUAL         reduce using rule 111 (term_1 -> empty .)
    EQUAL           reduce using rule 111 (term_1 -> empty .)
    NOTEQUAL        reduce using rule 111 (term_1 -> empty .)
    GREATERTHAN     reduce using rule 111 (term_1 -> empty .)
    GREATERORQUAL   reduce using rule 111 (term_1 -> empty .)
    LESSTHAN        reduce using rule 111 (term_1 -> empty .)
    LESSOREQUAL     reduce using rule 111 (term_1 -> empty .)
    OR              reduce using rule 111 (term_1 -> empty .)
    AND             reduce using rule 111 (term_1 -> empty .)
    SEMICOL         reduce using rule 111 (term_1 -> empty .)
    RPAR            reduce using rule 111 (term_1 -> empty .)
    COMMA           reduce using rule 111 (term_1 -> empty .)
    RBRACK          reduce using rule 111 (term_1 -> empty .)
    LCURLY          reduce using rule 111 (term_1 -> empty .)
    TO              reduce using rule 111 (term_1 -> empty .)


state 233

    (112) term_2 -> TIMES .

    ID              reduce using rule 112 (term_2 -> TIMES .)
    CTEI            reduce using rule 112 (term_2 -> TIMES .)
    CTEF            reduce using rule 112 (term_2 -> TIMES .)
    CTEB            reduce using rule 112 (term_2 -> TIMES .)
    CTEC            reduce using rule 112 (term_2 -> TIMES .)
    MINUS           reduce using rule 112 (term_2 -> TIMES .)
    LPAR            reduce using rule 112 (term_2 -> TIMES .)


state 234

    (113) term_2 -> DIV .

    ID              reduce using rule 113 (term_2 -> DIV .)
    CTEI            reduce using rule 113 (term_2 -> DIV .)
    CTEF            reduce using rule 113 (term_2 -> DIV .)
    CTEB            reduce using rule 113 (term_2 -> DIV .)
    CTEC            reduce using rule 113 (term_2 -> DIV .)
    MINUS           reduce using rule 113 (term_2 -> DIV .)
    LPAR            reduce using rule 113 (term_2 -> DIV .)


state 235

    (116) factor_1 -> ID see_id push_id . factor_3 print_value reset_dims
    (124) factor_3 -> . dims
    (125) factor_3 -> . empty
    (42) dims -> . LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end
    (179) empty -> .

    LBRACK          shift and go to state 101
    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    factor_3                       shift and go to state 270
    dims                           shift and go to state 271
    empty                          shift and go to state 272

state 236

    (123) factor_2 -> LPAR add_ff expression . RPAR pop_ff

    RPAR            shift and go to state 273


state 237

    (55) cond -> IF LPAR expression RPAR generate_g_if . block cond_1 finish_if
    (24) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 275

    block                          shift and go to state 274

state 238

    (161) generate_g_if -> empty .

    LCURLY          reduce using rule 161 (generate_g_if -> empty .)


state 239

    (61) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start . RPAR block generate_g_cloop_end

    RPAR            shift and go to state 276


state 240

    (167) generate_g_cloop_start -> empty .

    RPAR            reduce using rule 167 (generate_g_cloop_start -> empty .)


state 241

    (62) nloop -> FROM ID see_id nloop_1 push_id . nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (65) nloop_2 -> . push_id EQUAL push_equal expression generate_assign
    (66) nloop_2 -> . empty
    (158) push_id -> . empty
    (179) empty -> .

    TO              reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)

    push_id                        shift and go to state 277
    nloop_2                        shift and go to state 278
    empty                          shift and go to state 279

state 242

    (158) push_id -> empty .

    TO              reduce using rule 158 (push_id -> empty .)
    EQUAL           reduce using rule 158 (push_id -> empty .)
    COMMA           reduce using rule 158 (push_id -> empty .)
    RPAR            reduce using rule 158 (push_id -> empty .)


state 243

    (72) read -> READ LPAR read_1 RPAR SEMICOL .

    ID              reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    IF              reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    WHILE           reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    FROM            reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    READ            reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    WRITE           reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    LOADFILE        reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    RETURN          reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    RCURLY          reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)
    END             reduce using rule 72 (read -> READ LPAR read_1 RPAR SEMICOL .)


state 244

    (73) read_1 -> ID see_id read_2 . push_id generate_g_read read_3
    (158) push_id -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    push_id                        shift and go to state 280
    empty                          shift and go to state 242

state 245

    (74) read_2 -> dims . reset_dims
    (141) reset_dims -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    reset_dims                     shift and go to state 281
    empty                          shift and go to state 155

state 246

    (75) read_2 -> empty .

    COMMA           reduce using rule 75 (read_2 -> empty .)
    RPAR            reduce using rule 75 (read_2 -> empty .)


state 247

    (78) write -> WRITE LPAR write_1 RPAR SEMICOL .

    ID              reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    IF              reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    WHILE           reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    FROM            reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    READ            reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    WRITE           reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    LOADFILE        reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    RETURN          reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    RCURLY          reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    END             reduce using rule 78 (write -> WRITE LPAR write_1 RPAR SEMICOL .)


state 248

    (79) write_1 -> write_2 generate_g_write write_3 .

    RPAR            reduce using rule 79 (write_1 -> write_2 generate_g_write write_3 .)


state 249

    (82) write_3 -> COMMA . write_1
    (79) write_1 -> . write_2 generate_g_write write_3
    (80) write_2 -> . expression
    (81) write_2 -> . CTES push_string
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    CTES            shift and go to state 152
    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    write_1                        shift and go to state 282
    write_2                        shift and go to state 150
    expression                     shift and go to state 151
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 250

    (83) write_3 -> empty .

    RPAR            reduce using rule 83 (write_3 -> empty .)


state 251

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES . COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 283


state 252

    (37) params_3 -> COMMA params_1 .

    RPAR            reduce using rule 37 (params_3 -> COMMA params_1 .)


state 253

    (42) dims -> LBRACK see_dims expression generate_g_verify_f dims_1 . RBRACK dims_end

    RBRACK          shift and go to state 284


state 254

    (43) dims_1 -> COMMA . see_dims_s expression generate_g_verify_s
    (130) see_dims_s -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    see_dims_s                     shift and go to state 285
    empty                          shift and go to state 286

state 255

    (44) dims_1 -> empty .

    RBRACK          reduce using rule 44 (dims_1 -> empty .)


state 256

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end . generate_end
    (171) generate_end -> . empty
    (179) empty -> .

    $end            reduce using rule 179 (empty -> .)

    generate_end                   shift and go to state 287
    empty                          shift and go to state 288

state 257

    (39) assign -> ID see_id push_id assign_1 EQUAL push_equal . expression generate_assign SEMICOL
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 289
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 258

    (159) push_equal -> empty .

    ID              reduce using rule 159 (push_equal -> empty .)
    CTEI            reduce using rule 159 (push_equal -> empty .)
    CTEF            reduce using rule 159 (push_equal -> empty .)
    CTEB            reduce using rule 159 (push_equal -> empty .)
    CTEC            reduce using rule 159 (push_equal -> empty .)
    MINUS           reduce using rule 159 (push_equal -> empty .)
    LPAR            reduce using rule 159 (push_equal -> empty .)


state 259

    (67) callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 . verify_p_num RPAR
    (176) verify_p_num -> . empty
    (179) empty -> .

    RPAR            reduce using rule 179 (empty -> .)

    verify_p_num                   shift and go to state 290
    empty                          shift and go to state 291

state 260

    (68) callfunc_1 -> expression . verify_params callfunc_3
    (174) verify_params -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    verify_params                  shift and go to state 292
    empty                          shift and go to state 293

state 261

    (69) callfunc_1 -> empty .

    RPAR            reduce using rule 69 (callfunc_1 -> empty .)


state 262

    (90) expression_1 -> expression_2 push_and_or . expression
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 294
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 263

    (144) push_and_or -> empty .

    ID              reduce using rule 144 (push_and_or -> empty .)
    CTEI            reduce using rule 144 (push_and_or -> empty .)
    CTEF            reduce using rule 144 (push_and_or -> empty .)
    CTEB            reduce using rule 144 (push_and_or -> empty .)
    CTEC            reduce using rule 144 (push_and_or -> empty .)
    MINUS           reduce using rule 144 (push_and_or -> empty .)
    LPAR            reduce using rule 144 (push_and_or -> empty .)


state 264

    (95) sexp_1 -> sexp_2 push_relational . sexp
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    sexp                           shift and go to state 295
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 265

    (146) push_relational -> empty .

    ID              reduce using rule 146 (push_relational -> empty .)
    CTEI            reduce using rule 146 (push_relational -> empty .)
    CTEF            reduce using rule 146 (push_relational -> empty .)
    CTEB            reduce using rule 146 (push_relational -> empty .)
    CTEC            reduce using rule 146 (push_relational -> empty .)
    MINUS           reduce using rule 146 (push_relational -> empty .)
    LPAR            reduce using rule 146 (push_relational -> empty .)


state 266

    (105) exp_1 -> exp_2 push_sum . exp
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    exp                            shift and go to state 296
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 267

    (148) push_sum -> empty .

    ID              reduce using rule 148 (push_sum -> empty .)
    CTEI            reduce using rule 148 (push_sum -> empty .)
    CTEF            reduce using rule 148 (push_sum -> empty .)
    CTEB            reduce using rule 148 (push_sum -> empty .)
    CTEC            reduce using rule 148 (push_sum -> empty .)
    MINUS           reduce using rule 148 (push_sum -> empty .)
    LPAR            reduce using rule 148 (push_sum -> empty .)


state 268

    (110) term_1 -> term_2 push_mul_div . term
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    term                           shift and go to state 297
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 269

    (150) push_mul_div -> empty .

    ID              reduce using rule 150 (push_mul_div -> empty .)
    CTEI            reduce using rule 150 (push_mul_div -> empty .)
    CTEF            reduce using rule 150 (push_mul_div -> empty .)
    CTEB            reduce using rule 150 (push_mul_div -> empty .)
    CTEC            reduce using rule 150 (push_mul_div -> empty .)
    MINUS           reduce using rule 150 (push_mul_div -> empty .)
    LPAR            reduce using rule 150 (push_mul_div -> empty .)


state 270

    (116) factor_1 -> ID see_id push_id factor_3 . print_value reset_dims
    (142) print_value -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    print_value                    shift and go to state 298
    empty                          shift and go to state 299

state 271

    (124) factor_3 -> dims .

    TIMES           reduce using rule 124 (factor_3 -> dims .)
    DIV             reduce using rule 124 (factor_3 -> dims .)
    PLUS            reduce using rule 124 (factor_3 -> dims .)
    MINUS           reduce using rule 124 (factor_3 -> dims .)
    ISEQUAL         reduce using rule 124 (factor_3 -> dims .)
    EQUAL           reduce using rule 124 (factor_3 -> dims .)
    NOTEQUAL        reduce using rule 124 (factor_3 -> dims .)
    GREATERTHAN     reduce using rule 124 (factor_3 -> dims .)
    GREATERORQUAL   reduce using rule 124 (factor_3 -> dims .)
    LESSTHAN        reduce using rule 124 (factor_3 -> dims .)
    LESSOREQUAL     reduce using rule 124 (factor_3 -> dims .)
    OR              reduce using rule 124 (factor_3 -> dims .)
    AND             reduce using rule 124 (factor_3 -> dims .)
    SEMICOL         reduce using rule 124 (factor_3 -> dims .)
    RPAR            reduce using rule 124 (factor_3 -> dims .)
    COMMA           reduce using rule 124 (factor_3 -> dims .)
    RBRACK          reduce using rule 124 (factor_3 -> dims .)
    LCURLY          reduce using rule 124 (factor_3 -> dims .)
    TO              reduce using rule 124 (factor_3 -> dims .)


state 272

    (125) factor_3 -> empty .

    TIMES           reduce using rule 125 (factor_3 -> empty .)
    DIV             reduce using rule 125 (factor_3 -> empty .)
    PLUS            reduce using rule 125 (factor_3 -> empty .)
    MINUS           reduce using rule 125 (factor_3 -> empty .)
    ISEQUAL         reduce using rule 125 (factor_3 -> empty .)
    EQUAL           reduce using rule 125 (factor_3 -> empty .)
    NOTEQUAL        reduce using rule 125 (factor_3 -> empty .)
    GREATERTHAN     reduce using rule 125 (factor_3 -> empty .)
    GREATERORQUAL   reduce using rule 125 (factor_3 -> empty .)
    LESSTHAN        reduce using rule 125 (factor_3 -> empty .)
    LESSOREQUAL     reduce using rule 125 (factor_3 -> empty .)
    OR              reduce using rule 125 (factor_3 -> empty .)
    AND             reduce using rule 125 (factor_3 -> empty .)
    SEMICOL         reduce using rule 125 (factor_3 -> empty .)
    RPAR            reduce using rule 125 (factor_3 -> empty .)
    COMMA           reduce using rule 125 (factor_3 -> empty .)
    RBRACK          reduce using rule 125 (factor_3 -> empty .)
    LCURLY          reduce using rule 125 (factor_3 -> empty .)
    TO              reduce using rule 125 (factor_3 -> empty .)


state 273

    (123) factor_2 -> LPAR add_ff expression RPAR . pop_ff
    (152) pop_ff -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    pop_ff                         shift and go to state 300
    empty                          shift and go to state 301

state 274

    (55) cond -> IF LPAR expression RPAR generate_g_if block . cond_1 finish_if
    (56) cond_1 -> . ELSE generate_g_else cond_2

    ELSE            shift and go to state 303

    cond_1                         shift and go to state 302

state 275

    (24) block -> LCURLY . block_1 RCURLY
    (25) block_1 -> . statement
    (45) statement -> . statement_1 statement
    (46) statement -> . empty
    (47) statement_1 -> . assign
    (48) statement_1 -> . cond
    (49) statement_1 -> . cloop
    (50) statement_1 -> . nloop
    (51) statement_1 -> . read
    (52) statement_1 -> . write
    (53) statement_1 -> . loadfile
    (54) statement_1 -> . callfunc SEMICOL
    (179) empty -> .
    (39) assign -> . ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL
    (55) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (61) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (62) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (72) read -> . READ LPAR read_1 RPAR SEMICOL
    (78) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (84) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RCURLY          reduce using rule 179 (empty -> .)
    ID              shift and go to state 80
    IF              shift and go to state 92
    WHILE           shift and go to state 93
    FROM            shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    LOADFILE        shift and go to state 97

    block_1                        shift and go to state 304
    statement                      shift and go to state 305
    statement_1                    shift and go to state 82
    empty                          shift and go to state 83
    assign                         shift and go to state 84
    cond                           shift and go to state 85
    cloop                          shift and go to state 86
    nloop                          shift and go to state 87
    read                           shift and go to state 88
    write                          shift and go to state 89
    loadfile                       shift and go to state 90
    callfunc                       shift and go to state 91

state 276

    (61) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR . block generate_g_cloop_end
    (24) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 275

    block                          shift and go to state 306

state 277

    (65) nloop_2 -> push_id . EQUAL push_equal expression generate_assign

    EQUAL           shift and go to state 307


state 278

    (62) nloop -> FROM ID see_id nloop_1 push_id nloop_2 . TO expression generate_g_nloop_s block generate_g_nloop_e

    TO              shift and go to state 308


state 279

    (66) nloop_2 -> empty .
    (158) push_id -> empty .

    TO              reduce using rule 66 (nloop_2 -> empty .)
    EQUAL           reduce using rule 158 (push_id -> empty .)


state 280

    (73) read_1 -> ID see_id read_2 push_id . generate_g_read read_3
    (164) generate_g_read -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    generate_g_read                shift and go to state 309
    empty                          shift and go to state 310

state 281

    (74) read_2 -> dims reset_dims .

    COMMA           reduce using rule 74 (read_2 -> dims reset_dims .)
    RPAR            reduce using rule 74 (read_2 -> dims reset_dims .)


state 282

    (82) write_3 -> COMMA write_1 .

    RPAR            reduce using rule 82 (write_3 -> COMMA write_1 .)


state 283

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA . loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (85) loadfile_1 -> . CTEI
    (86) loadfile_1 -> . ID

    CTEI            shift and go to state 313
    ID              shift and go to state 311

    loadfile_1                     shift and go to state 312

state 284

    (42) dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK . dims_end
    (133) dims_end -> . empty
    (179) empty -> .

    COMMA           reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)
    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)

    dims_end                       shift and go to state 314
    empty                          shift and go to state 315

state 285

    (43) dims_1 -> COMMA see_dims_s . expression generate_g_verify_s
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 316
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 286

    (130) see_dims_s -> empty .

    ID              reduce using rule 130 (see_dims_s -> empty .)
    CTEI            reduce using rule 130 (see_dims_s -> empty .)
    CTEF            reduce using rule 130 (see_dims_s -> empty .)
    CTEB            reduce using rule 130 (see_dims_s -> empty .)
    CTEC            reduce using rule 130 (see_dims_s -> empty .)
    MINUS           reduce using rule 130 (see_dims_s -> empty .)
    LPAR            reduce using rule 130 (see_dims_s -> empty .)


state 287

    (126) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end .

    $end            reduce using rule 126 (main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end .)


state 288

    (171) generate_end -> empty .

    $end            reduce using rule 171 (generate_end -> empty .)


state 289

    (39) assign -> ID see_id push_id assign_1 EQUAL push_equal expression . generate_assign SEMICOL
    (160) generate_assign -> . empty
    (179) empty -> .

    SEMICOL         reduce using rule 179 (empty -> .)

    generate_assign                shift and go to state 317
    empty                          shift and go to state 318

state 290

    (67) callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num . RPAR

    RPAR            shift and go to state 319


state 291

    (176) verify_p_num -> empty .

    RPAR            reduce using rule 176 (verify_p_num -> empty .)


state 292

    (68) callfunc_1 -> expression verify_params . callfunc_3
    (70) callfunc_3 -> . COMMA increase_p_count callfunc_1
    (71) callfunc_3 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 321
    RPAR            reduce using rule 179 (empty -> .)

    callfunc_3                     shift and go to state 320
    empty                          shift and go to state 322

state 293

    (174) verify_params -> empty .

    COMMA           reduce using rule 174 (verify_params -> empty .)
    RPAR            reduce using rule 174 (verify_params -> empty .)


state 294

    (90) expression_1 -> expression_2 push_and_or expression .

    SEMICOL         reduce using rule 90 (expression_1 -> expression_2 push_and_or expression .)
    RPAR            reduce using rule 90 (expression_1 -> expression_2 push_and_or expression .)
    COMMA           reduce using rule 90 (expression_1 -> expression_2 push_and_or expression .)
    RBRACK          reduce using rule 90 (expression_1 -> expression_2 push_and_or expression .)
    LCURLY          reduce using rule 90 (expression_1 -> expression_2 push_and_or expression .)
    TO              reduce using rule 90 (expression_1 -> expression_2 push_and_or expression .)


state 295

    (95) sexp_1 -> sexp_2 push_relational sexp .

    OR              reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    AND             reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    SEMICOL         reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    RPAR            reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    COMMA           reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    RBRACK          reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    LCURLY          reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)
    TO              reduce using rule 95 (sexp_1 -> sexp_2 push_relational sexp .)


state 296

    (105) exp_1 -> exp_2 push_sum exp .

    ISEQUAL         reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    EQUAL           reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    NOTEQUAL        reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    GREATERTHAN     reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    GREATERORQUAL   reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    LESSTHAN        reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    LESSOREQUAL     reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    OR              reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    AND             reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    SEMICOL         reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    RPAR            reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    COMMA           reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    RBRACK          reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    LCURLY          reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)
    TO              reduce using rule 105 (exp_1 -> exp_2 push_sum exp .)


state 297

    (110) term_1 -> term_2 push_mul_div term .

    PLUS            reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    MINUS           reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    ISEQUAL         reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    EQUAL           reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    NOTEQUAL        reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    GREATERTHAN     reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    GREATERORQUAL   reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    LESSTHAN        reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    LESSOREQUAL     reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    OR              reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    AND             reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    SEMICOL         reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    RPAR            reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    COMMA           reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    RBRACK          reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    LCURLY          reduce using rule 110 (term_1 -> term_2 push_mul_div term .)
    TO              reduce using rule 110 (term_1 -> term_2 push_mul_div term .)


state 298

    (116) factor_1 -> ID see_id push_id factor_3 print_value . reset_dims
    (141) reset_dims -> . empty
    (179) empty -> .

    TIMES           reduce using rule 179 (empty -> .)
    DIV             reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    ISEQUAL         reduce using rule 179 (empty -> .)
    EQUAL           reduce using rule 179 (empty -> .)
    NOTEQUAL        reduce using rule 179 (empty -> .)
    GREATERTHAN     reduce using rule 179 (empty -> .)
    GREATERORQUAL   reduce using rule 179 (empty -> .)
    LESSTHAN        reduce using rule 179 (empty -> .)
    LESSOREQUAL     reduce using rule 179 (empty -> .)
    OR              reduce using rule 179 (empty -> .)
    AND             reduce using rule 179 (empty -> .)
    SEMICOL         reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    RBRACK          reduce using rule 179 (empty -> .)
    LCURLY          reduce using rule 179 (empty -> .)
    TO              reduce using rule 179 (empty -> .)

    reset_dims                     shift and go to state 323
    empty                          shift and go to state 155

state 299

    (142) print_value -> empty .

    TIMES           reduce using rule 142 (print_value -> empty .)
    DIV             reduce using rule 142 (print_value -> empty .)
    PLUS            reduce using rule 142 (print_value -> empty .)
    MINUS           reduce using rule 142 (print_value -> empty .)
    ISEQUAL         reduce using rule 142 (print_value -> empty .)
    EQUAL           reduce using rule 142 (print_value -> empty .)
    NOTEQUAL        reduce using rule 142 (print_value -> empty .)
    GREATERTHAN     reduce using rule 142 (print_value -> empty .)
    GREATERORQUAL   reduce using rule 142 (print_value -> empty .)
    LESSTHAN        reduce using rule 142 (print_value -> empty .)
    LESSOREQUAL     reduce using rule 142 (print_value -> empty .)
    OR              reduce using rule 142 (print_value -> empty .)
    AND             reduce using rule 142 (print_value -> empty .)
    SEMICOL         reduce using rule 142 (print_value -> empty .)
    RPAR            reduce using rule 142 (print_value -> empty .)
    COMMA           reduce using rule 142 (print_value -> empty .)
    RBRACK          reduce using rule 142 (print_value -> empty .)
    LCURLY          reduce using rule 142 (print_value -> empty .)
    TO              reduce using rule 142 (print_value -> empty .)


state 300

    (123) factor_2 -> LPAR add_ff expression RPAR pop_ff .

    TIMES           reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    DIV             reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    PLUS            reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    MINUS           reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    ISEQUAL         reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    EQUAL           reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    NOTEQUAL        reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    GREATERTHAN     reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    GREATERORQUAL   reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    LESSTHAN        reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    LESSOREQUAL     reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    OR              reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    AND             reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    SEMICOL         reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    RPAR            reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    COMMA           reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    RBRACK          reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    LCURLY          reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    TO              reduce using rule 123 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)


state 301

    (152) pop_ff -> empty .

    TIMES           reduce using rule 152 (pop_ff -> empty .)
    DIV             reduce using rule 152 (pop_ff -> empty .)
    PLUS            reduce using rule 152 (pop_ff -> empty .)
    MINUS           reduce using rule 152 (pop_ff -> empty .)
    ISEQUAL         reduce using rule 152 (pop_ff -> empty .)
    EQUAL           reduce using rule 152 (pop_ff -> empty .)
    NOTEQUAL        reduce using rule 152 (pop_ff -> empty .)
    GREATERTHAN     reduce using rule 152 (pop_ff -> empty .)
    GREATERORQUAL   reduce using rule 152 (pop_ff -> empty .)
    LESSTHAN        reduce using rule 152 (pop_ff -> empty .)
    LESSOREQUAL     reduce using rule 152 (pop_ff -> empty .)
    OR              reduce using rule 152 (pop_ff -> empty .)
    AND             reduce using rule 152 (pop_ff -> empty .)
    SEMICOL         reduce using rule 152 (pop_ff -> empty .)
    RPAR            reduce using rule 152 (pop_ff -> empty .)
    COMMA           reduce using rule 152 (pop_ff -> empty .)
    RBRACK          reduce using rule 152 (pop_ff -> empty .)
    LCURLY          reduce using rule 152 (pop_ff -> empty .)
    TO              reduce using rule 152 (pop_ff -> empty .)


state 302

    (55) cond -> IF LPAR expression RPAR generate_g_if block cond_1 . finish_if
    (162) finish_if -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    finish_if                      shift and go to state 324
    empty                          shift and go to state 325

state 303

    (56) cond_1 -> ELSE . generate_g_else cond_2
    (163) generate_g_else -> . empty
    (179) empty -> .

    LCURLY          reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    ID              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    generate_g_else                shift and go to state 326
    empty                          shift and go to state 327

state 304

    (24) block -> LCURLY block_1 . RCURLY

    RCURLY          shift and go to state 328


state 305

    (25) block_1 -> statement .

    RCURLY          reduce using rule 25 (block_1 -> statement .)


state 306

    (61) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block . generate_g_cloop_end
    (168) generate_g_cloop_end -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    generate_g_cloop_end           shift and go to state 329
    empty                          shift and go to state 330

state 307

    (65) nloop_2 -> push_id EQUAL . push_equal expression generate_assign
    (159) push_equal -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)

    push_equal                     shift and go to state 331
    empty                          shift and go to state 258

state 308

    (62) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO . expression generate_g_nloop_s block generate_g_nloop_e
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 332
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 309

    (73) read_1 -> ID see_id read_2 push_id generate_g_read . read_3
    (76) read_3 -> . COMMA read_1
    (77) read_3 -> . empty
    (179) empty -> .

    COMMA           shift and go to state 334
    RPAR            reduce using rule 179 (empty -> .)

    read_3                         shift and go to state 333
    empty                          shift and go to state 335

state 310

    (164) generate_g_read -> empty .

    COMMA           reduce using rule 164 (generate_g_read -> empty .)
    RPAR            reduce using rule 164 (generate_g_read -> empty .)


state 311

    (86) loadfile_1 -> ID .

    COMMA           reduce using rule 86 (loadfile_1 -> ID .)


state 312

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 . COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 336


state 313

    (85) loadfile_1 -> CTEI .

    COMMA           reduce using rule 85 (loadfile_1 -> CTEI .)


state 314

    (42) dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .

    COMMA           reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    RPAR            reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    EQUAL           reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    TO              reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    TIMES           reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    DIV             reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    PLUS            reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    MINUS           reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    ISEQUAL         reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    NOTEQUAL        reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    GREATERTHAN     reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    GREATERORQUAL   reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    LESSTHAN        reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    LESSOREQUAL     reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    OR              reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    AND             reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    SEMICOL         reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    RBRACK          reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)
    LCURLY          reduce using rule 42 (dims -> LBRACK see_dims expression generate_g_verify_f dims_1 RBRACK dims_end .)


state 315

    (133) dims_end -> empty .

    COMMA           reduce using rule 133 (dims_end -> empty .)
    RPAR            reduce using rule 133 (dims_end -> empty .)
    EQUAL           reduce using rule 133 (dims_end -> empty .)
    TO              reduce using rule 133 (dims_end -> empty .)
    TIMES           reduce using rule 133 (dims_end -> empty .)
    DIV             reduce using rule 133 (dims_end -> empty .)
    PLUS            reduce using rule 133 (dims_end -> empty .)
    MINUS           reduce using rule 133 (dims_end -> empty .)
    ISEQUAL         reduce using rule 133 (dims_end -> empty .)
    NOTEQUAL        reduce using rule 133 (dims_end -> empty .)
    GREATERTHAN     reduce using rule 133 (dims_end -> empty .)
    GREATERORQUAL   reduce using rule 133 (dims_end -> empty .)
    LESSTHAN        reduce using rule 133 (dims_end -> empty .)
    LESSOREQUAL     reduce using rule 133 (dims_end -> empty .)
    OR              reduce using rule 133 (dims_end -> empty .)
    AND             reduce using rule 133 (dims_end -> empty .)
    SEMICOL         reduce using rule 133 (dims_end -> empty .)
    RBRACK          reduce using rule 133 (dims_end -> empty .)
    LCURLY          reduce using rule 133 (dims_end -> empty .)


state 316

    (43) dims_1 -> COMMA see_dims_s expression . generate_g_verify_s
    (132) generate_g_verify_s -> . empty
    (179) empty -> .

    RBRACK          reduce using rule 179 (empty -> .)

    generate_g_verify_s            shift and go to state 337
    empty                          shift and go to state 338

state 317

    (39) assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign . SEMICOL

    SEMICOL         shift and go to state 339


state 318

    (160) generate_assign -> empty .

    SEMICOL         reduce using rule 160 (generate_assign -> empty .)
    TO              reduce using rule 160 (generate_assign -> empty .)


state 319

    (67) callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .

    SEMICOL         reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    TIMES           reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    DIV             reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    PLUS            reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    MINUS           reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    ISEQUAL         reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    EQUAL           reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    NOTEQUAL        reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    GREATERTHAN     reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    GREATERORQUAL   reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    LESSTHAN        reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    LESSOREQUAL     reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    OR              reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    AND             reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    RPAR            reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    COMMA           reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    RBRACK          reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    LCURLY          reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    TO              reduce using rule 67 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)


state 320

    (68) callfunc_1 -> expression verify_params callfunc_3 .

    RPAR            reduce using rule 68 (callfunc_1 -> expression verify_params callfunc_3 .)


state 321

    (70) callfunc_3 -> COMMA . increase_p_count callfunc_1
    (175) increase_p_count -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    CTEI            reduce using rule 179 (empty -> .)
    CTEF            reduce using rule 179 (empty -> .)
    CTEB            reduce using rule 179 (empty -> .)
    CTEC            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    LPAR            reduce using rule 179 (empty -> .)
    RPAR            reduce using rule 179 (empty -> .)

    increase_p_count               shift and go to state 340
    empty                          shift and go to state 341

state 322

    (71) callfunc_3 -> empty .

    RPAR            reduce using rule 71 (callfunc_3 -> empty .)


state 323

    (116) factor_1 -> ID see_id push_id factor_3 print_value reset_dims .

    TIMES           reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    DIV             reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    PLUS            reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    MINUS           reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    ISEQUAL         reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    EQUAL           reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    NOTEQUAL        reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    GREATERTHAN     reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    GREATERORQUAL   reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    LESSTHAN        reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    LESSOREQUAL     reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    OR              reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    AND             reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    SEMICOL         reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    RPAR            reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    COMMA           reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    RBRACK          reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    LCURLY          reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)
    TO              reduce using rule 116 (factor_1 -> ID see_id push_id factor_3 print_value reset_dims .)


state 324

    (55) cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .

    ID              reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    IF              reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    WHILE           reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    FROM            reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    READ            reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    WRITE           reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    LOADFILE        reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    RETURN          reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    RCURLY          reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    END             reduce using rule 55 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)


state 325

    (162) finish_if -> empty .

    ID              reduce using rule 162 (finish_if -> empty .)
    IF              reduce using rule 162 (finish_if -> empty .)
    WHILE           reduce using rule 162 (finish_if -> empty .)
    FROM            reduce using rule 162 (finish_if -> empty .)
    READ            reduce using rule 162 (finish_if -> empty .)
    WRITE           reduce using rule 162 (finish_if -> empty .)
    LOADFILE        reduce using rule 162 (finish_if -> empty .)
    RETURN          reduce using rule 162 (finish_if -> empty .)
    RCURLY          reduce using rule 162 (finish_if -> empty .)
    END             reduce using rule 162 (finish_if -> empty .)


state 326

    (56) cond_1 -> ELSE generate_g_else . cond_2
    (57) cond_2 -> . cond_3
    (58) cond_2 -> . block
    (59) cond_3 -> . cond
    (60) cond_3 -> . empty
    (24) block -> . LCURLY block_1 RCURLY
    (55) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (179) empty -> .

  ! shift/reduce conflict for IF resolved as shift
    LCURLY          shift and go to state 275
    IF              shift and go to state 92
    ID              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

  ! IF              [ reduce using rule 179 (empty -> .) ]

    cond_2                         shift and go to state 342
    cond_3                         shift and go to state 343
    block                          shift and go to state 344
    cond                           shift and go to state 345
    empty                          shift and go to state 346

state 327

    (163) generate_g_else -> empty .

    LCURLY          reduce using rule 163 (generate_g_else -> empty .)
    IF              reduce using rule 163 (generate_g_else -> empty .)
    ID              reduce using rule 163 (generate_g_else -> empty .)
    WHILE           reduce using rule 163 (generate_g_else -> empty .)
    FROM            reduce using rule 163 (generate_g_else -> empty .)
    READ            reduce using rule 163 (generate_g_else -> empty .)
    WRITE           reduce using rule 163 (generate_g_else -> empty .)
    LOADFILE        reduce using rule 163 (generate_g_else -> empty .)
    RETURN          reduce using rule 163 (generate_g_else -> empty .)
    RCURLY          reduce using rule 163 (generate_g_else -> empty .)
    END             reduce using rule 163 (generate_g_else -> empty .)


state 328

    (24) block -> LCURLY block_1 RCURLY .

    ELSE            reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    ID              reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    IF              reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    WHILE           reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    FROM            reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    READ            reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    WRITE           reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    LOADFILE        reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    RETURN          reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    RCURLY          reduce using rule 24 (block -> LCURLY block_1 RCURLY .)
    END             reduce using rule 24 (block -> LCURLY block_1 RCURLY .)


state 329

    (61) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .

    ID              reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    IF              reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    WHILE           reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    FROM            reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    READ            reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    WRITE           reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    LOADFILE        reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    RETURN          reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    RCURLY          reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    END             reduce using rule 61 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)


state 330

    (168) generate_g_cloop_end -> empty .

    ID              reduce using rule 168 (generate_g_cloop_end -> empty .)
    IF              reduce using rule 168 (generate_g_cloop_end -> empty .)
    WHILE           reduce using rule 168 (generate_g_cloop_end -> empty .)
    FROM            reduce using rule 168 (generate_g_cloop_end -> empty .)
    READ            reduce using rule 168 (generate_g_cloop_end -> empty .)
    WRITE           reduce using rule 168 (generate_g_cloop_end -> empty .)
    LOADFILE        reduce using rule 168 (generate_g_cloop_end -> empty .)
    RETURN          reduce using rule 168 (generate_g_cloop_end -> empty .)
    RCURLY          reduce using rule 168 (generate_g_cloop_end -> empty .)
    END             reduce using rule 168 (generate_g_cloop_end -> empty .)


state 331

    (65) nloop_2 -> push_id EQUAL push_equal . expression generate_assign
    (89) expression -> . sexp check_and_or expression_1
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    expression                     shift and go to state 347
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 332

    (62) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression . generate_g_nloop_s block generate_g_nloop_e
    (169) generate_g_nloop_s -> . empty
    (179) empty -> .

    LCURLY          reduce using rule 179 (empty -> .)

    generate_g_nloop_s             shift and go to state 348
    empty                          shift and go to state 349

state 333

    (73) read_1 -> ID see_id read_2 push_id generate_g_read read_3 .

    RPAR            reduce using rule 73 (read_1 -> ID see_id read_2 push_id generate_g_read read_3 .)


state 334

    (76) read_3 -> COMMA . read_1
    (73) read_1 -> . ID see_id read_2 push_id generate_g_read read_3

    ID              shift and go to state 148

    read_1                         shift and go to state 350

state 335

    (77) read_3 -> empty .

    RPAR            reduce using rule 77 (read_3 -> empty .)


state 336

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA . loadfile_2 RPAR SEMICOL
    (87) loadfile_2 -> . CTEI
    (88) loadfile_2 -> . ID

    CTEI            shift and go to state 353
    ID              shift and go to state 351

    loadfile_2                     shift and go to state 352

state 337

    (43) dims_1 -> COMMA see_dims_s expression generate_g_verify_s .

    RBRACK          reduce using rule 43 (dims_1 -> COMMA see_dims_s expression generate_g_verify_s .)


state 338

    (132) generate_g_verify_s -> empty .

    RBRACK          reduce using rule 132 (generate_g_verify_s -> empty .)


state 339

    (39) assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .

    ID              reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    IF              reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    WHILE           reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    FROM            reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    READ            reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    WRITE           reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    LOADFILE        reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    RETURN          reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    RCURLY          reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)
    END             reduce using rule 39 (assign -> ID see_id push_id assign_1 EQUAL push_equal expression generate_assign SEMICOL .)


state 340

    (70) callfunc_3 -> COMMA increase_p_count . callfunc_1
    (68) callfunc_1 -> . expression verify_params callfunc_3
    (69) callfunc_1 -> . empty
    (89) expression -> . sexp check_and_or expression_1
    (179) empty -> .
    (94) sexp -> . exp check_relational sexp_1
    (104) exp -> . term check_sum exp_1
    (109) term -> . factor check_mul_div term_1
    (114) factor -> . factor_1
    (115) factor -> . factor_2
    (116) factor_1 -> . ID see_id push_id factor_3 print_value reset_dims
    (117) factor_1 -> . callfunc
    (118) factor_1 -> . CTEI push_int
    (119) factor_1 -> . CTEF push_float
    (120) factor_1 -> . CTEB push_bool
    (121) factor_1 -> . CTEC push_char
    (122) factor_1 -> . MINUS factor_1
    (123) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (67) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RPAR            reduce using rule 179 (empty -> .)
    ID              shift and go to state 136
    CTEI            shift and go to state 138
    CTEF            shift and go to state 139
    CTEB            shift and go to state 140
    CTEC            shift and go to state 141
    MINUS           shift and go to state 142
    LPAR            shift and go to state 143

    callfunc_1                     shift and go to state 354
    expression                     shift and go to state 260
    empty                          shift and go to state 261
    sexp                           shift and go to state 130
    exp                            shift and go to state 131
    term                           shift and go to state 132
    factor                         shift and go to state 133
    factor_1                       shift and go to state 134
    factor_2                       shift and go to state 135
    callfunc                       shift and go to state 137

state 341

    (175) increase_p_count -> empty .

    ID              reduce using rule 175 (increase_p_count -> empty .)
    CTEI            reduce using rule 175 (increase_p_count -> empty .)
    CTEF            reduce using rule 175 (increase_p_count -> empty .)
    CTEB            reduce using rule 175 (increase_p_count -> empty .)
    CTEC            reduce using rule 175 (increase_p_count -> empty .)
    MINUS           reduce using rule 175 (increase_p_count -> empty .)
    LPAR            reduce using rule 175 (increase_p_count -> empty .)
    RPAR            reduce using rule 175 (increase_p_count -> empty .)


state 342

    (56) cond_1 -> ELSE generate_g_else cond_2 .

    ID              reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    IF              reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    WHILE           reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    FROM            reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    READ            reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    WRITE           reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    LOADFILE        reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    RETURN          reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    RCURLY          reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)
    END             reduce using rule 56 (cond_1 -> ELSE generate_g_else cond_2 .)


state 343

    (57) cond_2 -> cond_3 .

    ID              reduce using rule 57 (cond_2 -> cond_3 .)
    IF              reduce using rule 57 (cond_2 -> cond_3 .)
    WHILE           reduce using rule 57 (cond_2 -> cond_3 .)
    FROM            reduce using rule 57 (cond_2 -> cond_3 .)
    READ            reduce using rule 57 (cond_2 -> cond_3 .)
    WRITE           reduce using rule 57 (cond_2 -> cond_3 .)
    LOADFILE        reduce using rule 57 (cond_2 -> cond_3 .)
    RETURN          reduce using rule 57 (cond_2 -> cond_3 .)
    RCURLY          reduce using rule 57 (cond_2 -> cond_3 .)
    END             reduce using rule 57 (cond_2 -> cond_3 .)


state 344

    (58) cond_2 -> block .

    ID              reduce using rule 58 (cond_2 -> block .)
    IF              reduce using rule 58 (cond_2 -> block .)
    WHILE           reduce using rule 58 (cond_2 -> block .)
    FROM            reduce using rule 58 (cond_2 -> block .)
    READ            reduce using rule 58 (cond_2 -> block .)
    WRITE           reduce using rule 58 (cond_2 -> block .)
    LOADFILE        reduce using rule 58 (cond_2 -> block .)
    RETURN          reduce using rule 58 (cond_2 -> block .)
    RCURLY          reduce using rule 58 (cond_2 -> block .)
    END             reduce using rule 58 (cond_2 -> block .)


state 345

    (59) cond_3 -> cond .

    ID              reduce using rule 59 (cond_3 -> cond .)
    IF              reduce using rule 59 (cond_3 -> cond .)
    WHILE           reduce using rule 59 (cond_3 -> cond .)
    FROM            reduce using rule 59 (cond_3 -> cond .)
    READ            reduce using rule 59 (cond_3 -> cond .)
    WRITE           reduce using rule 59 (cond_3 -> cond .)
    LOADFILE        reduce using rule 59 (cond_3 -> cond .)
    RETURN          reduce using rule 59 (cond_3 -> cond .)
    RCURLY          reduce using rule 59 (cond_3 -> cond .)
    END             reduce using rule 59 (cond_3 -> cond .)


state 346

    (60) cond_3 -> empty .

    ID              reduce using rule 60 (cond_3 -> empty .)
    IF              reduce using rule 60 (cond_3 -> empty .)
    WHILE           reduce using rule 60 (cond_3 -> empty .)
    FROM            reduce using rule 60 (cond_3 -> empty .)
    READ            reduce using rule 60 (cond_3 -> empty .)
    WRITE           reduce using rule 60 (cond_3 -> empty .)
    LOADFILE        reduce using rule 60 (cond_3 -> empty .)
    RETURN          reduce using rule 60 (cond_3 -> empty .)
    RCURLY          reduce using rule 60 (cond_3 -> empty .)
    END             reduce using rule 60 (cond_3 -> empty .)


state 347

    (65) nloop_2 -> push_id EQUAL push_equal expression . generate_assign
    (160) generate_assign -> . empty
    (179) empty -> .

    TO              reduce using rule 179 (empty -> .)

    generate_assign                shift and go to state 355
    empty                          shift and go to state 318

state 348

    (62) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s . block generate_g_nloop_e
    (24) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 275

    block                          shift and go to state 356

state 349

    (169) generate_g_nloop_s -> empty .

    LCURLY          reduce using rule 169 (generate_g_nloop_s -> empty .)


state 350

    (76) read_3 -> COMMA read_1 .

    RPAR            reduce using rule 76 (read_3 -> COMMA read_1 .)


state 351

    (88) loadfile_2 -> ID .

    RPAR            reduce using rule 88 (loadfile_2 -> ID .)


state 352

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 . RPAR SEMICOL

    RPAR            shift and go to state 357


state 353

    (87) loadfile_2 -> CTEI .

    RPAR            reduce using rule 87 (loadfile_2 -> CTEI .)


state 354

    (70) callfunc_3 -> COMMA increase_p_count callfunc_1 .

    RPAR            reduce using rule 70 (callfunc_3 -> COMMA increase_p_count callfunc_1 .)


state 355

    (65) nloop_2 -> push_id EQUAL push_equal expression generate_assign .

    TO              reduce using rule 65 (nloop_2 -> push_id EQUAL push_equal expression generate_assign .)


state 356

    (62) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block . generate_g_nloop_e
    (170) generate_g_nloop_e -> . empty
    (179) empty -> .

    ID              reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    FROM            reduce using rule 179 (empty -> .)
    READ            reduce using rule 179 (empty -> .)
    WRITE           reduce using rule 179 (empty -> .)
    LOADFILE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    RCURLY          reduce using rule 179 (empty -> .)
    END             reduce using rule 179 (empty -> .)

    generate_g_nloop_e             shift and go to state 358
    empty                          shift and go to state 359

state 357

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR . SEMICOL

    SEMICOL         shift and go to state 360


state 358

    (62) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .

    ID              reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    IF              reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    WHILE           reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    FROM            reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    READ            reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    WRITE           reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    LOADFILE        reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    RETURN          reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    RCURLY          reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    END             reduce using rule 62 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)


state 359

    (170) generate_g_nloop_e -> empty .

    ID              reduce using rule 170 (generate_g_nloop_e -> empty .)
    IF              reduce using rule 170 (generate_g_nloop_e -> empty .)
    WHILE           reduce using rule 170 (generate_g_nloop_e -> empty .)
    FROM            reduce using rule 170 (generate_g_nloop_e -> empty .)
    READ            reduce using rule 170 (generate_g_nloop_e -> empty .)
    WRITE           reduce using rule 170 (generate_g_nloop_e -> empty .)
    LOADFILE        reduce using rule 170 (generate_g_nloop_e -> empty .)
    RETURN          reduce using rule 170 (generate_g_nloop_e -> empty .)
    RCURLY          reduce using rule 170 (generate_g_nloop_e -> empty .)
    END             reduce using rule 170 (generate_g_nloop_e -> empty .)


state 360

    (84) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .

    ID              reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    IF              reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    WHILE           reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    FROM            reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    READ            reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    WRITE           reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    LOADFILE        reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    RETURN          reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    RCURLY          reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    END             reduce using rule 84 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 326 resolved as shift
