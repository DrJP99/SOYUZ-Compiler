Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program_start
Rule 1     program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main
Rule 2     program_start_1 -> vars
Rule 3     program_start_2 -> funcs
Rule 4     program_start_2 -> empty
Rule 5     vars -> VAR type COL vars_1 SEMICOL vars
Rule 6     vars -> empty
Rule 7     vars_1 -> ID see_id vars_2 push_var vars_3
Rule 8     vars_2 -> dims
Rule 9     vars_2 -> empty
Rule 10    vars_3 -> COMMA vars_1
Rule 11    vars_3 -> empty
Rule 12    type -> INT
Rule 13    type -> FLOAT
Rule 14    type -> CHAR
Rule 15    type -> BOOL
Rule 16    rtype -> INT
Rule 17    rtype -> FLOAT
Rule 18    rtype -> CHAR
Rule 19    rtype -> BOOL
Rule 20    rtype -> VOID
Rule 21    block -> LCURLY block_1 RCURLY
Rule 22    block_1 -> statement
Rule 23    funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
Rule 24    funcs_1 -> vars
Rule 25    funcs_2 -> RETURN expression SEMICOL
Rule 26    funcs_2 -> empty
Rule 27    funcs_3 -> funcs
Rule 28    funcs_3 -> empty
Rule 29    params -> LPAR params_1 RPAR
Rule 30    params_1 -> type ID see_id params_2 see_end_param reset_dims params_3
Rule 31    params_1 -> empty
Rule 32    params_2 -> dims
Rule 33    params_2 -> empty
Rule 34    params_3 -> COMMA params_1
Rule 35    params_3 -> empty
Rule 36    assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
Rule 37    assign_1 -> dims
Rule 38    assign_1 -> empty
Rule 39    dims -> LBRACK expression see_dims dims_1 RBRACK
Rule 40    dims_1 -> COMMA expression see_dims
Rule 41    dims_1 -> empty
Rule 42    statement -> statement_1 statement
Rule 43    statement -> empty
Rule 44    statement_1 -> assign
Rule 45    statement_1 -> cond
Rule 46    statement_1 -> cloop
Rule 47    statement_1 -> nloop
Rule 48    statement_1 -> read
Rule 49    statement_1 -> write
Rule 50    statement_1 -> loadfile
Rule 51    statement_1 -> callfunc SEMICOL
Rule 52    cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if
Rule 53    cond_1 -> ELSE generate_g_else cond_2
Rule 54    cond_2 -> cond_3
Rule 55    cond_2 -> block
Rule 56    cond_3 -> cond
Rule 57    cond_3 -> empty
Rule 58    cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
Rule 59    nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
Rule 60    nloop_1 -> dims
Rule 61    nloop_1 -> empty
Rule 62    nloop_2 -> push_id EQUAL push_equal expression generate_assign
Rule 63    nloop_2 -> empty
Rule 64    callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
Rule 65    callfunc_1 -> expression verify_params callfunc_3
Rule 66    callfunc_1 -> empty
Rule 67    callfunc_3 -> COMMA increase_p_count callfunc_1
Rule 68    callfunc_3 -> empty
Rule 69    read -> READ LPAR read_1 RPAR SEMICOL
Rule 70    read_1 -> ID see_id read_2 push_id generate_g_read read_3
Rule 71    read_2 -> dims reset_dims
Rule 72    read_2 -> empty
Rule 73    read_3 -> COMMA read_1
Rule 74    read_3 -> empty
Rule 75    write -> WRITE LPAR write_1 RPAR SEMICOL
Rule 76    write_1 -> write_2 generate_g_write write_3
Rule 77    write_2 -> expression
Rule 78    write_2 -> CTES push_string
Rule 79    write_3 -> COMMA write_1
Rule 80    write_3 -> empty
Rule 81    loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
Rule 82    loadfile_1 -> CTEI
Rule 83    loadfile_1 -> ID
Rule 84    loadfile_2 -> CTEI
Rule 85    loadfile_2 -> ID
Rule 86    expression -> sexp check_and_or expression_1
Rule 87    expression_1 -> expression_2 push_and_or expression
Rule 88    expression_1 -> empty
Rule 89    expression_2 -> OR
Rule 90    expression_2 -> AND
Rule 91    sexp -> exp check_relational sexp_1
Rule 92    sexp_1 -> sexp_2 push_relational sexp
Rule 93    sexp_1 -> empty
Rule 94    sexp_2 -> ISEQUAL
Rule 95    sexp_2 -> EQUAL
Rule 96    sexp_2 -> NOTEQUAL
Rule 97    sexp_2 -> GREATERTHAN
Rule 98    sexp_2 -> GREATERORQUAL
Rule 99    sexp_2 -> LESSTHAN
Rule 100   sexp_2 -> LESSOREQUAL
Rule 101   exp -> term check_sum exp_1
Rule 102   exp_1 -> exp_2 push_sum exp
Rule 103   exp_1 -> empty
Rule 104   exp_2 -> PLUS
Rule 105   exp_2 -> MINUS
Rule 106   term -> factor check_mul_div term_1
Rule 107   term_1 -> term_2 push_mul_div term
Rule 108   term_1 -> empty
Rule 109   term_2 -> TIMES
Rule 110   term_2 -> DIV
Rule 111   factor -> factor_1
Rule 112   factor -> factor_2
Rule 113   factor_1 -> ID see_id factor_3 push_id print_value reset_dims
Rule 114   factor_1 -> callfunc
Rule 115   factor_1 -> CTEI push_int
Rule 116   factor_1 -> CTEF push_float
Rule 117   factor_1 -> CTEB push_bool
Rule 118   factor_1 -> CTEC push_char
Rule 119   factor_1 -> MINUS factor_1
Rule 120   factor_2 -> LPAR add_ff expression RPAR pop_ff
Rule 121   factor_3 -> dims
Rule 122   factor_3 -> empty
Rule 123   main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
Rule 124   main_1 -> vars
Rule 125   see_id -> empty
Rule 126   see_dims -> empty
Rule 127   push_var -> empty
Rule 128   see_func_start -> empty
Rule 129   see_func_end -> empty
Rule 130   set_func_init -> empty
Rule 131   see_end_param -> empty
Rule 132   reset_dims -> empty
Rule 133   print_value -> empty
Rule 134   check_and_or -> empty
Rule 135   push_and_or -> empty
Rule 136   check_relational -> empty
Rule 137   push_relational -> empty
Rule 138   check_sum -> empty
Rule 139   push_sum -> empty
Rule 140   check_mul_div -> empty
Rule 141   push_mul_div -> empty
Rule 142   add_ff -> empty
Rule 143   pop_ff -> empty
Rule 144   push_int -> empty
Rule 145   push_float -> empty
Rule 146   push_bool -> empty
Rule 147   push_char -> empty
Rule 148   push_string -> empty
Rule 149   push_id -> empty
Rule 150   push_equal -> empty
Rule 151   generate_assign -> empty
Rule 152   generate_g_if -> empty
Rule 153   finish_if -> empty
Rule 154   generate_g_else -> empty
Rule 155   generate_g_read -> empty
Rule 156   generate_g_write -> empty
Rule 157   cloop_push_jump -> empty
Rule 158   generate_g_cloop_start -> empty
Rule 159   generate_g_cloop_end -> empty
Rule 160   generate_g_nloop_s -> empty
Rule 161   generate_g_nloop_e -> empty
Rule 162   generate_end -> empty
Rule 163   verify_func -> empty
Rule 164   activate_record -> empty
Rule 165   verify_params -> empty
Rule 166   increase_p_count -> empty
Rule 167   verify_p_num -> empty
Rule 168   main_goto -> empty
Rule 169   fill_main_goto -> empty
Rule 170   empty -> <empty>

Terminals, with rules where they appear

AND                  : 90
BOOL                 : 15 19
CHAR                 : 14 18
COL                  : 5
COMMA                : 10 34 40 67 73 79 81 81 81
COMMENT              : 
CTEB                 : 117
CTEC                 : 118
CTEF                 : 116
CTEI                 : 82 84 115
CTES                 : 78 81
DIV                  : 110
ELSE                 : 53
END                  : 123
EQUAL                : 36 62 95
FLOAT                : 13 17
FROM                 : 59
FUNC                 : 23
GREATERORQUAL        : 98
GREATERTHAN          : 97
ID                   : 1 7 23 30 36 59 64 70 81 83 85 113
IF                   : 52
INT                  : 12 16
ISEQUAL              : 94
LBRACK               : 39
LCURLY               : 21 23 123
LESSOREQUAL          : 100
LESSTHAN             : 99
LOADFILE             : 81
LPAR                 : 29 52 58 64 69 75 81 120 123
MAIN                 : 123
MINUS                : 105 119
NOTEQUAL             : 96
OR                   : 89
PLUS                 : 104
PROGRAM              : 1
RBRACK               : 39
RCURLY               : 21 23 123
READ                 : 69
RETURN               : 25
RPAR                 : 29 52 58 64 69 75 81 120 123
SEMICOL              : 1 5 25 36 51 69 75 81 123
TIMES                : 109
TO                   : 59
VAR                  : 5
VOID                 : 20
WHILE                : 58
WRITE                : 75
error                : 

Nonterminals, with rules where they appear

activate_record      : 64
add_ff               : 120
assign               : 44
assign_1             : 36
block                : 52 55 58 59
block_1              : 21
callfunc             : 51 114
callfunc_1           : 64 67
callfunc_3           : 65
check_and_or         : 86
check_mul_div        : 106
check_relational     : 91
check_sum            : 101
cloop                : 46
cloop_push_jump      : 58
cond                 : 45 56
cond_1               : 52
cond_2               : 53
cond_3               : 54
dims                 : 8 32 37 60 71 121
dims_1               : 39
empty                : 4 6 9 11 26 28 31 33 35 38 41 43 57 61 63 66 68 72 74 80 88 93 103 108 122 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169
exp                  : 91 102
exp_1                : 101
exp_2                : 102
expression           : 25 36 39 40 52 58 59 62 65 77 87 120
expression_1         : 86
expression_2         : 87
factor               : 106
factor_1             : 111 119
factor_2             : 112
factor_3             : 113
fill_main_goto       : 123
finish_if            : 52
funcs                : 3 27
funcs_1              : 23
funcs_2              : 23
funcs_3              : 23
generate_assign      : 36 62
generate_end         : 123
generate_g_cloop_end : 58
generate_g_cloop_start : 58
generate_g_else      : 53
generate_g_if        : 52
generate_g_nloop_e   : 59
generate_g_nloop_s   : 59
generate_g_read      : 70
generate_g_write     : 76
increase_p_count     : 67
loadfile             : 50
loadfile_1           : 81
loadfile_2           : 81
main                 : 1
main_1               : 123
main_goto            : 1
nloop                : 47
nloop_1              : 59
nloop_2              : 59
params               : 23
params_1             : 29 34
params_2             : 30
params_3             : 30
pop_ff               : 120
print_value          : 113
program_start        : 0
program_start_1      : 1
program_start_2      : 1
push_and_or          : 87
push_bool            : 117
push_char            : 118
push_equal           : 36 62
push_float           : 116
push_id              : 36 59 62 70 113
push_int             : 115
push_mul_div         : 107
push_relational      : 92
push_string          : 78
push_sum             : 102
push_var             : 7
read                 : 48
read_1               : 69 73
read_2               : 70
read_3               : 70
reset_dims           : 30 71 113
rtype                : 23
see_dims             : 39 40
see_end_param        : 30
see_func_end         : 23 123
see_func_start       : 23 123
see_id               : 7 23 30 36 59 64 70 113 123
set_func_init        : 23 123
sexp                 : 86 92
sexp_1               : 91
sexp_2               : 92
statement            : 22 23 42 123
statement_1          : 42
term                 : 101 107
term_1               : 106
term_2               : 107
type                 : 5 30
vars                 : 2 5 24 124
vars_1               : 5 10
vars_2               : 7
vars_3               : 7
verify_func          : 64
verify_p_num         : 64
verify_params        : 65
write                : 49
write_1              : 75 79
write_2              : 76
write_3              : 76

Parsing method: LALR

state 0

    (0) S' -> . program_start
    (1) program_start -> . main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main
    (168) main_goto -> . empty
    (170) empty -> .

    PROGRAM         reduce using rule 170 (empty -> .)

    program_start                  shift and go to state 1
    main_goto                      shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program_start .



state 2

    (1) program_start -> main_goto . PROGRAM ID SEMICOL program_start_1 program_start_2 main

    PROGRAM         shift and go to state 4


state 3

    (168) main_goto -> empty .

    PROGRAM         reduce using rule 168 (main_goto -> empty .)


state 4

    (1) program_start -> main_goto PROGRAM . ID SEMICOL program_start_1 program_start_2 main

    ID              shift and go to state 5


state 5

    (1) program_start -> main_goto PROGRAM ID . SEMICOL program_start_1 program_start_2 main

    SEMICOL         shift and go to state 6


state 6

    (1) program_start -> main_goto PROGRAM ID SEMICOL . program_start_1 program_start_2 main
    (2) program_start_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (170) empty -> .

    VAR             shift and go to state 9
    FUNC            reduce using rule 170 (empty -> .)
    MAIN            reduce using rule 170 (empty -> .)

    program_start_1                shift and go to state 7
    vars                           shift and go to state 8
    empty                          shift and go to state 10

state 7

    (1) program_start -> main_goto PROGRAM ID SEMICOL program_start_1 . program_start_2 main
    (3) program_start_2 -> . funcs
    (4) program_start_2 -> . empty
    (23) funcs -> . FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (170) empty -> .

    FUNC            shift and go to state 14
    MAIN            reduce using rule 170 (empty -> .)

    program_start_2                shift and go to state 11
    funcs                          shift and go to state 12
    empty                          shift and go to state 13

state 8

    (2) program_start_1 -> vars .

    FUNC            reduce using rule 2 (program_start_1 -> vars .)
    MAIN            reduce using rule 2 (program_start_1 -> vars .)


state 9

    (5) vars -> VAR . type COL vars_1 SEMICOL vars
    (12) type -> . INT
    (13) type -> . FLOAT
    (14) type -> . CHAR
    (15) type -> . BOOL

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19

    type                           shift and go to state 15

state 10

    (6) vars -> empty .

    FUNC            reduce using rule 6 (vars -> empty .)
    MAIN            reduce using rule 6 (vars -> empty .)
    ID              reduce using rule 6 (vars -> empty .)
    IF              reduce using rule 6 (vars -> empty .)
    WHILE           reduce using rule 6 (vars -> empty .)
    FROM            reduce using rule 6 (vars -> empty .)
    READ            reduce using rule 6 (vars -> empty .)
    WRITE           reduce using rule 6 (vars -> empty .)
    LOADFILE        reduce using rule 6 (vars -> empty .)
    END             reduce using rule 6 (vars -> empty .)
    RETURN          reduce using rule 6 (vars -> empty .)
    RCURLY          reduce using rule 6 (vars -> empty .)


state 11

    (1) program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 . main
    (123) main -> . MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 12

    (3) program_start_2 -> funcs .

    MAIN            reduce using rule 3 (program_start_2 -> funcs .)


state 13

    (4) program_start_2 -> empty .

    MAIN            reduce using rule 4 (program_start_2 -> empty .)


state 14

    (23) funcs -> FUNC . rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (16) rtype -> . INT
    (17) rtype -> . FLOAT
    (18) rtype -> . CHAR
    (19) rtype -> . BOOL
    (20) rtype -> . VOID

    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    CHAR            shift and go to state 25
    BOOL            shift and go to state 26
    VOID            shift and go to state 27

    rtype                          shift and go to state 22

state 15

    (5) vars -> VAR type . COL vars_1 SEMICOL vars

    COL             shift and go to state 28


state 16

    (12) type -> INT .

    COL             reduce using rule 12 (type -> INT .)
    ID              reduce using rule 12 (type -> INT .)


state 17

    (13) type -> FLOAT .

    COL             reduce using rule 13 (type -> FLOAT .)
    ID              reduce using rule 13 (type -> FLOAT .)


state 18

    (14) type -> CHAR .

    COL             reduce using rule 14 (type -> CHAR .)
    ID              reduce using rule 14 (type -> CHAR .)


state 19

    (15) type -> BOOL .

    COL             reduce using rule 15 (type -> BOOL .)
    ID              reduce using rule 15 (type -> BOOL .)


state 20

    (1) program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main .

    $end            reduce using rule 1 (program_start -> main_goto PROGRAM ID SEMICOL program_start_1 program_start_2 main .)


state 21

    (123) main -> MAIN . see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (125) see_id -> . empty
    (170) empty -> .

    LPAR            reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 29
    empty                          shift and go to state 30

state 22

    (23) funcs -> FUNC rtype . ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3

    ID              shift and go to state 31


state 23

    (16) rtype -> INT .

    ID              reduce using rule 16 (rtype -> INT .)


state 24

    (17) rtype -> FLOAT .

    ID              reduce using rule 17 (rtype -> FLOAT .)


state 25

    (18) rtype -> CHAR .

    ID              reduce using rule 18 (rtype -> CHAR .)


state 26

    (19) rtype -> BOOL .

    ID              reduce using rule 19 (rtype -> BOOL .)


state 27

    (20) rtype -> VOID .

    ID              reduce using rule 20 (rtype -> VOID .)


state 28

    (5) vars -> VAR type COL . vars_1 SEMICOL vars
    (7) vars_1 -> . ID see_id vars_2 push_var vars_3

    ID              shift and go to state 33

    vars_1                         shift and go to state 32

state 29

    (123) main -> MAIN see_id . LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    LPAR            shift and go to state 34


state 30

    (125) see_id -> empty .

    LPAR            reduce using rule 125 (see_id -> empty .)
    LBRACK          reduce using rule 125 (see_id -> empty .)
    COMMA           reduce using rule 125 (see_id -> empty .)
    SEMICOL         reduce using rule 125 (see_id -> empty .)
    TIMES           reduce using rule 125 (see_id -> empty .)
    DIV             reduce using rule 125 (see_id -> empty .)
    PLUS            reduce using rule 125 (see_id -> empty .)
    MINUS           reduce using rule 125 (see_id -> empty .)
    ISEQUAL         reduce using rule 125 (see_id -> empty .)
    EQUAL           reduce using rule 125 (see_id -> empty .)
    NOTEQUAL        reduce using rule 125 (see_id -> empty .)
    GREATERTHAN     reduce using rule 125 (see_id -> empty .)
    GREATERORQUAL   reduce using rule 125 (see_id -> empty .)
    LESSTHAN        reduce using rule 125 (see_id -> empty .)
    LESSOREQUAL     reduce using rule 125 (see_id -> empty .)
    OR              reduce using rule 125 (see_id -> empty .)
    AND             reduce using rule 125 (see_id -> empty .)
    RBRACK          reduce using rule 125 (see_id -> empty .)
    RPAR            reduce using rule 125 (see_id -> empty .)
    LCURLY          reduce using rule 125 (see_id -> empty .)
    TO              reduce using rule 125 (see_id -> empty .)


state 31

    (23) funcs -> FUNC rtype ID . see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (125) see_id -> . empty
    (170) empty -> .

    LPAR            reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 35
    empty                          shift and go to state 30

state 32

    (5) vars -> VAR type COL vars_1 . SEMICOL vars

    SEMICOL         shift and go to state 36


state 33

    (7) vars_1 -> ID . see_id vars_2 push_var vars_3
    (125) see_id -> . empty
    (170) empty -> .

    LBRACK          reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 37
    empty                          shift and go to state 30

state 34

    (123) main -> MAIN see_id LPAR . RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    RPAR            shift and go to state 38


state 35

    (23) funcs -> FUNC rtype ID see_id . see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (128) see_func_start -> . empty
    (170) empty -> .

    LPAR            reduce using rule 170 (empty -> .)

    see_func_start                 shift and go to state 39
    empty                          shift and go to state 40

state 36

    (5) vars -> VAR type COL vars_1 SEMICOL . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (170) empty -> .

    VAR             shift and go to state 9
    FUNC            reduce using rule 170 (empty -> .)
    MAIN            reduce using rule 170 (empty -> .)
    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)

    vars                           shift and go to state 41
    empty                          shift and go to state 10

state 37

    (7) vars_1 -> ID see_id . vars_2 push_var vars_3
    (8) vars_2 -> . dims
    (9) vars_2 -> . empty
    (39) dims -> . LBRACK expression see_dims dims_1 RBRACK
    (170) empty -> .

    LBRACK          shift and go to state 45
    COMMA           reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)

    vars_2                         shift and go to state 42
    dims                           shift and go to state 43
    empty                          shift and go to state 44

state 38

    (123) main -> MAIN see_id LPAR RPAR . LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end

    LCURLY          shift and go to state 46


state 39

    (23) funcs -> FUNC rtype ID see_id see_func_start . params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (29) params -> . LPAR params_1 RPAR

    LPAR            shift and go to state 48

    params                         shift and go to state 47

state 40

    (128) see_func_start -> empty .

    LPAR            reduce using rule 128 (see_func_start -> empty .)
    VAR             reduce using rule 128 (see_func_start -> empty .)
    ID              reduce using rule 128 (see_func_start -> empty .)
    IF              reduce using rule 128 (see_func_start -> empty .)
    WHILE           reduce using rule 128 (see_func_start -> empty .)
    FROM            reduce using rule 128 (see_func_start -> empty .)
    READ            reduce using rule 128 (see_func_start -> empty .)
    WRITE           reduce using rule 128 (see_func_start -> empty .)
    LOADFILE        reduce using rule 128 (see_func_start -> empty .)
    END             reduce using rule 128 (see_func_start -> empty .)


state 41

    (5) vars -> VAR type COL vars_1 SEMICOL vars .

    FUNC            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    MAIN            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    ID              reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    IF              reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    WHILE           reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    FROM            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    READ            reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    WRITE           reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    LOADFILE        reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    END             reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    RETURN          reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)
    RCURLY          reduce using rule 5 (vars -> VAR type COL vars_1 SEMICOL vars .)


state 42

    (7) vars_1 -> ID see_id vars_2 . push_var vars_3
    (127) push_var -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)

    push_var                       shift and go to state 49
    empty                          shift and go to state 50

state 43

    (8) vars_2 -> dims .

    COMMA           reduce using rule 8 (vars_2 -> dims .)
    SEMICOL         reduce using rule 8 (vars_2 -> dims .)


state 44

    (9) vars_2 -> empty .

    COMMA           reduce using rule 9 (vars_2 -> empty .)
    SEMICOL         reduce using rule 9 (vars_2 -> empty .)


state 45

    (39) dims -> LBRACK . expression see_dims dims_1 RBRACK
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 51
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 46

    (123) main -> MAIN see_id LPAR RPAR LCURLY . see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (128) see_func_start -> . empty
    (170) empty -> .

    VAR             reduce using rule 170 (empty -> .)
    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    see_func_start                 shift and go to state 66
    empty                          shift and go to state 40

state 47

    (23) funcs -> FUNC rtype ID see_id see_func_start params . LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3

    LCURLY          shift and go to state 67


state 48

    (29) params -> LPAR . params_1 RPAR
    (30) params_1 -> . type ID see_id params_2 see_end_param reset_dims params_3
    (31) params_1 -> . empty
    (12) type -> . INT
    (13) type -> . FLOAT
    (14) type -> . CHAR
    (15) type -> . BOOL
    (170) empty -> .

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19
    RPAR            reduce using rule 170 (empty -> .)

    params_1                       shift and go to state 68
    type                           shift and go to state 69
    empty                          shift and go to state 70

state 49

    (7) vars_1 -> ID see_id vars_2 push_var . vars_3
    (10) vars_3 -> . COMMA vars_1
    (11) vars_3 -> . empty
    (170) empty -> .

    COMMA           shift and go to state 72
    SEMICOL         reduce using rule 170 (empty -> .)

    vars_3                         shift and go to state 71
    empty                          shift and go to state 73

state 50

    (127) push_var -> empty .

    COMMA           reduce using rule 127 (push_var -> empty .)
    SEMICOL         reduce using rule 127 (push_var -> empty .)


state 51

    (39) dims -> LBRACK expression . see_dims dims_1 RBRACK
    (126) see_dims -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)

    see_dims                       shift and go to state 74
    empty                          shift and go to state 75

state 52

    (86) expression -> sexp . check_and_or expression_1
    (134) check_and_or -> . empty
    (170) empty -> .

    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    check_and_or                   shift and go to state 76
    empty                          shift and go to state 77

state 53

    (91) sexp -> exp . check_relational sexp_1
    (136) check_relational -> . empty
    (170) empty -> .

    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    check_relational               shift and go to state 78
    empty                          shift and go to state 79

state 54

    (101) exp -> term . check_sum exp_1
    (138) check_sum -> . empty
    (170) empty -> .

    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    check_sum                      shift and go to state 80
    empty                          shift and go to state 81

state 55

    (106) term -> factor . check_mul_div term_1
    (140) check_mul_div -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    check_mul_div                  shift and go to state 82
    empty                          shift and go to state 83

state 56

    (111) factor -> factor_1 .

    TIMES           reduce using rule 111 (factor -> factor_1 .)
    DIV             reduce using rule 111 (factor -> factor_1 .)
    PLUS            reduce using rule 111 (factor -> factor_1 .)
    MINUS           reduce using rule 111 (factor -> factor_1 .)
    ISEQUAL         reduce using rule 111 (factor -> factor_1 .)
    EQUAL           reduce using rule 111 (factor -> factor_1 .)
    NOTEQUAL        reduce using rule 111 (factor -> factor_1 .)
    GREATERTHAN     reduce using rule 111 (factor -> factor_1 .)
    GREATERORQUAL   reduce using rule 111 (factor -> factor_1 .)
    LESSTHAN        reduce using rule 111 (factor -> factor_1 .)
    LESSOREQUAL     reduce using rule 111 (factor -> factor_1 .)
    OR              reduce using rule 111 (factor -> factor_1 .)
    AND             reduce using rule 111 (factor -> factor_1 .)
    COMMA           reduce using rule 111 (factor -> factor_1 .)
    RBRACK          reduce using rule 111 (factor -> factor_1 .)
    RPAR            reduce using rule 111 (factor -> factor_1 .)
    SEMICOL         reduce using rule 111 (factor -> factor_1 .)
    LCURLY          reduce using rule 111 (factor -> factor_1 .)
    TO              reduce using rule 111 (factor -> factor_1 .)


state 57

    (112) factor -> factor_2 .

    TIMES           reduce using rule 112 (factor -> factor_2 .)
    DIV             reduce using rule 112 (factor -> factor_2 .)
    PLUS            reduce using rule 112 (factor -> factor_2 .)
    MINUS           reduce using rule 112 (factor -> factor_2 .)
    ISEQUAL         reduce using rule 112 (factor -> factor_2 .)
    EQUAL           reduce using rule 112 (factor -> factor_2 .)
    NOTEQUAL        reduce using rule 112 (factor -> factor_2 .)
    GREATERTHAN     reduce using rule 112 (factor -> factor_2 .)
    GREATERORQUAL   reduce using rule 112 (factor -> factor_2 .)
    LESSTHAN        reduce using rule 112 (factor -> factor_2 .)
    LESSOREQUAL     reduce using rule 112 (factor -> factor_2 .)
    OR              reduce using rule 112 (factor -> factor_2 .)
    AND             reduce using rule 112 (factor -> factor_2 .)
    COMMA           reduce using rule 112 (factor -> factor_2 .)
    RBRACK          reduce using rule 112 (factor -> factor_2 .)
    RPAR            reduce using rule 112 (factor -> factor_2 .)
    SEMICOL         reduce using rule 112 (factor -> factor_2 .)
    LCURLY          reduce using rule 112 (factor -> factor_2 .)
    TO              reduce using rule 112 (factor -> factor_2 .)


state 58

    (113) factor_1 -> ID . see_id factor_3 push_id print_value reset_dims
    (64) callfunc -> ID . see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (125) see_id -> . empty
    (170) empty -> .

    LBRACK          reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)
    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 84
    empty                          shift and go to state 30

state 59

    (114) factor_1 -> callfunc .

    TIMES           reduce using rule 114 (factor_1 -> callfunc .)
    DIV             reduce using rule 114 (factor_1 -> callfunc .)
    PLUS            reduce using rule 114 (factor_1 -> callfunc .)
    MINUS           reduce using rule 114 (factor_1 -> callfunc .)
    ISEQUAL         reduce using rule 114 (factor_1 -> callfunc .)
    EQUAL           reduce using rule 114 (factor_1 -> callfunc .)
    NOTEQUAL        reduce using rule 114 (factor_1 -> callfunc .)
    GREATERTHAN     reduce using rule 114 (factor_1 -> callfunc .)
    GREATERORQUAL   reduce using rule 114 (factor_1 -> callfunc .)
    LESSTHAN        reduce using rule 114 (factor_1 -> callfunc .)
    LESSOREQUAL     reduce using rule 114 (factor_1 -> callfunc .)
    OR              reduce using rule 114 (factor_1 -> callfunc .)
    AND             reduce using rule 114 (factor_1 -> callfunc .)
    COMMA           reduce using rule 114 (factor_1 -> callfunc .)
    RBRACK          reduce using rule 114 (factor_1 -> callfunc .)
    RPAR            reduce using rule 114 (factor_1 -> callfunc .)
    SEMICOL         reduce using rule 114 (factor_1 -> callfunc .)
    LCURLY          reduce using rule 114 (factor_1 -> callfunc .)
    TO              reduce using rule 114 (factor_1 -> callfunc .)


state 60

    (115) factor_1 -> CTEI . push_int
    (144) push_int -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    push_int                       shift and go to state 85
    empty                          shift and go to state 86

state 61

    (116) factor_1 -> CTEF . push_float
    (145) push_float -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    push_float                     shift and go to state 87
    empty                          shift and go to state 88

state 62

    (117) factor_1 -> CTEB . push_bool
    (146) push_bool -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    push_bool                      shift and go to state 89
    empty                          shift and go to state 90

state 63

    (118) factor_1 -> CTEC . push_char
    (147) push_char -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    push_char                      shift and go to state 91
    empty                          shift and go to state 92

state 64

    (119) factor_1 -> MINUS . factor_1
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64

    factor_1                       shift and go to state 93
    callfunc                       shift and go to state 59

state 65

    (120) factor_2 -> LPAR . add_ff expression RPAR pop_ff
    (142) add_ff -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    add_ff                         shift and go to state 94
    empty                          shift and go to state 95

state 66

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start . main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (124) main_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (170) empty -> .

    VAR             shift and go to state 9
    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    main_1                         shift and go to state 96
    vars                           shift and go to state 97
    empty                          shift and go to state 10

state 67

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY . funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (24) funcs_1 -> . vars
    (5) vars -> . VAR type COL vars_1 SEMICOL vars
    (6) vars -> . empty
    (170) empty -> .

    VAR             shift and go to state 9
    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)

    funcs_1                        shift and go to state 98
    vars                           shift and go to state 99
    empty                          shift and go to state 10

state 68

    (29) params -> LPAR params_1 . RPAR

    RPAR            shift and go to state 100


state 69

    (30) params_1 -> type . ID see_id params_2 see_end_param reset_dims params_3

    ID              shift and go to state 101


state 70

    (31) params_1 -> empty .

    RPAR            reduce using rule 31 (params_1 -> empty .)


state 71

    (7) vars_1 -> ID see_id vars_2 push_var vars_3 .

    SEMICOL         reduce using rule 7 (vars_1 -> ID see_id vars_2 push_var vars_3 .)


state 72

    (10) vars_3 -> COMMA . vars_1
    (7) vars_1 -> . ID see_id vars_2 push_var vars_3

    ID              shift and go to state 33

    vars_1                         shift and go to state 102

state 73

    (11) vars_3 -> empty .

    SEMICOL         reduce using rule 11 (vars_3 -> empty .)


state 74

    (39) dims -> LBRACK expression see_dims . dims_1 RBRACK
    (40) dims_1 -> . COMMA expression see_dims
    (41) dims_1 -> . empty
    (170) empty -> .

    COMMA           shift and go to state 104
    RBRACK          reduce using rule 170 (empty -> .)

    dims_1                         shift and go to state 103
    empty                          shift and go to state 105

state 75

    (126) see_dims -> empty .

    COMMA           reduce using rule 126 (see_dims -> empty .)
    RBRACK          reduce using rule 126 (see_dims -> empty .)


state 76

    (86) expression -> sexp check_and_or . expression_1
    (87) expression_1 -> . expression_2 push_and_or expression
    (88) expression_1 -> . empty
    (89) expression_2 -> . OR
    (90) expression_2 -> . AND
    (170) empty -> .

    OR              shift and go to state 109
    AND             shift and go to state 110
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    expression_1                   shift and go to state 106
    expression_2                   shift and go to state 107
    empty                          shift and go to state 108

state 77

    (134) check_and_or -> empty .

    OR              reduce using rule 134 (check_and_or -> empty .)
    AND             reduce using rule 134 (check_and_or -> empty .)
    COMMA           reduce using rule 134 (check_and_or -> empty .)
    RBRACK          reduce using rule 134 (check_and_or -> empty .)
    RPAR            reduce using rule 134 (check_and_or -> empty .)
    SEMICOL         reduce using rule 134 (check_and_or -> empty .)
    LCURLY          reduce using rule 134 (check_and_or -> empty .)
    TO              reduce using rule 134 (check_and_or -> empty .)


state 78

    (91) sexp -> exp check_relational . sexp_1
    (92) sexp_1 -> . sexp_2 push_relational sexp
    (93) sexp_1 -> . empty
    (94) sexp_2 -> . ISEQUAL
    (95) sexp_2 -> . EQUAL
    (96) sexp_2 -> . NOTEQUAL
    (97) sexp_2 -> . GREATERTHAN
    (98) sexp_2 -> . GREATERORQUAL
    (99) sexp_2 -> . LESSTHAN
    (100) sexp_2 -> . LESSOREQUAL
    (170) empty -> .

    ISEQUAL         shift and go to state 114
    EQUAL           shift and go to state 115
    NOTEQUAL        shift and go to state 116
    GREATERTHAN     shift and go to state 117
    GREATERORQUAL   shift and go to state 118
    LESSTHAN        shift and go to state 119
    LESSOREQUAL     shift and go to state 120
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    sexp_1                         shift and go to state 111
    sexp_2                         shift and go to state 112
    empty                          shift and go to state 113

state 79

    (136) check_relational -> empty .

    ISEQUAL         reduce using rule 136 (check_relational -> empty .)
    EQUAL           reduce using rule 136 (check_relational -> empty .)
    NOTEQUAL        reduce using rule 136 (check_relational -> empty .)
    GREATERTHAN     reduce using rule 136 (check_relational -> empty .)
    GREATERORQUAL   reduce using rule 136 (check_relational -> empty .)
    LESSTHAN        reduce using rule 136 (check_relational -> empty .)
    LESSOREQUAL     reduce using rule 136 (check_relational -> empty .)
    OR              reduce using rule 136 (check_relational -> empty .)
    AND             reduce using rule 136 (check_relational -> empty .)
    COMMA           reduce using rule 136 (check_relational -> empty .)
    RBRACK          reduce using rule 136 (check_relational -> empty .)
    RPAR            reduce using rule 136 (check_relational -> empty .)
    SEMICOL         reduce using rule 136 (check_relational -> empty .)
    LCURLY          reduce using rule 136 (check_relational -> empty .)
    TO              reduce using rule 136 (check_relational -> empty .)


state 80

    (101) exp -> term check_sum . exp_1
    (102) exp_1 -> . exp_2 push_sum exp
    (103) exp_1 -> . empty
    (104) exp_2 -> . PLUS
    (105) exp_2 -> . MINUS
    (170) empty -> .

    PLUS            shift and go to state 124
    MINUS           shift and go to state 125
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    exp_1                          shift and go to state 121
    exp_2                          shift and go to state 122
    empty                          shift and go to state 123

state 81

    (138) check_sum -> empty .

    PLUS            reduce using rule 138 (check_sum -> empty .)
    MINUS           reduce using rule 138 (check_sum -> empty .)
    ISEQUAL         reduce using rule 138 (check_sum -> empty .)
    EQUAL           reduce using rule 138 (check_sum -> empty .)
    NOTEQUAL        reduce using rule 138 (check_sum -> empty .)
    GREATERTHAN     reduce using rule 138 (check_sum -> empty .)
    GREATERORQUAL   reduce using rule 138 (check_sum -> empty .)
    LESSTHAN        reduce using rule 138 (check_sum -> empty .)
    LESSOREQUAL     reduce using rule 138 (check_sum -> empty .)
    OR              reduce using rule 138 (check_sum -> empty .)
    AND             reduce using rule 138 (check_sum -> empty .)
    COMMA           reduce using rule 138 (check_sum -> empty .)
    RBRACK          reduce using rule 138 (check_sum -> empty .)
    RPAR            reduce using rule 138 (check_sum -> empty .)
    SEMICOL         reduce using rule 138 (check_sum -> empty .)
    LCURLY          reduce using rule 138 (check_sum -> empty .)
    TO              reduce using rule 138 (check_sum -> empty .)


state 82

    (106) term -> factor check_mul_div . term_1
    (107) term_1 -> . term_2 push_mul_div term
    (108) term_1 -> . empty
    (109) term_2 -> . TIMES
    (110) term_2 -> . DIV
    (170) empty -> .

    TIMES           shift and go to state 129
    DIV             shift and go to state 130
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    term_1                         shift and go to state 126
    term_2                         shift and go to state 127
    empty                          shift and go to state 128

state 83

    (140) check_mul_div -> empty .

    TIMES           reduce using rule 140 (check_mul_div -> empty .)
    DIV             reduce using rule 140 (check_mul_div -> empty .)
    PLUS            reduce using rule 140 (check_mul_div -> empty .)
    MINUS           reduce using rule 140 (check_mul_div -> empty .)
    ISEQUAL         reduce using rule 140 (check_mul_div -> empty .)
    EQUAL           reduce using rule 140 (check_mul_div -> empty .)
    NOTEQUAL        reduce using rule 140 (check_mul_div -> empty .)
    GREATERTHAN     reduce using rule 140 (check_mul_div -> empty .)
    GREATERORQUAL   reduce using rule 140 (check_mul_div -> empty .)
    LESSTHAN        reduce using rule 140 (check_mul_div -> empty .)
    LESSOREQUAL     reduce using rule 140 (check_mul_div -> empty .)
    OR              reduce using rule 140 (check_mul_div -> empty .)
    AND             reduce using rule 140 (check_mul_div -> empty .)
    COMMA           reduce using rule 140 (check_mul_div -> empty .)
    RBRACK          reduce using rule 140 (check_mul_div -> empty .)
    RPAR            reduce using rule 140 (check_mul_div -> empty .)
    SEMICOL         reduce using rule 140 (check_mul_div -> empty .)
    LCURLY          reduce using rule 140 (check_mul_div -> empty .)
    TO              reduce using rule 140 (check_mul_div -> empty .)


state 84

    (113) factor_1 -> ID see_id . factor_3 push_id print_value reset_dims
    (64) callfunc -> ID see_id . verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (121) factor_3 -> . dims
    (122) factor_3 -> . empty
    (163) verify_func -> . empty
    (39) dims -> . LBRACK expression see_dims dims_1 RBRACK
    (170) empty -> .

    LBRACK          shift and go to state 45
    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    factor_3                       shift and go to state 131
    verify_func                    shift and go to state 132
    dims                           shift and go to state 133
    empty                          shift and go to state 134

state 85

    (115) factor_1 -> CTEI push_int .

    TIMES           reduce using rule 115 (factor_1 -> CTEI push_int .)
    DIV             reduce using rule 115 (factor_1 -> CTEI push_int .)
    PLUS            reduce using rule 115 (factor_1 -> CTEI push_int .)
    MINUS           reduce using rule 115 (factor_1 -> CTEI push_int .)
    ISEQUAL         reduce using rule 115 (factor_1 -> CTEI push_int .)
    EQUAL           reduce using rule 115 (factor_1 -> CTEI push_int .)
    NOTEQUAL        reduce using rule 115 (factor_1 -> CTEI push_int .)
    GREATERTHAN     reduce using rule 115 (factor_1 -> CTEI push_int .)
    GREATERORQUAL   reduce using rule 115 (factor_1 -> CTEI push_int .)
    LESSTHAN        reduce using rule 115 (factor_1 -> CTEI push_int .)
    LESSOREQUAL     reduce using rule 115 (factor_1 -> CTEI push_int .)
    OR              reduce using rule 115 (factor_1 -> CTEI push_int .)
    AND             reduce using rule 115 (factor_1 -> CTEI push_int .)
    COMMA           reduce using rule 115 (factor_1 -> CTEI push_int .)
    RBRACK          reduce using rule 115 (factor_1 -> CTEI push_int .)
    RPAR            reduce using rule 115 (factor_1 -> CTEI push_int .)
    SEMICOL         reduce using rule 115 (factor_1 -> CTEI push_int .)
    LCURLY          reduce using rule 115 (factor_1 -> CTEI push_int .)
    TO              reduce using rule 115 (factor_1 -> CTEI push_int .)


state 86

    (144) push_int -> empty .

    TIMES           reduce using rule 144 (push_int -> empty .)
    DIV             reduce using rule 144 (push_int -> empty .)
    PLUS            reduce using rule 144 (push_int -> empty .)
    MINUS           reduce using rule 144 (push_int -> empty .)
    ISEQUAL         reduce using rule 144 (push_int -> empty .)
    EQUAL           reduce using rule 144 (push_int -> empty .)
    NOTEQUAL        reduce using rule 144 (push_int -> empty .)
    GREATERTHAN     reduce using rule 144 (push_int -> empty .)
    GREATERORQUAL   reduce using rule 144 (push_int -> empty .)
    LESSTHAN        reduce using rule 144 (push_int -> empty .)
    LESSOREQUAL     reduce using rule 144 (push_int -> empty .)
    OR              reduce using rule 144 (push_int -> empty .)
    AND             reduce using rule 144 (push_int -> empty .)
    COMMA           reduce using rule 144 (push_int -> empty .)
    RBRACK          reduce using rule 144 (push_int -> empty .)
    RPAR            reduce using rule 144 (push_int -> empty .)
    SEMICOL         reduce using rule 144 (push_int -> empty .)
    LCURLY          reduce using rule 144 (push_int -> empty .)
    TO              reduce using rule 144 (push_int -> empty .)


state 87

    (116) factor_1 -> CTEF push_float .

    TIMES           reduce using rule 116 (factor_1 -> CTEF push_float .)
    DIV             reduce using rule 116 (factor_1 -> CTEF push_float .)
    PLUS            reduce using rule 116 (factor_1 -> CTEF push_float .)
    MINUS           reduce using rule 116 (factor_1 -> CTEF push_float .)
    ISEQUAL         reduce using rule 116 (factor_1 -> CTEF push_float .)
    EQUAL           reduce using rule 116 (factor_1 -> CTEF push_float .)
    NOTEQUAL        reduce using rule 116 (factor_1 -> CTEF push_float .)
    GREATERTHAN     reduce using rule 116 (factor_1 -> CTEF push_float .)
    GREATERORQUAL   reduce using rule 116 (factor_1 -> CTEF push_float .)
    LESSTHAN        reduce using rule 116 (factor_1 -> CTEF push_float .)
    LESSOREQUAL     reduce using rule 116 (factor_1 -> CTEF push_float .)
    OR              reduce using rule 116 (factor_1 -> CTEF push_float .)
    AND             reduce using rule 116 (factor_1 -> CTEF push_float .)
    COMMA           reduce using rule 116 (factor_1 -> CTEF push_float .)
    RBRACK          reduce using rule 116 (factor_1 -> CTEF push_float .)
    RPAR            reduce using rule 116 (factor_1 -> CTEF push_float .)
    SEMICOL         reduce using rule 116 (factor_1 -> CTEF push_float .)
    LCURLY          reduce using rule 116 (factor_1 -> CTEF push_float .)
    TO              reduce using rule 116 (factor_1 -> CTEF push_float .)


state 88

    (145) push_float -> empty .

    TIMES           reduce using rule 145 (push_float -> empty .)
    DIV             reduce using rule 145 (push_float -> empty .)
    PLUS            reduce using rule 145 (push_float -> empty .)
    MINUS           reduce using rule 145 (push_float -> empty .)
    ISEQUAL         reduce using rule 145 (push_float -> empty .)
    EQUAL           reduce using rule 145 (push_float -> empty .)
    NOTEQUAL        reduce using rule 145 (push_float -> empty .)
    GREATERTHAN     reduce using rule 145 (push_float -> empty .)
    GREATERORQUAL   reduce using rule 145 (push_float -> empty .)
    LESSTHAN        reduce using rule 145 (push_float -> empty .)
    LESSOREQUAL     reduce using rule 145 (push_float -> empty .)
    OR              reduce using rule 145 (push_float -> empty .)
    AND             reduce using rule 145 (push_float -> empty .)
    COMMA           reduce using rule 145 (push_float -> empty .)
    RBRACK          reduce using rule 145 (push_float -> empty .)
    RPAR            reduce using rule 145 (push_float -> empty .)
    SEMICOL         reduce using rule 145 (push_float -> empty .)
    LCURLY          reduce using rule 145 (push_float -> empty .)
    TO              reduce using rule 145 (push_float -> empty .)


state 89

    (117) factor_1 -> CTEB push_bool .

    TIMES           reduce using rule 117 (factor_1 -> CTEB push_bool .)
    DIV             reduce using rule 117 (factor_1 -> CTEB push_bool .)
    PLUS            reduce using rule 117 (factor_1 -> CTEB push_bool .)
    MINUS           reduce using rule 117 (factor_1 -> CTEB push_bool .)
    ISEQUAL         reduce using rule 117 (factor_1 -> CTEB push_bool .)
    EQUAL           reduce using rule 117 (factor_1 -> CTEB push_bool .)
    NOTEQUAL        reduce using rule 117 (factor_1 -> CTEB push_bool .)
    GREATERTHAN     reduce using rule 117 (factor_1 -> CTEB push_bool .)
    GREATERORQUAL   reduce using rule 117 (factor_1 -> CTEB push_bool .)
    LESSTHAN        reduce using rule 117 (factor_1 -> CTEB push_bool .)
    LESSOREQUAL     reduce using rule 117 (factor_1 -> CTEB push_bool .)
    OR              reduce using rule 117 (factor_1 -> CTEB push_bool .)
    AND             reduce using rule 117 (factor_1 -> CTEB push_bool .)
    COMMA           reduce using rule 117 (factor_1 -> CTEB push_bool .)
    RBRACK          reduce using rule 117 (factor_1 -> CTEB push_bool .)
    RPAR            reduce using rule 117 (factor_1 -> CTEB push_bool .)
    SEMICOL         reduce using rule 117 (factor_1 -> CTEB push_bool .)
    LCURLY          reduce using rule 117 (factor_1 -> CTEB push_bool .)
    TO              reduce using rule 117 (factor_1 -> CTEB push_bool .)


state 90

    (146) push_bool -> empty .

    TIMES           reduce using rule 146 (push_bool -> empty .)
    DIV             reduce using rule 146 (push_bool -> empty .)
    PLUS            reduce using rule 146 (push_bool -> empty .)
    MINUS           reduce using rule 146 (push_bool -> empty .)
    ISEQUAL         reduce using rule 146 (push_bool -> empty .)
    EQUAL           reduce using rule 146 (push_bool -> empty .)
    NOTEQUAL        reduce using rule 146 (push_bool -> empty .)
    GREATERTHAN     reduce using rule 146 (push_bool -> empty .)
    GREATERORQUAL   reduce using rule 146 (push_bool -> empty .)
    LESSTHAN        reduce using rule 146 (push_bool -> empty .)
    LESSOREQUAL     reduce using rule 146 (push_bool -> empty .)
    OR              reduce using rule 146 (push_bool -> empty .)
    AND             reduce using rule 146 (push_bool -> empty .)
    COMMA           reduce using rule 146 (push_bool -> empty .)
    RBRACK          reduce using rule 146 (push_bool -> empty .)
    RPAR            reduce using rule 146 (push_bool -> empty .)
    SEMICOL         reduce using rule 146 (push_bool -> empty .)
    LCURLY          reduce using rule 146 (push_bool -> empty .)
    TO              reduce using rule 146 (push_bool -> empty .)


state 91

    (118) factor_1 -> CTEC push_char .

    TIMES           reduce using rule 118 (factor_1 -> CTEC push_char .)
    DIV             reduce using rule 118 (factor_1 -> CTEC push_char .)
    PLUS            reduce using rule 118 (factor_1 -> CTEC push_char .)
    MINUS           reduce using rule 118 (factor_1 -> CTEC push_char .)
    ISEQUAL         reduce using rule 118 (factor_1 -> CTEC push_char .)
    EQUAL           reduce using rule 118 (factor_1 -> CTEC push_char .)
    NOTEQUAL        reduce using rule 118 (factor_1 -> CTEC push_char .)
    GREATERTHAN     reduce using rule 118 (factor_1 -> CTEC push_char .)
    GREATERORQUAL   reduce using rule 118 (factor_1 -> CTEC push_char .)
    LESSTHAN        reduce using rule 118 (factor_1 -> CTEC push_char .)
    LESSOREQUAL     reduce using rule 118 (factor_1 -> CTEC push_char .)
    OR              reduce using rule 118 (factor_1 -> CTEC push_char .)
    AND             reduce using rule 118 (factor_1 -> CTEC push_char .)
    COMMA           reduce using rule 118 (factor_1 -> CTEC push_char .)
    RBRACK          reduce using rule 118 (factor_1 -> CTEC push_char .)
    RPAR            reduce using rule 118 (factor_1 -> CTEC push_char .)
    SEMICOL         reduce using rule 118 (factor_1 -> CTEC push_char .)
    LCURLY          reduce using rule 118 (factor_1 -> CTEC push_char .)
    TO              reduce using rule 118 (factor_1 -> CTEC push_char .)


state 92

    (147) push_char -> empty .

    TIMES           reduce using rule 147 (push_char -> empty .)
    DIV             reduce using rule 147 (push_char -> empty .)
    PLUS            reduce using rule 147 (push_char -> empty .)
    MINUS           reduce using rule 147 (push_char -> empty .)
    ISEQUAL         reduce using rule 147 (push_char -> empty .)
    EQUAL           reduce using rule 147 (push_char -> empty .)
    NOTEQUAL        reduce using rule 147 (push_char -> empty .)
    GREATERTHAN     reduce using rule 147 (push_char -> empty .)
    GREATERORQUAL   reduce using rule 147 (push_char -> empty .)
    LESSTHAN        reduce using rule 147 (push_char -> empty .)
    LESSOREQUAL     reduce using rule 147 (push_char -> empty .)
    OR              reduce using rule 147 (push_char -> empty .)
    AND             reduce using rule 147 (push_char -> empty .)
    COMMA           reduce using rule 147 (push_char -> empty .)
    RBRACK          reduce using rule 147 (push_char -> empty .)
    RPAR            reduce using rule 147 (push_char -> empty .)
    SEMICOL         reduce using rule 147 (push_char -> empty .)
    LCURLY          reduce using rule 147 (push_char -> empty .)
    TO              reduce using rule 147 (push_char -> empty .)


state 93

    (119) factor_1 -> MINUS factor_1 .

    TIMES           reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    DIV             reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    PLUS            reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    MINUS           reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    ISEQUAL         reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    EQUAL           reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    NOTEQUAL        reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    GREATERTHAN     reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    GREATERORQUAL   reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    LESSTHAN        reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    LESSOREQUAL     reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    OR              reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    AND             reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    COMMA           reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    RBRACK          reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    RPAR            reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    SEMICOL         reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    LCURLY          reduce using rule 119 (factor_1 -> MINUS factor_1 .)
    TO              reduce using rule 119 (factor_1 -> MINUS factor_1 .)


state 94

    (120) factor_2 -> LPAR add_ff . expression RPAR pop_ff
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 135
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 95

    (142) add_ff -> empty .

    ID              reduce using rule 142 (add_ff -> empty .)
    CTEI            reduce using rule 142 (add_ff -> empty .)
    CTEF            reduce using rule 142 (add_ff -> empty .)
    CTEB            reduce using rule 142 (add_ff -> empty .)
    CTEC            reduce using rule 142 (add_ff -> empty .)
    MINUS           reduce using rule 142 (add_ff -> empty .)
    LPAR            reduce using rule 142 (add_ff -> empty .)


state 96

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 . set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (130) set_func_init -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    set_func_init                  shift and go to state 136
    empty                          shift and go to state 137

state 97

    (124) main_1 -> vars .

    ID              reduce using rule 124 (main_1 -> vars .)
    IF              reduce using rule 124 (main_1 -> vars .)
    WHILE           reduce using rule 124 (main_1 -> vars .)
    FROM            reduce using rule 124 (main_1 -> vars .)
    READ            reduce using rule 124 (main_1 -> vars .)
    WRITE           reduce using rule 124 (main_1 -> vars .)
    LOADFILE        reduce using rule 124 (main_1 -> vars .)
    END             reduce using rule 124 (main_1 -> vars .)


state 98

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 . set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (130) set_func_init -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)

    set_func_init                  shift and go to state 138
    empty                          shift and go to state 137

state 99

    (24) funcs_1 -> vars .

    ID              reduce using rule 24 (funcs_1 -> vars .)
    IF              reduce using rule 24 (funcs_1 -> vars .)
    WHILE           reduce using rule 24 (funcs_1 -> vars .)
    FROM            reduce using rule 24 (funcs_1 -> vars .)
    READ            reduce using rule 24 (funcs_1 -> vars .)
    WRITE           reduce using rule 24 (funcs_1 -> vars .)
    LOADFILE        reduce using rule 24 (funcs_1 -> vars .)
    RETURN          reduce using rule 24 (funcs_1 -> vars .)
    RCURLY          reduce using rule 24 (funcs_1 -> vars .)


state 100

    (29) params -> LPAR params_1 RPAR .

    LCURLY          reduce using rule 29 (params -> LPAR params_1 RPAR .)


state 101

    (30) params_1 -> type ID . see_id params_2 see_end_param reset_dims params_3
    (125) see_id -> . empty
    (170) empty -> .

    LBRACK          reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 139
    empty                          shift and go to state 30

state 102

    (10) vars_3 -> COMMA vars_1 .

    SEMICOL         reduce using rule 10 (vars_3 -> COMMA vars_1 .)


state 103

    (39) dims -> LBRACK expression see_dims dims_1 . RBRACK

    RBRACK          shift and go to state 140


state 104

    (40) dims_1 -> COMMA . expression see_dims
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 141
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 105

    (41) dims_1 -> empty .

    RBRACK          reduce using rule 41 (dims_1 -> empty .)


state 106

    (86) expression -> sexp check_and_or expression_1 .

    COMMA           reduce using rule 86 (expression -> sexp check_and_or expression_1 .)
    RBRACK          reduce using rule 86 (expression -> sexp check_and_or expression_1 .)
    RPAR            reduce using rule 86 (expression -> sexp check_and_or expression_1 .)
    SEMICOL         reduce using rule 86 (expression -> sexp check_and_or expression_1 .)
    LCURLY          reduce using rule 86 (expression -> sexp check_and_or expression_1 .)
    TO              reduce using rule 86 (expression -> sexp check_and_or expression_1 .)


state 107

    (87) expression_1 -> expression_2 . push_and_or expression
    (135) push_and_or -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    push_and_or                    shift and go to state 142
    empty                          shift and go to state 143

state 108

    (88) expression_1 -> empty .

    COMMA           reduce using rule 88 (expression_1 -> empty .)
    RBRACK          reduce using rule 88 (expression_1 -> empty .)
    RPAR            reduce using rule 88 (expression_1 -> empty .)
    SEMICOL         reduce using rule 88 (expression_1 -> empty .)
    LCURLY          reduce using rule 88 (expression_1 -> empty .)
    TO              reduce using rule 88 (expression_1 -> empty .)


state 109

    (89) expression_2 -> OR .

    ID              reduce using rule 89 (expression_2 -> OR .)
    CTEI            reduce using rule 89 (expression_2 -> OR .)
    CTEF            reduce using rule 89 (expression_2 -> OR .)
    CTEB            reduce using rule 89 (expression_2 -> OR .)
    CTEC            reduce using rule 89 (expression_2 -> OR .)
    MINUS           reduce using rule 89 (expression_2 -> OR .)
    LPAR            reduce using rule 89 (expression_2 -> OR .)


state 110

    (90) expression_2 -> AND .

    ID              reduce using rule 90 (expression_2 -> AND .)
    CTEI            reduce using rule 90 (expression_2 -> AND .)
    CTEF            reduce using rule 90 (expression_2 -> AND .)
    CTEB            reduce using rule 90 (expression_2 -> AND .)
    CTEC            reduce using rule 90 (expression_2 -> AND .)
    MINUS           reduce using rule 90 (expression_2 -> AND .)
    LPAR            reduce using rule 90 (expression_2 -> AND .)


state 111

    (91) sexp -> exp check_relational sexp_1 .

    OR              reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    AND             reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    COMMA           reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    RBRACK          reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    RPAR            reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    SEMICOL         reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    LCURLY          reduce using rule 91 (sexp -> exp check_relational sexp_1 .)
    TO              reduce using rule 91 (sexp -> exp check_relational sexp_1 .)


state 112

    (92) sexp_1 -> sexp_2 . push_relational sexp
    (137) push_relational -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    push_relational                shift and go to state 144
    empty                          shift and go to state 145

state 113

    (93) sexp_1 -> empty .

    OR              reduce using rule 93 (sexp_1 -> empty .)
    AND             reduce using rule 93 (sexp_1 -> empty .)
    COMMA           reduce using rule 93 (sexp_1 -> empty .)
    RBRACK          reduce using rule 93 (sexp_1 -> empty .)
    RPAR            reduce using rule 93 (sexp_1 -> empty .)
    SEMICOL         reduce using rule 93 (sexp_1 -> empty .)
    LCURLY          reduce using rule 93 (sexp_1 -> empty .)
    TO              reduce using rule 93 (sexp_1 -> empty .)


state 114

    (94) sexp_2 -> ISEQUAL .

    ID              reduce using rule 94 (sexp_2 -> ISEQUAL .)
    CTEI            reduce using rule 94 (sexp_2 -> ISEQUAL .)
    CTEF            reduce using rule 94 (sexp_2 -> ISEQUAL .)
    CTEB            reduce using rule 94 (sexp_2 -> ISEQUAL .)
    CTEC            reduce using rule 94 (sexp_2 -> ISEQUAL .)
    MINUS           reduce using rule 94 (sexp_2 -> ISEQUAL .)
    LPAR            reduce using rule 94 (sexp_2 -> ISEQUAL .)


state 115

    (95) sexp_2 -> EQUAL .

    ID              reduce using rule 95 (sexp_2 -> EQUAL .)
    CTEI            reduce using rule 95 (sexp_2 -> EQUAL .)
    CTEF            reduce using rule 95 (sexp_2 -> EQUAL .)
    CTEB            reduce using rule 95 (sexp_2 -> EQUAL .)
    CTEC            reduce using rule 95 (sexp_2 -> EQUAL .)
    MINUS           reduce using rule 95 (sexp_2 -> EQUAL .)
    LPAR            reduce using rule 95 (sexp_2 -> EQUAL .)


state 116

    (96) sexp_2 -> NOTEQUAL .

    ID              reduce using rule 96 (sexp_2 -> NOTEQUAL .)
    CTEI            reduce using rule 96 (sexp_2 -> NOTEQUAL .)
    CTEF            reduce using rule 96 (sexp_2 -> NOTEQUAL .)
    CTEB            reduce using rule 96 (sexp_2 -> NOTEQUAL .)
    CTEC            reduce using rule 96 (sexp_2 -> NOTEQUAL .)
    MINUS           reduce using rule 96 (sexp_2 -> NOTEQUAL .)
    LPAR            reduce using rule 96 (sexp_2 -> NOTEQUAL .)


state 117

    (97) sexp_2 -> GREATERTHAN .

    ID              reduce using rule 97 (sexp_2 -> GREATERTHAN .)
    CTEI            reduce using rule 97 (sexp_2 -> GREATERTHAN .)
    CTEF            reduce using rule 97 (sexp_2 -> GREATERTHAN .)
    CTEB            reduce using rule 97 (sexp_2 -> GREATERTHAN .)
    CTEC            reduce using rule 97 (sexp_2 -> GREATERTHAN .)
    MINUS           reduce using rule 97 (sexp_2 -> GREATERTHAN .)
    LPAR            reduce using rule 97 (sexp_2 -> GREATERTHAN .)


state 118

    (98) sexp_2 -> GREATERORQUAL .

    ID              reduce using rule 98 (sexp_2 -> GREATERORQUAL .)
    CTEI            reduce using rule 98 (sexp_2 -> GREATERORQUAL .)
    CTEF            reduce using rule 98 (sexp_2 -> GREATERORQUAL .)
    CTEB            reduce using rule 98 (sexp_2 -> GREATERORQUAL .)
    CTEC            reduce using rule 98 (sexp_2 -> GREATERORQUAL .)
    MINUS           reduce using rule 98 (sexp_2 -> GREATERORQUAL .)
    LPAR            reduce using rule 98 (sexp_2 -> GREATERORQUAL .)


state 119

    (99) sexp_2 -> LESSTHAN .

    ID              reduce using rule 99 (sexp_2 -> LESSTHAN .)
    CTEI            reduce using rule 99 (sexp_2 -> LESSTHAN .)
    CTEF            reduce using rule 99 (sexp_2 -> LESSTHAN .)
    CTEB            reduce using rule 99 (sexp_2 -> LESSTHAN .)
    CTEC            reduce using rule 99 (sexp_2 -> LESSTHAN .)
    MINUS           reduce using rule 99 (sexp_2 -> LESSTHAN .)
    LPAR            reduce using rule 99 (sexp_2 -> LESSTHAN .)


state 120

    (100) sexp_2 -> LESSOREQUAL .

    ID              reduce using rule 100 (sexp_2 -> LESSOREQUAL .)
    CTEI            reduce using rule 100 (sexp_2 -> LESSOREQUAL .)
    CTEF            reduce using rule 100 (sexp_2 -> LESSOREQUAL .)
    CTEB            reduce using rule 100 (sexp_2 -> LESSOREQUAL .)
    CTEC            reduce using rule 100 (sexp_2 -> LESSOREQUAL .)
    MINUS           reduce using rule 100 (sexp_2 -> LESSOREQUAL .)
    LPAR            reduce using rule 100 (sexp_2 -> LESSOREQUAL .)


state 121

    (101) exp -> term check_sum exp_1 .

    ISEQUAL         reduce using rule 101 (exp -> term check_sum exp_1 .)
    EQUAL           reduce using rule 101 (exp -> term check_sum exp_1 .)
    NOTEQUAL        reduce using rule 101 (exp -> term check_sum exp_1 .)
    GREATERTHAN     reduce using rule 101 (exp -> term check_sum exp_1 .)
    GREATERORQUAL   reduce using rule 101 (exp -> term check_sum exp_1 .)
    LESSTHAN        reduce using rule 101 (exp -> term check_sum exp_1 .)
    LESSOREQUAL     reduce using rule 101 (exp -> term check_sum exp_1 .)
    OR              reduce using rule 101 (exp -> term check_sum exp_1 .)
    AND             reduce using rule 101 (exp -> term check_sum exp_1 .)
    COMMA           reduce using rule 101 (exp -> term check_sum exp_1 .)
    RBRACK          reduce using rule 101 (exp -> term check_sum exp_1 .)
    RPAR            reduce using rule 101 (exp -> term check_sum exp_1 .)
    SEMICOL         reduce using rule 101 (exp -> term check_sum exp_1 .)
    LCURLY          reduce using rule 101 (exp -> term check_sum exp_1 .)
    TO              reduce using rule 101 (exp -> term check_sum exp_1 .)


state 122

    (102) exp_1 -> exp_2 . push_sum exp
    (139) push_sum -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    push_sum                       shift and go to state 146
    empty                          shift and go to state 147

state 123

    (103) exp_1 -> empty .

    ISEQUAL         reduce using rule 103 (exp_1 -> empty .)
    EQUAL           reduce using rule 103 (exp_1 -> empty .)
    NOTEQUAL        reduce using rule 103 (exp_1 -> empty .)
    GREATERTHAN     reduce using rule 103 (exp_1 -> empty .)
    GREATERORQUAL   reduce using rule 103 (exp_1 -> empty .)
    LESSTHAN        reduce using rule 103 (exp_1 -> empty .)
    LESSOREQUAL     reduce using rule 103 (exp_1 -> empty .)
    OR              reduce using rule 103 (exp_1 -> empty .)
    AND             reduce using rule 103 (exp_1 -> empty .)
    COMMA           reduce using rule 103 (exp_1 -> empty .)
    RBRACK          reduce using rule 103 (exp_1 -> empty .)
    RPAR            reduce using rule 103 (exp_1 -> empty .)
    SEMICOL         reduce using rule 103 (exp_1 -> empty .)
    LCURLY          reduce using rule 103 (exp_1 -> empty .)
    TO              reduce using rule 103 (exp_1 -> empty .)


state 124

    (104) exp_2 -> PLUS .

    ID              reduce using rule 104 (exp_2 -> PLUS .)
    CTEI            reduce using rule 104 (exp_2 -> PLUS .)
    CTEF            reduce using rule 104 (exp_2 -> PLUS .)
    CTEB            reduce using rule 104 (exp_2 -> PLUS .)
    CTEC            reduce using rule 104 (exp_2 -> PLUS .)
    MINUS           reduce using rule 104 (exp_2 -> PLUS .)
    LPAR            reduce using rule 104 (exp_2 -> PLUS .)


state 125

    (105) exp_2 -> MINUS .

    ID              reduce using rule 105 (exp_2 -> MINUS .)
    CTEI            reduce using rule 105 (exp_2 -> MINUS .)
    CTEF            reduce using rule 105 (exp_2 -> MINUS .)
    CTEB            reduce using rule 105 (exp_2 -> MINUS .)
    CTEC            reduce using rule 105 (exp_2 -> MINUS .)
    MINUS           reduce using rule 105 (exp_2 -> MINUS .)
    LPAR            reduce using rule 105 (exp_2 -> MINUS .)


state 126

    (106) term -> factor check_mul_div term_1 .

    PLUS            reduce using rule 106 (term -> factor check_mul_div term_1 .)
    MINUS           reduce using rule 106 (term -> factor check_mul_div term_1 .)
    ISEQUAL         reduce using rule 106 (term -> factor check_mul_div term_1 .)
    EQUAL           reduce using rule 106 (term -> factor check_mul_div term_1 .)
    NOTEQUAL        reduce using rule 106 (term -> factor check_mul_div term_1 .)
    GREATERTHAN     reduce using rule 106 (term -> factor check_mul_div term_1 .)
    GREATERORQUAL   reduce using rule 106 (term -> factor check_mul_div term_1 .)
    LESSTHAN        reduce using rule 106 (term -> factor check_mul_div term_1 .)
    LESSOREQUAL     reduce using rule 106 (term -> factor check_mul_div term_1 .)
    OR              reduce using rule 106 (term -> factor check_mul_div term_1 .)
    AND             reduce using rule 106 (term -> factor check_mul_div term_1 .)
    COMMA           reduce using rule 106 (term -> factor check_mul_div term_1 .)
    RBRACK          reduce using rule 106 (term -> factor check_mul_div term_1 .)
    RPAR            reduce using rule 106 (term -> factor check_mul_div term_1 .)
    SEMICOL         reduce using rule 106 (term -> factor check_mul_div term_1 .)
    LCURLY          reduce using rule 106 (term -> factor check_mul_div term_1 .)
    TO              reduce using rule 106 (term -> factor check_mul_div term_1 .)


state 127

    (107) term_1 -> term_2 . push_mul_div term
    (141) push_mul_div -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    push_mul_div                   shift and go to state 148
    empty                          shift and go to state 149

state 128

    (108) term_1 -> empty .

    PLUS            reduce using rule 108 (term_1 -> empty .)
    MINUS           reduce using rule 108 (term_1 -> empty .)
    ISEQUAL         reduce using rule 108 (term_1 -> empty .)
    EQUAL           reduce using rule 108 (term_1 -> empty .)
    NOTEQUAL        reduce using rule 108 (term_1 -> empty .)
    GREATERTHAN     reduce using rule 108 (term_1 -> empty .)
    GREATERORQUAL   reduce using rule 108 (term_1 -> empty .)
    LESSTHAN        reduce using rule 108 (term_1 -> empty .)
    LESSOREQUAL     reduce using rule 108 (term_1 -> empty .)
    OR              reduce using rule 108 (term_1 -> empty .)
    AND             reduce using rule 108 (term_1 -> empty .)
    COMMA           reduce using rule 108 (term_1 -> empty .)
    RBRACK          reduce using rule 108 (term_1 -> empty .)
    RPAR            reduce using rule 108 (term_1 -> empty .)
    SEMICOL         reduce using rule 108 (term_1 -> empty .)
    LCURLY          reduce using rule 108 (term_1 -> empty .)
    TO              reduce using rule 108 (term_1 -> empty .)


state 129

    (109) term_2 -> TIMES .

    ID              reduce using rule 109 (term_2 -> TIMES .)
    CTEI            reduce using rule 109 (term_2 -> TIMES .)
    CTEF            reduce using rule 109 (term_2 -> TIMES .)
    CTEB            reduce using rule 109 (term_2 -> TIMES .)
    CTEC            reduce using rule 109 (term_2 -> TIMES .)
    MINUS           reduce using rule 109 (term_2 -> TIMES .)
    LPAR            reduce using rule 109 (term_2 -> TIMES .)


state 130

    (110) term_2 -> DIV .

    ID              reduce using rule 110 (term_2 -> DIV .)
    CTEI            reduce using rule 110 (term_2 -> DIV .)
    CTEF            reduce using rule 110 (term_2 -> DIV .)
    CTEB            reduce using rule 110 (term_2 -> DIV .)
    CTEC            reduce using rule 110 (term_2 -> DIV .)
    MINUS           reduce using rule 110 (term_2 -> DIV .)
    LPAR            reduce using rule 110 (term_2 -> DIV .)


state 131

    (113) factor_1 -> ID see_id factor_3 . push_id print_value reset_dims
    (149) push_id -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    push_id                        shift and go to state 150
    empty                          shift and go to state 151

state 132

    (64) callfunc -> ID see_id verify_func . LPAR activate_record callfunc_1 verify_p_num RPAR

    LPAR            shift and go to state 152


state 133

    (121) factor_3 -> dims .

    TIMES           reduce using rule 121 (factor_3 -> dims .)
    DIV             reduce using rule 121 (factor_3 -> dims .)
    PLUS            reduce using rule 121 (factor_3 -> dims .)
    MINUS           reduce using rule 121 (factor_3 -> dims .)
    ISEQUAL         reduce using rule 121 (factor_3 -> dims .)
    EQUAL           reduce using rule 121 (factor_3 -> dims .)
    NOTEQUAL        reduce using rule 121 (factor_3 -> dims .)
    GREATERTHAN     reduce using rule 121 (factor_3 -> dims .)
    GREATERORQUAL   reduce using rule 121 (factor_3 -> dims .)
    LESSTHAN        reduce using rule 121 (factor_3 -> dims .)
    LESSOREQUAL     reduce using rule 121 (factor_3 -> dims .)
    OR              reduce using rule 121 (factor_3 -> dims .)
    AND             reduce using rule 121 (factor_3 -> dims .)
    COMMA           reduce using rule 121 (factor_3 -> dims .)
    RBRACK          reduce using rule 121 (factor_3 -> dims .)
    RPAR            reduce using rule 121 (factor_3 -> dims .)
    SEMICOL         reduce using rule 121 (factor_3 -> dims .)
    LCURLY          reduce using rule 121 (factor_3 -> dims .)
    TO              reduce using rule 121 (factor_3 -> dims .)


state 134

    (122) factor_3 -> empty .
    (163) verify_func -> empty .

    TIMES           reduce using rule 122 (factor_3 -> empty .)
    DIV             reduce using rule 122 (factor_3 -> empty .)
    PLUS            reduce using rule 122 (factor_3 -> empty .)
    MINUS           reduce using rule 122 (factor_3 -> empty .)
    ISEQUAL         reduce using rule 122 (factor_3 -> empty .)
    EQUAL           reduce using rule 122 (factor_3 -> empty .)
    NOTEQUAL        reduce using rule 122 (factor_3 -> empty .)
    GREATERTHAN     reduce using rule 122 (factor_3 -> empty .)
    GREATERORQUAL   reduce using rule 122 (factor_3 -> empty .)
    LESSTHAN        reduce using rule 122 (factor_3 -> empty .)
    LESSOREQUAL     reduce using rule 122 (factor_3 -> empty .)
    OR              reduce using rule 122 (factor_3 -> empty .)
    AND             reduce using rule 122 (factor_3 -> empty .)
    COMMA           reduce using rule 122 (factor_3 -> empty .)
    RBRACK          reduce using rule 122 (factor_3 -> empty .)
    RPAR            reduce using rule 122 (factor_3 -> empty .)
    SEMICOL         reduce using rule 122 (factor_3 -> empty .)
    LCURLY          reduce using rule 122 (factor_3 -> empty .)
    TO              reduce using rule 122 (factor_3 -> empty .)
    LPAR            reduce using rule 163 (verify_func -> empty .)


state 135

    (120) factor_2 -> LPAR add_ff expression . RPAR pop_ff

    RPAR            shift and go to state 153


state 136

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init . fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end
    (169) fill_main_goto -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    fill_main_goto                 shift and go to state 154
    empty                          shift and go to state 155

state 137

    (130) set_func_init -> empty .

    ID              reduce using rule 130 (set_func_init -> empty .)
    IF              reduce using rule 130 (set_func_init -> empty .)
    WHILE           reduce using rule 130 (set_func_init -> empty .)
    FROM            reduce using rule 130 (set_func_init -> empty .)
    READ            reduce using rule 130 (set_func_init -> empty .)
    WRITE           reduce using rule 130 (set_func_init -> empty .)
    LOADFILE        reduce using rule 130 (set_func_init -> empty .)
    END             reduce using rule 130 (set_func_init -> empty .)
    RETURN          reduce using rule 130 (set_func_init -> empty .)
    RCURLY          reduce using rule 130 (set_func_init -> empty .)


state 138

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init . statement funcs_2 see_func_end RCURLY funcs_3
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . read
    (49) statement_1 -> . write
    (50) statement_1 -> . loadfile
    (51) statement_1 -> . callfunc SEMICOL
    (170) empty -> .
    (36) assign -> . ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
    (52) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (58) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (59) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (69) read -> . READ LPAR read_1 RPAR SEMICOL
    (75) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (81) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    ID              shift and go to state 156
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FROM            shift and go to state 170
    READ            shift and go to state 171
    WRITE           shift and go to state 172
    LOADFILE        shift and go to state 173

    statement                      shift and go to state 157
    statement_1                    shift and go to state 158
    empty                          shift and go to state 159
    assign                         shift and go to state 160
    cond                           shift and go to state 161
    cloop                          shift and go to state 162
    nloop                          shift and go to state 163
    read                           shift and go to state 164
    write                          shift and go to state 165
    loadfile                       shift and go to state 166
    callfunc                       shift and go to state 167

state 139

    (30) params_1 -> type ID see_id . params_2 see_end_param reset_dims params_3
    (32) params_2 -> . dims
    (33) params_2 -> . empty
    (39) dims -> . LBRACK expression see_dims dims_1 RBRACK
    (170) empty -> .

    LBRACK          shift and go to state 45
    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    params_2                       shift and go to state 174
    dims                           shift and go to state 175
    empty                          shift and go to state 176

state 140

    (39) dims -> LBRACK expression see_dims dims_1 RBRACK .

    COMMA           reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    SEMICOL         reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    TIMES           reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    DIV             reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    PLUS            reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    MINUS           reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    ISEQUAL         reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    EQUAL           reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    NOTEQUAL        reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    GREATERTHAN     reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    GREATERORQUAL   reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    LESSTHAN        reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    LESSOREQUAL     reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    OR              reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    AND             reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    RBRACK          reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    RPAR            reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    LCURLY          reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)
    TO              reduce using rule 39 (dims -> LBRACK expression see_dims dims_1 RBRACK .)


state 141

    (40) dims_1 -> COMMA expression . see_dims
    (126) see_dims -> . empty
    (170) empty -> .

    RBRACK          reduce using rule 170 (empty -> .)

    see_dims                       shift and go to state 177
    empty                          shift and go to state 75

state 142

    (87) expression_1 -> expression_2 push_and_or . expression
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 178
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 143

    (135) push_and_or -> empty .

    ID              reduce using rule 135 (push_and_or -> empty .)
    CTEI            reduce using rule 135 (push_and_or -> empty .)
    CTEF            reduce using rule 135 (push_and_or -> empty .)
    CTEB            reduce using rule 135 (push_and_or -> empty .)
    CTEC            reduce using rule 135 (push_and_or -> empty .)
    MINUS           reduce using rule 135 (push_and_or -> empty .)
    LPAR            reduce using rule 135 (push_and_or -> empty .)


state 144

    (92) sexp_1 -> sexp_2 push_relational . sexp
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    sexp                           shift and go to state 179
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 145

    (137) push_relational -> empty .

    ID              reduce using rule 137 (push_relational -> empty .)
    CTEI            reduce using rule 137 (push_relational -> empty .)
    CTEF            reduce using rule 137 (push_relational -> empty .)
    CTEB            reduce using rule 137 (push_relational -> empty .)
    CTEC            reduce using rule 137 (push_relational -> empty .)
    MINUS           reduce using rule 137 (push_relational -> empty .)
    LPAR            reduce using rule 137 (push_relational -> empty .)


state 146

    (102) exp_1 -> exp_2 push_sum . exp
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    exp                            shift and go to state 180
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 147

    (139) push_sum -> empty .

    ID              reduce using rule 139 (push_sum -> empty .)
    CTEI            reduce using rule 139 (push_sum -> empty .)
    CTEF            reduce using rule 139 (push_sum -> empty .)
    CTEB            reduce using rule 139 (push_sum -> empty .)
    CTEC            reduce using rule 139 (push_sum -> empty .)
    MINUS           reduce using rule 139 (push_sum -> empty .)
    LPAR            reduce using rule 139 (push_sum -> empty .)


state 148

    (107) term_1 -> term_2 push_mul_div . term
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    term                           shift and go to state 181
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 149

    (141) push_mul_div -> empty .

    ID              reduce using rule 141 (push_mul_div -> empty .)
    CTEI            reduce using rule 141 (push_mul_div -> empty .)
    CTEF            reduce using rule 141 (push_mul_div -> empty .)
    CTEB            reduce using rule 141 (push_mul_div -> empty .)
    CTEC            reduce using rule 141 (push_mul_div -> empty .)
    MINUS           reduce using rule 141 (push_mul_div -> empty .)
    LPAR            reduce using rule 141 (push_mul_div -> empty .)


state 150

    (113) factor_1 -> ID see_id factor_3 push_id . print_value reset_dims
    (133) print_value -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    print_value                    shift and go to state 182
    empty                          shift and go to state 183

state 151

    (149) push_id -> empty .

    TIMES           reduce using rule 149 (push_id -> empty .)
    DIV             reduce using rule 149 (push_id -> empty .)
    PLUS            reduce using rule 149 (push_id -> empty .)
    MINUS           reduce using rule 149 (push_id -> empty .)
    ISEQUAL         reduce using rule 149 (push_id -> empty .)
    EQUAL           reduce using rule 149 (push_id -> empty .)
    NOTEQUAL        reduce using rule 149 (push_id -> empty .)
    GREATERTHAN     reduce using rule 149 (push_id -> empty .)
    GREATERORQUAL   reduce using rule 149 (push_id -> empty .)
    LESSTHAN        reduce using rule 149 (push_id -> empty .)
    LESSOREQUAL     reduce using rule 149 (push_id -> empty .)
    OR              reduce using rule 149 (push_id -> empty .)
    AND             reduce using rule 149 (push_id -> empty .)
    COMMA           reduce using rule 149 (push_id -> empty .)
    RBRACK          reduce using rule 149 (push_id -> empty .)
    RPAR            reduce using rule 149 (push_id -> empty .)
    SEMICOL         reduce using rule 149 (push_id -> empty .)
    LCURLY          reduce using rule 149 (push_id -> empty .)
    TO              reduce using rule 149 (push_id -> empty .)


state 152

    (64) callfunc -> ID see_id verify_func LPAR . activate_record callfunc_1 verify_p_num RPAR
    (164) activate_record -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    activate_record                shift and go to state 184
    empty                          shift and go to state 185

state 153

    (120) factor_2 -> LPAR add_ff expression RPAR . pop_ff
    (143) pop_ff -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    pop_ff                         shift and go to state 186
    empty                          shift and go to state 187

state 154

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto . statement END SEMICOL RCURLY see_func_end generate_end
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . read
    (49) statement_1 -> . write
    (50) statement_1 -> . loadfile
    (51) statement_1 -> . callfunc SEMICOL
    (170) empty -> .
    (36) assign -> . ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
    (52) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (58) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (59) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (69) read -> . READ LPAR read_1 RPAR SEMICOL
    (75) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (81) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    END             reduce using rule 170 (empty -> .)
    ID              shift and go to state 156
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FROM            shift and go to state 170
    READ            shift and go to state 171
    WRITE           shift and go to state 172
    LOADFILE        shift and go to state 173

    statement                      shift and go to state 188
    statement_1                    shift and go to state 158
    empty                          shift and go to state 159
    assign                         shift and go to state 160
    cond                           shift and go to state 161
    cloop                          shift and go to state 162
    nloop                          shift and go to state 163
    read                           shift and go to state 164
    write                          shift and go to state 165
    loadfile                       shift and go to state 166
    callfunc                       shift and go to state 167

state 155

    (169) fill_main_goto -> empty .

    ID              reduce using rule 169 (fill_main_goto -> empty .)
    IF              reduce using rule 169 (fill_main_goto -> empty .)
    WHILE           reduce using rule 169 (fill_main_goto -> empty .)
    FROM            reduce using rule 169 (fill_main_goto -> empty .)
    READ            reduce using rule 169 (fill_main_goto -> empty .)
    WRITE           reduce using rule 169 (fill_main_goto -> empty .)
    LOADFILE        reduce using rule 169 (fill_main_goto -> empty .)
    END             reduce using rule 169 (fill_main_goto -> empty .)


state 156

    (36) assign -> ID . see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
    (64) callfunc -> ID . see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (125) see_id -> . empty
    (170) empty -> .

    LBRACK          reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 189
    empty                          shift and go to state 30

state 157

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement . funcs_2 see_func_end RCURLY funcs_3
    (25) funcs_2 -> . RETURN expression SEMICOL
    (26) funcs_2 -> . empty
    (170) empty -> .

    RETURN          shift and go to state 191
    RCURLY          reduce using rule 170 (empty -> .)

    funcs_2                        shift and go to state 190
    empty                          shift and go to state 192

state 158

    (42) statement -> statement_1 . statement
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . read
    (49) statement_1 -> . write
    (50) statement_1 -> . loadfile
    (51) statement_1 -> . callfunc SEMICOL
    (170) empty -> .
    (36) assign -> . ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
    (52) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (58) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (59) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (69) read -> . READ LPAR read_1 RPAR SEMICOL
    (75) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (81) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)
    ID              shift and go to state 156
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FROM            shift and go to state 170
    READ            shift and go to state 171
    WRITE           shift and go to state 172
    LOADFILE        shift and go to state 173

    statement_1                    shift and go to state 158
    statement                      shift and go to state 193
    empty                          shift and go to state 159
    assign                         shift and go to state 160
    cond                           shift and go to state 161
    cloop                          shift and go to state 162
    nloop                          shift and go to state 163
    read                           shift and go to state 164
    write                          shift and go to state 165
    loadfile                       shift and go to state 166
    callfunc                       shift and go to state 167

state 159

    (43) statement -> empty .

    RETURN          reduce using rule 43 (statement -> empty .)
    RCURLY          reduce using rule 43 (statement -> empty .)
    END             reduce using rule 43 (statement -> empty .)


state 160

    (44) statement_1 -> assign .

    ID              reduce using rule 44 (statement_1 -> assign .)
    IF              reduce using rule 44 (statement_1 -> assign .)
    WHILE           reduce using rule 44 (statement_1 -> assign .)
    FROM            reduce using rule 44 (statement_1 -> assign .)
    READ            reduce using rule 44 (statement_1 -> assign .)
    WRITE           reduce using rule 44 (statement_1 -> assign .)
    LOADFILE        reduce using rule 44 (statement_1 -> assign .)
    RETURN          reduce using rule 44 (statement_1 -> assign .)
    RCURLY          reduce using rule 44 (statement_1 -> assign .)
    END             reduce using rule 44 (statement_1 -> assign .)


state 161

    (45) statement_1 -> cond .

    ID              reduce using rule 45 (statement_1 -> cond .)
    IF              reduce using rule 45 (statement_1 -> cond .)
    WHILE           reduce using rule 45 (statement_1 -> cond .)
    FROM            reduce using rule 45 (statement_1 -> cond .)
    READ            reduce using rule 45 (statement_1 -> cond .)
    WRITE           reduce using rule 45 (statement_1 -> cond .)
    LOADFILE        reduce using rule 45 (statement_1 -> cond .)
    RETURN          reduce using rule 45 (statement_1 -> cond .)
    RCURLY          reduce using rule 45 (statement_1 -> cond .)
    END             reduce using rule 45 (statement_1 -> cond .)


state 162

    (46) statement_1 -> cloop .

    ID              reduce using rule 46 (statement_1 -> cloop .)
    IF              reduce using rule 46 (statement_1 -> cloop .)
    WHILE           reduce using rule 46 (statement_1 -> cloop .)
    FROM            reduce using rule 46 (statement_1 -> cloop .)
    READ            reduce using rule 46 (statement_1 -> cloop .)
    WRITE           reduce using rule 46 (statement_1 -> cloop .)
    LOADFILE        reduce using rule 46 (statement_1 -> cloop .)
    RETURN          reduce using rule 46 (statement_1 -> cloop .)
    RCURLY          reduce using rule 46 (statement_1 -> cloop .)
    END             reduce using rule 46 (statement_1 -> cloop .)


state 163

    (47) statement_1 -> nloop .

    ID              reduce using rule 47 (statement_1 -> nloop .)
    IF              reduce using rule 47 (statement_1 -> nloop .)
    WHILE           reduce using rule 47 (statement_1 -> nloop .)
    FROM            reduce using rule 47 (statement_1 -> nloop .)
    READ            reduce using rule 47 (statement_1 -> nloop .)
    WRITE           reduce using rule 47 (statement_1 -> nloop .)
    LOADFILE        reduce using rule 47 (statement_1 -> nloop .)
    RETURN          reduce using rule 47 (statement_1 -> nloop .)
    RCURLY          reduce using rule 47 (statement_1 -> nloop .)
    END             reduce using rule 47 (statement_1 -> nloop .)


state 164

    (48) statement_1 -> read .

    ID              reduce using rule 48 (statement_1 -> read .)
    IF              reduce using rule 48 (statement_1 -> read .)
    WHILE           reduce using rule 48 (statement_1 -> read .)
    FROM            reduce using rule 48 (statement_1 -> read .)
    READ            reduce using rule 48 (statement_1 -> read .)
    WRITE           reduce using rule 48 (statement_1 -> read .)
    LOADFILE        reduce using rule 48 (statement_1 -> read .)
    RETURN          reduce using rule 48 (statement_1 -> read .)
    RCURLY          reduce using rule 48 (statement_1 -> read .)
    END             reduce using rule 48 (statement_1 -> read .)


state 165

    (49) statement_1 -> write .

    ID              reduce using rule 49 (statement_1 -> write .)
    IF              reduce using rule 49 (statement_1 -> write .)
    WHILE           reduce using rule 49 (statement_1 -> write .)
    FROM            reduce using rule 49 (statement_1 -> write .)
    READ            reduce using rule 49 (statement_1 -> write .)
    WRITE           reduce using rule 49 (statement_1 -> write .)
    LOADFILE        reduce using rule 49 (statement_1 -> write .)
    RETURN          reduce using rule 49 (statement_1 -> write .)
    RCURLY          reduce using rule 49 (statement_1 -> write .)
    END             reduce using rule 49 (statement_1 -> write .)


state 166

    (50) statement_1 -> loadfile .

    ID              reduce using rule 50 (statement_1 -> loadfile .)
    IF              reduce using rule 50 (statement_1 -> loadfile .)
    WHILE           reduce using rule 50 (statement_1 -> loadfile .)
    FROM            reduce using rule 50 (statement_1 -> loadfile .)
    READ            reduce using rule 50 (statement_1 -> loadfile .)
    WRITE           reduce using rule 50 (statement_1 -> loadfile .)
    LOADFILE        reduce using rule 50 (statement_1 -> loadfile .)
    RETURN          reduce using rule 50 (statement_1 -> loadfile .)
    RCURLY          reduce using rule 50 (statement_1 -> loadfile .)
    END             reduce using rule 50 (statement_1 -> loadfile .)


state 167

    (51) statement_1 -> callfunc . SEMICOL

    SEMICOL         shift and go to state 194


state 168

    (52) cond -> IF . LPAR expression RPAR generate_g_if block cond_1 finish_if

    LPAR            shift and go to state 195


state 169

    (58) cloop -> WHILE . cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (157) cloop_push_jump -> . empty
    (170) empty -> .

    LPAR            reduce using rule 170 (empty -> .)

    cloop_push_jump                shift and go to state 196
    empty                          shift and go to state 197

state 170

    (59) nloop -> FROM . ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e

    ID              shift and go to state 198


state 171

    (69) read -> READ . LPAR read_1 RPAR SEMICOL

    LPAR            shift and go to state 199


state 172

    (75) write -> WRITE . LPAR write_1 RPAR SEMICOL

    LPAR            shift and go to state 200


state 173

    (81) loadfile -> LOADFILE . LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    LPAR            shift and go to state 201


state 174

    (30) params_1 -> type ID see_id params_2 . see_end_param reset_dims params_3
    (131) see_end_param -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    see_end_param                  shift and go to state 202
    empty                          shift and go to state 203

state 175

    (32) params_2 -> dims .

    COMMA           reduce using rule 32 (params_2 -> dims .)
    RPAR            reduce using rule 32 (params_2 -> dims .)


state 176

    (33) params_2 -> empty .

    COMMA           reduce using rule 33 (params_2 -> empty .)
    RPAR            reduce using rule 33 (params_2 -> empty .)


state 177

    (40) dims_1 -> COMMA expression see_dims .

    RBRACK          reduce using rule 40 (dims_1 -> COMMA expression see_dims .)


state 178

    (87) expression_1 -> expression_2 push_and_or expression .

    COMMA           reduce using rule 87 (expression_1 -> expression_2 push_and_or expression .)
    RBRACK          reduce using rule 87 (expression_1 -> expression_2 push_and_or expression .)
    RPAR            reduce using rule 87 (expression_1 -> expression_2 push_and_or expression .)
    SEMICOL         reduce using rule 87 (expression_1 -> expression_2 push_and_or expression .)
    LCURLY          reduce using rule 87 (expression_1 -> expression_2 push_and_or expression .)
    TO              reduce using rule 87 (expression_1 -> expression_2 push_and_or expression .)


state 179

    (92) sexp_1 -> sexp_2 push_relational sexp .

    OR              reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    AND             reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    COMMA           reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    RBRACK          reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    RPAR            reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    SEMICOL         reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    LCURLY          reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)
    TO              reduce using rule 92 (sexp_1 -> sexp_2 push_relational sexp .)


state 180

    (102) exp_1 -> exp_2 push_sum exp .

    ISEQUAL         reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    EQUAL           reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    NOTEQUAL        reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    GREATERTHAN     reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    GREATERORQUAL   reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    LESSTHAN        reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    LESSOREQUAL     reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    OR              reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    AND             reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    COMMA           reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    RBRACK          reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    RPAR            reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    SEMICOL         reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    LCURLY          reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)
    TO              reduce using rule 102 (exp_1 -> exp_2 push_sum exp .)


state 181

    (107) term_1 -> term_2 push_mul_div term .

    PLUS            reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    MINUS           reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    ISEQUAL         reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    EQUAL           reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    NOTEQUAL        reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    GREATERTHAN     reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    GREATERORQUAL   reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    LESSTHAN        reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    LESSOREQUAL     reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    OR              reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    AND             reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    COMMA           reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    RBRACK          reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    RPAR            reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    SEMICOL         reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    LCURLY          reduce using rule 107 (term_1 -> term_2 push_mul_div term .)
    TO              reduce using rule 107 (term_1 -> term_2 push_mul_div term .)


state 182

    (113) factor_1 -> ID see_id factor_3 push_id print_value . reset_dims
    (132) reset_dims -> . empty
    (170) empty -> .

    TIMES           reduce using rule 170 (empty -> .)
    DIV             reduce using rule 170 (empty -> .)
    PLUS            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    ISEQUAL         reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)
    NOTEQUAL        reduce using rule 170 (empty -> .)
    GREATERTHAN     reduce using rule 170 (empty -> .)
    GREATERORQUAL   reduce using rule 170 (empty -> .)
    LESSTHAN        reduce using rule 170 (empty -> .)
    LESSOREQUAL     reduce using rule 170 (empty -> .)
    OR              reduce using rule 170 (empty -> .)
    AND             reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RBRACK          reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)
    SEMICOL         reduce using rule 170 (empty -> .)
    LCURLY          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)

    reset_dims                     shift and go to state 204
    empty                          shift and go to state 205

state 183

    (133) print_value -> empty .

    TIMES           reduce using rule 133 (print_value -> empty .)
    DIV             reduce using rule 133 (print_value -> empty .)
    PLUS            reduce using rule 133 (print_value -> empty .)
    MINUS           reduce using rule 133 (print_value -> empty .)
    ISEQUAL         reduce using rule 133 (print_value -> empty .)
    EQUAL           reduce using rule 133 (print_value -> empty .)
    NOTEQUAL        reduce using rule 133 (print_value -> empty .)
    GREATERTHAN     reduce using rule 133 (print_value -> empty .)
    GREATERORQUAL   reduce using rule 133 (print_value -> empty .)
    LESSTHAN        reduce using rule 133 (print_value -> empty .)
    LESSOREQUAL     reduce using rule 133 (print_value -> empty .)
    OR              reduce using rule 133 (print_value -> empty .)
    AND             reduce using rule 133 (print_value -> empty .)
    COMMA           reduce using rule 133 (print_value -> empty .)
    RBRACK          reduce using rule 133 (print_value -> empty .)
    RPAR            reduce using rule 133 (print_value -> empty .)
    SEMICOL         reduce using rule 133 (print_value -> empty .)
    LCURLY          reduce using rule 133 (print_value -> empty .)
    TO              reduce using rule 133 (print_value -> empty .)


state 184

    (64) callfunc -> ID see_id verify_func LPAR activate_record . callfunc_1 verify_p_num RPAR
    (65) callfunc_1 -> . expression verify_params callfunc_3
    (66) callfunc_1 -> . empty
    (86) expression -> . sexp check_and_or expression_1
    (170) empty -> .
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RPAR            reduce using rule 170 (empty -> .)
    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    callfunc_1                     shift and go to state 206
    expression                     shift and go to state 207
    empty                          shift and go to state 208
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 185

    (164) activate_record -> empty .

    ID              reduce using rule 164 (activate_record -> empty .)
    CTEI            reduce using rule 164 (activate_record -> empty .)
    CTEF            reduce using rule 164 (activate_record -> empty .)
    CTEB            reduce using rule 164 (activate_record -> empty .)
    CTEC            reduce using rule 164 (activate_record -> empty .)
    MINUS           reduce using rule 164 (activate_record -> empty .)
    LPAR            reduce using rule 164 (activate_record -> empty .)
    RPAR            reduce using rule 164 (activate_record -> empty .)


state 186

    (120) factor_2 -> LPAR add_ff expression RPAR pop_ff .

    TIMES           reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    DIV             reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    PLUS            reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    MINUS           reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    ISEQUAL         reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    EQUAL           reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    NOTEQUAL        reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    GREATERTHAN     reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    GREATERORQUAL   reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    LESSTHAN        reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    LESSOREQUAL     reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    OR              reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    AND             reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    COMMA           reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    RBRACK          reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    RPAR            reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    SEMICOL         reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    LCURLY          reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)
    TO              reduce using rule 120 (factor_2 -> LPAR add_ff expression RPAR pop_ff .)


state 187

    (143) pop_ff -> empty .

    TIMES           reduce using rule 143 (pop_ff -> empty .)
    DIV             reduce using rule 143 (pop_ff -> empty .)
    PLUS            reduce using rule 143 (pop_ff -> empty .)
    MINUS           reduce using rule 143 (pop_ff -> empty .)
    ISEQUAL         reduce using rule 143 (pop_ff -> empty .)
    EQUAL           reduce using rule 143 (pop_ff -> empty .)
    NOTEQUAL        reduce using rule 143 (pop_ff -> empty .)
    GREATERTHAN     reduce using rule 143 (pop_ff -> empty .)
    GREATERORQUAL   reduce using rule 143 (pop_ff -> empty .)
    LESSTHAN        reduce using rule 143 (pop_ff -> empty .)
    LESSOREQUAL     reduce using rule 143 (pop_ff -> empty .)
    OR              reduce using rule 143 (pop_ff -> empty .)
    AND             reduce using rule 143 (pop_ff -> empty .)
    COMMA           reduce using rule 143 (pop_ff -> empty .)
    RBRACK          reduce using rule 143 (pop_ff -> empty .)
    RPAR            reduce using rule 143 (pop_ff -> empty .)
    SEMICOL         reduce using rule 143 (pop_ff -> empty .)
    LCURLY          reduce using rule 143 (pop_ff -> empty .)
    TO              reduce using rule 143 (pop_ff -> empty .)


state 188

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement . END SEMICOL RCURLY see_func_end generate_end

    END             shift and go to state 209


state 189

    (36) assign -> ID see_id . assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
    (64) callfunc -> ID see_id . verify_func LPAR activate_record callfunc_1 verify_p_num RPAR
    (37) assign_1 -> . dims
    (38) assign_1 -> . empty
    (163) verify_func -> . empty
    (39) dims -> . LBRACK expression see_dims dims_1 RBRACK
    (170) empty -> .

    LBRACK          shift and go to state 45
    EQUAL           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    assign_1                       shift and go to state 210
    verify_func                    shift and go to state 132
    dims                           shift and go to state 211
    empty                          shift and go to state 212

state 190

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 . see_func_end RCURLY funcs_3
    (129) see_func_end -> . empty
    (170) empty -> .

    RCURLY          reduce using rule 170 (empty -> .)

    see_func_end                   shift and go to state 213
    empty                          shift and go to state 214

state 191

    (25) funcs_2 -> RETURN . expression SEMICOL
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 215
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 192

    (26) funcs_2 -> empty .

    RCURLY          reduce using rule 26 (funcs_2 -> empty .)


state 193

    (42) statement -> statement_1 statement .

    RETURN          reduce using rule 42 (statement -> statement_1 statement .)
    RCURLY          reduce using rule 42 (statement -> statement_1 statement .)
    END             reduce using rule 42 (statement -> statement_1 statement .)


state 194

    (51) statement_1 -> callfunc SEMICOL .

    ID              reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    IF              reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    WHILE           reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    FROM            reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    READ            reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    WRITE           reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    LOADFILE        reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    RETURN          reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    RCURLY          reduce using rule 51 (statement_1 -> callfunc SEMICOL .)
    END             reduce using rule 51 (statement_1 -> callfunc SEMICOL .)


state 195

    (52) cond -> IF LPAR . expression RPAR generate_g_if block cond_1 finish_if
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 216
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 196

    (58) cloop -> WHILE cloop_push_jump . LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end

    LPAR            shift and go to state 217


state 197

    (157) cloop_push_jump -> empty .

    LPAR            reduce using rule 157 (cloop_push_jump -> empty .)


state 198

    (59) nloop -> FROM ID . see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (125) see_id -> . empty
    (170) empty -> .

    LBRACK          reduce using rule 170 (empty -> .)
    TO              reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 218
    empty                          shift and go to state 30

state 199

    (69) read -> READ LPAR . read_1 RPAR SEMICOL
    (70) read_1 -> . ID see_id read_2 push_id generate_g_read read_3

    ID              shift and go to state 220

    read_1                         shift and go to state 219

state 200

    (75) write -> WRITE LPAR . write_1 RPAR SEMICOL
    (76) write_1 -> . write_2 generate_g_write write_3
    (77) write_2 -> . expression
    (78) write_2 -> . CTES push_string
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    CTES            shift and go to state 224
    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    write_1                        shift and go to state 221
    write_2                        shift and go to state 222
    expression                     shift and go to state 223
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 201

    (81) loadfile -> LOADFILE LPAR . ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    ID              shift and go to state 225


state 202

    (30) params_1 -> type ID see_id params_2 see_end_param . reset_dims params_3
    (132) reset_dims -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    reset_dims                     shift and go to state 226
    empty                          shift and go to state 205

state 203

    (131) see_end_param -> empty .

    COMMA           reduce using rule 131 (see_end_param -> empty .)
    RPAR            reduce using rule 131 (see_end_param -> empty .)


state 204

    (113) factor_1 -> ID see_id factor_3 push_id print_value reset_dims .

    TIMES           reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    DIV             reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    PLUS            reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    MINUS           reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    ISEQUAL         reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    EQUAL           reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    NOTEQUAL        reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    GREATERTHAN     reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    GREATERORQUAL   reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    LESSTHAN        reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    LESSOREQUAL     reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    OR              reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    AND             reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    COMMA           reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    RBRACK          reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    RPAR            reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    SEMICOL         reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    LCURLY          reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)
    TO              reduce using rule 113 (factor_1 -> ID see_id factor_3 push_id print_value reset_dims .)


state 205

    (132) reset_dims -> empty .

    TIMES           reduce using rule 132 (reset_dims -> empty .)
    DIV             reduce using rule 132 (reset_dims -> empty .)
    PLUS            reduce using rule 132 (reset_dims -> empty .)
    MINUS           reduce using rule 132 (reset_dims -> empty .)
    ISEQUAL         reduce using rule 132 (reset_dims -> empty .)
    EQUAL           reduce using rule 132 (reset_dims -> empty .)
    NOTEQUAL        reduce using rule 132 (reset_dims -> empty .)
    GREATERTHAN     reduce using rule 132 (reset_dims -> empty .)
    GREATERORQUAL   reduce using rule 132 (reset_dims -> empty .)
    LESSTHAN        reduce using rule 132 (reset_dims -> empty .)
    LESSOREQUAL     reduce using rule 132 (reset_dims -> empty .)
    OR              reduce using rule 132 (reset_dims -> empty .)
    AND             reduce using rule 132 (reset_dims -> empty .)
    COMMA           reduce using rule 132 (reset_dims -> empty .)
    RBRACK          reduce using rule 132 (reset_dims -> empty .)
    RPAR            reduce using rule 132 (reset_dims -> empty .)
    SEMICOL         reduce using rule 132 (reset_dims -> empty .)
    LCURLY          reduce using rule 132 (reset_dims -> empty .)
    TO              reduce using rule 132 (reset_dims -> empty .)


state 206

    (64) callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 . verify_p_num RPAR
    (167) verify_p_num -> . empty
    (170) empty -> .

    RPAR            reduce using rule 170 (empty -> .)

    verify_p_num                   shift and go to state 227
    empty                          shift and go to state 228

state 207

    (65) callfunc_1 -> expression . verify_params callfunc_3
    (165) verify_params -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    verify_params                  shift and go to state 229
    empty                          shift and go to state 230

state 208

    (66) callfunc_1 -> empty .

    RPAR            reduce using rule 66 (callfunc_1 -> empty .)


state 209

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END . SEMICOL RCURLY see_func_end generate_end

    SEMICOL         shift and go to state 231


state 210

    (36) assign -> ID see_id assign_1 . push_id EQUAL push_equal expression generate_assign SEMICOL
    (149) push_id -> . empty
    (170) empty -> .

    EQUAL           reduce using rule 170 (empty -> .)

    push_id                        shift and go to state 232
    empty                          shift and go to state 151

state 211

    (37) assign_1 -> dims .

    EQUAL           reduce using rule 37 (assign_1 -> dims .)


state 212

    (38) assign_1 -> empty .
    (163) verify_func -> empty .

    EQUAL           reduce using rule 38 (assign_1 -> empty .)
    LPAR            reduce using rule 163 (verify_func -> empty .)


state 213

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end . RCURLY funcs_3

    RCURLY          shift and go to state 233


state 214

    (129) see_func_end -> empty .

    RCURLY          reduce using rule 129 (see_func_end -> empty .)
    $end            reduce using rule 129 (see_func_end -> empty .)


state 215

    (25) funcs_2 -> RETURN expression . SEMICOL

    SEMICOL         shift and go to state 234


state 216

    (52) cond -> IF LPAR expression . RPAR generate_g_if block cond_1 finish_if

    RPAR            shift and go to state 235


state 217

    (58) cloop -> WHILE cloop_push_jump LPAR . expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 236
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 218

    (59) nloop -> FROM ID see_id . nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (60) nloop_1 -> . dims
    (61) nloop_1 -> . empty
    (39) dims -> . LBRACK expression see_dims dims_1 RBRACK
    (170) empty -> .

    LBRACK          shift and go to state 45
    TO              reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)

    nloop_1                        shift and go to state 237
    dims                           shift and go to state 238
    empty                          shift and go to state 239

state 219

    (69) read -> READ LPAR read_1 . RPAR SEMICOL

    RPAR            shift and go to state 240


state 220

    (70) read_1 -> ID . see_id read_2 push_id generate_g_read read_3
    (125) see_id -> . empty
    (170) empty -> .

    LBRACK          reduce using rule 170 (empty -> .)
    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    see_id                         shift and go to state 241
    empty                          shift and go to state 30

state 221

    (75) write -> WRITE LPAR write_1 . RPAR SEMICOL

    RPAR            shift and go to state 242


state 222

    (76) write_1 -> write_2 . generate_g_write write_3
    (156) generate_g_write -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    generate_g_write               shift and go to state 243
    empty                          shift and go to state 244

state 223

    (77) write_2 -> expression .

    COMMA           reduce using rule 77 (write_2 -> expression .)
    RPAR            reduce using rule 77 (write_2 -> expression .)


state 224

    (78) write_2 -> CTES . push_string
    (148) push_string -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    push_string                    shift and go to state 245
    empty                          shift and go to state 246

state 225

    (81) loadfile -> LOADFILE LPAR ID . COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 247


state 226

    (30) params_1 -> type ID see_id params_2 see_end_param reset_dims . params_3
    (34) params_3 -> . COMMA params_1
    (35) params_3 -> . empty
    (170) empty -> .

    COMMA           shift and go to state 249
    RPAR            reduce using rule 170 (empty -> .)

    params_3                       shift and go to state 248
    empty                          shift and go to state 250

state 227

    (64) callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num . RPAR

    RPAR            shift and go to state 251


state 228

    (167) verify_p_num -> empty .

    RPAR            reduce using rule 167 (verify_p_num -> empty .)


state 229

    (65) callfunc_1 -> expression verify_params . callfunc_3
    (67) callfunc_3 -> . COMMA increase_p_count callfunc_1
    (68) callfunc_3 -> . empty
    (170) empty -> .

    COMMA           shift and go to state 253
    RPAR            reduce using rule 170 (empty -> .)

    callfunc_3                     shift and go to state 252
    empty                          shift and go to state 254

state 230

    (165) verify_params -> empty .

    COMMA           reduce using rule 165 (verify_params -> empty .)
    RPAR            reduce using rule 165 (verify_params -> empty .)


state 231

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL . RCURLY see_func_end generate_end

    RCURLY          shift and go to state 255


state 232

    (36) assign -> ID see_id assign_1 push_id . EQUAL push_equal expression generate_assign SEMICOL

    EQUAL           shift and go to state 256


state 233

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY . funcs_3
    (27) funcs_3 -> . funcs
    (28) funcs_3 -> . empty
    (23) funcs -> . FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3
    (170) empty -> .

    FUNC            shift and go to state 14
    MAIN            reduce using rule 170 (empty -> .)

    funcs_3                        shift and go to state 257
    funcs                          shift and go to state 258
    empty                          shift and go to state 259

state 234

    (25) funcs_2 -> RETURN expression SEMICOL .

    RCURLY          reduce using rule 25 (funcs_2 -> RETURN expression SEMICOL .)


state 235

    (52) cond -> IF LPAR expression RPAR . generate_g_if block cond_1 finish_if
    (152) generate_g_if -> . empty
    (170) empty -> .

    LCURLY          reduce using rule 170 (empty -> .)

    generate_g_if                  shift and go to state 260
    empty                          shift and go to state 261

state 236

    (58) cloop -> WHILE cloop_push_jump LPAR expression . generate_g_cloop_start RPAR block generate_g_cloop_end
    (158) generate_g_cloop_start -> . empty
    (170) empty -> .

    RPAR            reduce using rule 170 (empty -> .)

    generate_g_cloop_start         shift and go to state 262
    empty                          shift and go to state 263

state 237

    (59) nloop -> FROM ID see_id nloop_1 . push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (149) push_id -> . empty
    (170) empty -> .

    TO              reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)

    push_id                        shift and go to state 264
    empty                          shift and go to state 151

state 238

    (60) nloop_1 -> dims .

    TO              reduce using rule 60 (nloop_1 -> dims .)
    EQUAL           reduce using rule 60 (nloop_1 -> dims .)


state 239

    (61) nloop_1 -> empty .

    TO              reduce using rule 61 (nloop_1 -> empty .)
    EQUAL           reduce using rule 61 (nloop_1 -> empty .)


state 240

    (69) read -> READ LPAR read_1 RPAR . SEMICOL

    SEMICOL         shift and go to state 265


state 241

    (70) read_1 -> ID see_id . read_2 push_id generate_g_read read_3
    (71) read_2 -> . dims reset_dims
    (72) read_2 -> . empty
    (39) dims -> . LBRACK expression see_dims dims_1 RBRACK
    (170) empty -> .

    LBRACK          shift and go to state 45
    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    read_2                         shift and go to state 266
    dims                           shift and go to state 267
    empty                          shift and go to state 268

state 242

    (75) write -> WRITE LPAR write_1 RPAR . SEMICOL

    SEMICOL         shift and go to state 269


state 243

    (76) write_1 -> write_2 generate_g_write . write_3
    (79) write_3 -> . COMMA write_1
    (80) write_3 -> . empty
    (170) empty -> .

    COMMA           shift and go to state 271
    RPAR            reduce using rule 170 (empty -> .)

    write_3                        shift and go to state 270
    empty                          shift and go to state 272

state 244

    (156) generate_g_write -> empty .

    COMMA           reduce using rule 156 (generate_g_write -> empty .)
    RPAR            reduce using rule 156 (generate_g_write -> empty .)


state 245

    (78) write_2 -> CTES push_string .

    COMMA           reduce using rule 78 (write_2 -> CTES push_string .)
    RPAR            reduce using rule 78 (write_2 -> CTES push_string .)


state 246

    (148) push_string -> empty .

    COMMA           reduce using rule 148 (push_string -> empty .)
    RPAR            reduce using rule 148 (push_string -> empty .)


state 247

    (81) loadfile -> LOADFILE LPAR ID COMMA . CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    CTES            shift and go to state 273


state 248

    (30) params_1 -> type ID see_id params_2 see_end_param reset_dims params_3 .

    RPAR            reduce using rule 30 (params_1 -> type ID see_id params_2 see_end_param reset_dims params_3 .)


state 249

    (34) params_3 -> COMMA . params_1
    (30) params_1 -> . type ID see_id params_2 see_end_param reset_dims params_3
    (31) params_1 -> . empty
    (12) type -> . INT
    (13) type -> . FLOAT
    (14) type -> . CHAR
    (15) type -> . BOOL
    (170) empty -> .

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19
    RPAR            reduce using rule 170 (empty -> .)

    params_1                       shift and go to state 274
    type                           shift and go to state 69
    empty                          shift and go to state 70

state 250

    (35) params_3 -> empty .

    RPAR            reduce using rule 35 (params_3 -> empty .)


state 251

    (64) callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .

    TIMES           reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    DIV             reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    PLUS            reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    MINUS           reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    ISEQUAL         reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    EQUAL           reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    NOTEQUAL        reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    GREATERTHAN     reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    GREATERORQUAL   reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    LESSTHAN        reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    LESSOREQUAL     reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    OR              reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    AND             reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    COMMA           reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    RBRACK          reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    RPAR            reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    SEMICOL         reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    LCURLY          reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)
    TO              reduce using rule 64 (callfunc -> ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR .)


state 252

    (65) callfunc_1 -> expression verify_params callfunc_3 .

    RPAR            reduce using rule 65 (callfunc_1 -> expression verify_params callfunc_3 .)


state 253

    (67) callfunc_3 -> COMMA . increase_p_count callfunc_1
    (166) increase_p_count -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    increase_p_count               shift and go to state 275
    empty                          shift and go to state 276

state 254

    (68) callfunc_3 -> empty .

    RPAR            reduce using rule 68 (callfunc_3 -> empty .)


state 255

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY . see_func_end generate_end
    (129) see_func_end -> . empty
    (170) empty -> .

    $end            reduce using rule 170 (empty -> .)

    see_func_end                   shift and go to state 277
    empty                          shift and go to state 214

state 256

    (36) assign -> ID see_id assign_1 push_id EQUAL . push_equal expression generate_assign SEMICOL
    (150) push_equal -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    push_equal                     shift and go to state 278
    empty                          shift and go to state 279

state 257

    (23) funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3 .

    MAIN            reduce using rule 23 (funcs -> FUNC rtype ID see_id see_func_start params LCURLY funcs_1 set_func_init statement funcs_2 see_func_end RCURLY funcs_3 .)


state 258

    (27) funcs_3 -> funcs .

    MAIN            reduce using rule 27 (funcs_3 -> funcs .)


state 259

    (28) funcs_3 -> empty .

    MAIN            reduce using rule 28 (funcs_3 -> empty .)


state 260

    (52) cond -> IF LPAR expression RPAR generate_g_if . block cond_1 finish_if
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 281

    block                          shift and go to state 280

state 261

    (152) generate_g_if -> empty .

    LCURLY          reduce using rule 152 (generate_g_if -> empty .)


state 262

    (58) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start . RPAR block generate_g_cloop_end

    RPAR            shift and go to state 282


state 263

    (158) generate_g_cloop_start -> empty .

    RPAR            reduce using rule 158 (generate_g_cloop_start -> empty .)


state 264

    (59) nloop -> FROM ID see_id nloop_1 push_id . nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (62) nloop_2 -> . push_id EQUAL push_equal expression generate_assign
    (63) nloop_2 -> . empty
    (149) push_id -> . empty
    (170) empty -> .

    TO              reduce using rule 170 (empty -> .)
    EQUAL           reduce using rule 170 (empty -> .)

    push_id                        shift and go to state 283
    nloop_2                        shift and go to state 284
    empty                          shift and go to state 285

state 265

    (69) read -> READ LPAR read_1 RPAR SEMICOL .

    ID              reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    IF              reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    WHILE           reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    FROM            reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    READ            reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    WRITE           reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    LOADFILE        reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    RETURN          reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    RCURLY          reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)
    END             reduce using rule 69 (read -> READ LPAR read_1 RPAR SEMICOL .)


state 266

    (70) read_1 -> ID see_id read_2 . push_id generate_g_read read_3
    (149) push_id -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    push_id                        shift and go to state 286
    empty                          shift and go to state 151

state 267

    (71) read_2 -> dims . reset_dims
    (132) reset_dims -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    reset_dims                     shift and go to state 287
    empty                          shift and go to state 205

state 268

    (72) read_2 -> empty .

    COMMA           reduce using rule 72 (read_2 -> empty .)
    RPAR            reduce using rule 72 (read_2 -> empty .)


state 269

    (75) write -> WRITE LPAR write_1 RPAR SEMICOL .

    ID              reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    IF              reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    WHILE           reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    FROM            reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    READ            reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    WRITE           reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    LOADFILE        reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    RETURN          reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    RCURLY          reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)
    END             reduce using rule 75 (write -> WRITE LPAR write_1 RPAR SEMICOL .)


state 270

    (76) write_1 -> write_2 generate_g_write write_3 .

    RPAR            reduce using rule 76 (write_1 -> write_2 generate_g_write write_3 .)


state 271

    (79) write_3 -> COMMA . write_1
    (76) write_1 -> . write_2 generate_g_write write_3
    (77) write_2 -> . expression
    (78) write_2 -> . CTES push_string
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    CTES            shift and go to state 224
    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    write_1                        shift and go to state 288
    write_2                        shift and go to state 222
    expression                     shift and go to state 223
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 272

    (80) write_3 -> empty .

    RPAR            reduce using rule 80 (write_3 -> empty .)


state 273

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES . COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 289


state 274

    (34) params_3 -> COMMA params_1 .

    RPAR            reduce using rule 34 (params_3 -> COMMA params_1 .)


state 275

    (67) callfunc_3 -> COMMA increase_p_count . callfunc_1
    (65) callfunc_1 -> . expression verify_params callfunc_3
    (66) callfunc_1 -> . empty
    (86) expression -> . sexp check_and_or expression_1
    (170) empty -> .
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RPAR            reduce using rule 170 (empty -> .)
    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    callfunc_1                     shift and go to state 290
    expression                     shift and go to state 207
    empty                          shift and go to state 208
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 276

    (166) increase_p_count -> empty .

    ID              reduce using rule 166 (increase_p_count -> empty .)
    CTEI            reduce using rule 166 (increase_p_count -> empty .)
    CTEF            reduce using rule 166 (increase_p_count -> empty .)
    CTEB            reduce using rule 166 (increase_p_count -> empty .)
    CTEC            reduce using rule 166 (increase_p_count -> empty .)
    MINUS           reduce using rule 166 (increase_p_count -> empty .)
    LPAR            reduce using rule 166 (increase_p_count -> empty .)
    RPAR            reduce using rule 166 (increase_p_count -> empty .)


state 277

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end . generate_end
    (162) generate_end -> . empty
    (170) empty -> .

    $end            reduce using rule 170 (empty -> .)

    generate_end                   shift and go to state 291
    empty                          shift and go to state 292

state 278

    (36) assign -> ID see_id assign_1 push_id EQUAL push_equal . expression generate_assign SEMICOL
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 293
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 279

    (150) push_equal -> empty .

    ID              reduce using rule 150 (push_equal -> empty .)
    CTEI            reduce using rule 150 (push_equal -> empty .)
    CTEF            reduce using rule 150 (push_equal -> empty .)
    CTEB            reduce using rule 150 (push_equal -> empty .)
    CTEC            reduce using rule 150 (push_equal -> empty .)
    MINUS           reduce using rule 150 (push_equal -> empty .)
    LPAR            reduce using rule 150 (push_equal -> empty .)


state 280

    (52) cond -> IF LPAR expression RPAR generate_g_if block . cond_1 finish_if
    (53) cond_1 -> . ELSE generate_g_else cond_2

    ELSE            shift and go to state 295

    cond_1                         shift and go to state 294

state 281

    (21) block -> LCURLY . block_1 RCURLY
    (22) block_1 -> . statement
    (42) statement -> . statement_1 statement
    (43) statement -> . empty
    (44) statement_1 -> . assign
    (45) statement_1 -> . cond
    (46) statement_1 -> . cloop
    (47) statement_1 -> . nloop
    (48) statement_1 -> . read
    (49) statement_1 -> . write
    (50) statement_1 -> . loadfile
    (51) statement_1 -> . callfunc SEMICOL
    (170) empty -> .
    (36) assign -> . ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL
    (52) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (58) cloop -> . WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end
    (59) nloop -> . FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e
    (69) read -> . READ LPAR read_1 RPAR SEMICOL
    (75) write -> . WRITE LPAR write_1 RPAR SEMICOL
    (81) loadfile -> . LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    RCURLY          reduce using rule 170 (empty -> .)
    ID              shift and go to state 156
    IF              shift and go to state 168
    WHILE           shift and go to state 169
    FROM            shift and go to state 170
    READ            shift and go to state 171
    WRITE           shift and go to state 172
    LOADFILE        shift and go to state 173

    block_1                        shift and go to state 296
    statement                      shift and go to state 297
    statement_1                    shift and go to state 158
    empty                          shift and go to state 159
    assign                         shift and go to state 160
    cond                           shift and go to state 161
    cloop                          shift and go to state 162
    nloop                          shift and go to state 163
    read                           shift and go to state 164
    write                          shift and go to state 165
    loadfile                       shift and go to state 166
    callfunc                       shift and go to state 167

state 282

    (58) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR . block generate_g_cloop_end
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 281

    block                          shift and go to state 298

state 283

    (62) nloop_2 -> push_id . EQUAL push_equal expression generate_assign

    EQUAL           shift and go to state 299


state 284

    (59) nloop -> FROM ID see_id nloop_1 push_id nloop_2 . TO expression generate_g_nloop_s block generate_g_nloop_e

    TO              shift and go to state 300


state 285

    (63) nloop_2 -> empty .
    (149) push_id -> empty .

    TO              reduce using rule 63 (nloop_2 -> empty .)
    EQUAL           reduce using rule 149 (push_id -> empty .)


state 286

    (70) read_1 -> ID see_id read_2 push_id . generate_g_read read_3
    (155) generate_g_read -> . empty
    (170) empty -> .

    COMMA           reduce using rule 170 (empty -> .)
    RPAR            reduce using rule 170 (empty -> .)

    generate_g_read                shift and go to state 301
    empty                          shift and go to state 302

state 287

    (71) read_2 -> dims reset_dims .

    COMMA           reduce using rule 71 (read_2 -> dims reset_dims .)
    RPAR            reduce using rule 71 (read_2 -> dims reset_dims .)


state 288

    (79) write_3 -> COMMA write_1 .

    RPAR            reduce using rule 79 (write_3 -> COMMA write_1 .)


state 289

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA . loadfile_1 COMMA loadfile_2 RPAR SEMICOL
    (82) loadfile_1 -> . CTEI
    (83) loadfile_1 -> . ID

    CTEI            shift and go to state 305
    ID              shift and go to state 303

    loadfile_1                     shift and go to state 304

state 290

    (67) callfunc_3 -> COMMA increase_p_count callfunc_1 .

    RPAR            reduce using rule 67 (callfunc_3 -> COMMA increase_p_count callfunc_1 .)


state 291

    (123) main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end .

    $end            reduce using rule 123 (main -> MAIN see_id LPAR RPAR LCURLY see_func_start main_1 set_func_init fill_main_goto statement END SEMICOL RCURLY see_func_end generate_end .)


state 292

    (162) generate_end -> empty .

    $end            reduce using rule 162 (generate_end -> empty .)


state 293

    (36) assign -> ID see_id assign_1 push_id EQUAL push_equal expression . generate_assign SEMICOL
    (151) generate_assign -> . empty
    (170) empty -> .

    SEMICOL         reduce using rule 170 (empty -> .)

    generate_assign                shift and go to state 306
    empty                          shift and go to state 307

state 294

    (52) cond -> IF LPAR expression RPAR generate_g_if block cond_1 . finish_if
    (153) finish_if -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    finish_if                      shift and go to state 308
    empty                          shift and go to state 309

state 295

    (53) cond_1 -> ELSE . generate_g_else cond_2
    (154) generate_g_else -> . empty
    (170) empty -> .

    LCURLY          reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    ID              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    generate_g_else                shift and go to state 310
    empty                          shift and go to state 311

state 296

    (21) block -> LCURLY block_1 . RCURLY

    RCURLY          shift and go to state 312


state 297

    (22) block_1 -> statement .

    RCURLY          reduce using rule 22 (block_1 -> statement .)


state 298

    (58) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block . generate_g_cloop_end
    (159) generate_g_cloop_end -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    generate_g_cloop_end           shift and go to state 313
    empty                          shift and go to state 314

state 299

    (62) nloop_2 -> push_id EQUAL . push_equal expression generate_assign
    (150) push_equal -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    CTEI            reduce using rule 170 (empty -> .)
    CTEF            reduce using rule 170 (empty -> .)
    CTEB            reduce using rule 170 (empty -> .)
    CTEC            reduce using rule 170 (empty -> .)
    MINUS           reduce using rule 170 (empty -> .)
    LPAR            reduce using rule 170 (empty -> .)

    push_equal                     shift and go to state 315
    empty                          shift and go to state 279

state 300

    (59) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO . expression generate_g_nloop_s block generate_g_nloop_e
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 316
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 301

    (70) read_1 -> ID see_id read_2 push_id generate_g_read . read_3
    (73) read_3 -> . COMMA read_1
    (74) read_3 -> . empty
    (170) empty -> .

    COMMA           shift and go to state 318
    RPAR            reduce using rule 170 (empty -> .)

    read_3                         shift and go to state 317
    empty                          shift and go to state 319

state 302

    (155) generate_g_read -> empty .

    COMMA           reduce using rule 155 (generate_g_read -> empty .)
    RPAR            reduce using rule 155 (generate_g_read -> empty .)


state 303

    (83) loadfile_1 -> ID .

    COMMA           reduce using rule 83 (loadfile_1 -> ID .)


state 304

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 . COMMA loadfile_2 RPAR SEMICOL

    COMMA           shift and go to state 320


state 305

    (82) loadfile_1 -> CTEI .

    COMMA           reduce using rule 82 (loadfile_1 -> CTEI .)


state 306

    (36) assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign . SEMICOL

    SEMICOL         shift and go to state 321


state 307

    (151) generate_assign -> empty .

    SEMICOL         reduce using rule 151 (generate_assign -> empty .)
    TO              reduce using rule 151 (generate_assign -> empty .)


state 308

    (52) cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .

    ID              reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    IF              reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    WHILE           reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    FROM            reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    READ            reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    WRITE           reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    LOADFILE        reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    RETURN          reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    RCURLY          reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)
    END             reduce using rule 52 (cond -> IF LPAR expression RPAR generate_g_if block cond_1 finish_if .)


state 309

    (153) finish_if -> empty .

    ID              reduce using rule 153 (finish_if -> empty .)
    IF              reduce using rule 153 (finish_if -> empty .)
    WHILE           reduce using rule 153 (finish_if -> empty .)
    FROM            reduce using rule 153 (finish_if -> empty .)
    READ            reduce using rule 153 (finish_if -> empty .)
    WRITE           reduce using rule 153 (finish_if -> empty .)
    LOADFILE        reduce using rule 153 (finish_if -> empty .)
    RETURN          reduce using rule 153 (finish_if -> empty .)
    RCURLY          reduce using rule 153 (finish_if -> empty .)
    END             reduce using rule 153 (finish_if -> empty .)


state 310

    (53) cond_1 -> ELSE generate_g_else . cond_2
    (54) cond_2 -> . cond_3
    (55) cond_2 -> . block
    (56) cond_3 -> . cond
    (57) cond_3 -> . empty
    (21) block -> . LCURLY block_1 RCURLY
    (52) cond -> . IF LPAR expression RPAR generate_g_if block cond_1 finish_if
    (170) empty -> .

  ! shift/reduce conflict for IF resolved as shift
    LCURLY          shift and go to state 281
    IF              shift and go to state 168
    ID              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

  ! IF              [ reduce using rule 170 (empty -> .) ]

    cond_2                         shift and go to state 322
    cond_3                         shift and go to state 323
    block                          shift and go to state 324
    cond                           shift and go to state 325
    empty                          shift and go to state 326

state 311

    (154) generate_g_else -> empty .

    LCURLY          reduce using rule 154 (generate_g_else -> empty .)
    IF              reduce using rule 154 (generate_g_else -> empty .)
    ID              reduce using rule 154 (generate_g_else -> empty .)
    WHILE           reduce using rule 154 (generate_g_else -> empty .)
    FROM            reduce using rule 154 (generate_g_else -> empty .)
    READ            reduce using rule 154 (generate_g_else -> empty .)
    WRITE           reduce using rule 154 (generate_g_else -> empty .)
    LOADFILE        reduce using rule 154 (generate_g_else -> empty .)
    RETURN          reduce using rule 154 (generate_g_else -> empty .)
    RCURLY          reduce using rule 154 (generate_g_else -> empty .)
    END             reduce using rule 154 (generate_g_else -> empty .)


state 312

    (21) block -> LCURLY block_1 RCURLY .

    ELSE            reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    ID              reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    IF              reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    WHILE           reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    FROM            reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    READ            reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    WRITE           reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    LOADFILE        reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    RETURN          reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    RCURLY          reduce using rule 21 (block -> LCURLY block_1 RCURLY .)
    END             reduce using rule 21 (block -> LCURLY block_1 RCURLY .)


state 313

    (58) cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .

    ID              reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    IF              reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    WHILE           reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    FROM            reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    READ            reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    WRITE           reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    LOADFILE        reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    RETURN          reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    RCURLY          reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)
    END             reduce using rule 58 (cloop -> WHILE cloop_push_jump LPAR expression generate_g_cloop_start RPAR block generate_g_cloop_end .)


state 314

    (159) generate_g_cloop_end -> empty .

    ID              reduce using rule 159 (generate_g_cloop_end -> empty .)
    IF              reduce using rule 159 (generate_g_cloop_end -> empty .)
    WHILE           reduce using rule 159 (generate_g_cloop_end -> empty .)
    FROM            reduce using rule 159 (generate_g_cloop_end -> empty .)
    READ            reduce using rule 159 (generate_g_cloop_end -> empty .)
    WRITE           reduce using rule 159 (generate_g_cloop_end -> empty .)
    LOADFILE        reduce using rule 159 (generate_g_cloop_end -> empty .)
    RETURN          reduce using rule 159 (generate_g_cloop_end -> empty .)
    RCURLY          reduce using rule 159 (generate_g_cloop_end -> empty .)
    END             reduce using rule 159 (generate_g_cloop_end -> empty .)


state 315

    (62) nloop_2 -> push_id EQUAL push_equal . expression generate_assign
    (86) expression -> . sexp check_and_or expression_1
    (91) sexp -> . exp check_relational sexp_1
    (101) exp -> . term check_sum exp_1
    (106) term -> . factor check_mul_div term_1
    (111) factor -> . factor_1
    (112) factor -> . factor_2
    (113) factor_1 -> . ID see_id factor_3 push_id print_value reset_dims
    (114) factor_1 -> . callfunc
    (115) factor_1 -> . CTEI push_int
    (116) factor_1 -> . CTEF push_float
    (117) factor_1 -> . CTEB push_bool
    (118) factor_1 -> . CTEC push_char
    (119) factor_1 -> . MINUS factor_1
    (120) factor_2 -> . LPAR add_ff expression RPAR pop_ff
    (64) callfunc -> . ID see_id verify_func LPAR activate_record callfunc_1 verify_p_num RPAR

    ID              shift and go to state 58
    CTEI            shift and go to state 60
    CTEF            shift and go to state 61
    CTEB            shift and go to state 62
    CTEC            shift and go to state 63
    MINUS           shift and go to state 64
    LPAR            shift and go to state 65

    expression                     shift and go to state 327
    sexp                           shift and go to state 52
    exp                            shift and go to state 53
    term                           shift and go to state 54
    factor                         shift and go to state 55
    factor_1                       shift and go to state 56
    factor_2                       shift and go to state 57
    callfunc                       shift and go to state 59

state 316

    (59) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression . generate_g_nloop_s block generate_g_nloop_e
    (160) generate_g_nloop_s -> . empty
    (170) empty -> .

    LCURLY          reduce using rule 170 (empty -> .)

    generate_g_nloop_s             shift and go to state 328
    empty                          shift and go to state 329

state 317

    (70) read_1 -> ID see_id read_2 push_id generate_g_read read_3 .

    RPAR            reduce using rule 70 (read_1 -> ID see_id read_2 push_id generate_g_read read_3 .)


state 318

    (73) read_3 -> COMMA . read_1
    (70) read_1 -> . ID see_id read_2 push_id generate_g_read read_3

    ID              shift and go to state 220

    read_1                         shift and go to state 330

state 319

    (74) read_3 -> empty .

    RPAR            reduce using rule 74 (read_3 -> empty .)


state 320

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA . loadfile_2 RPAR SEMICOL
    (84) loadfile_2 -> . CTEI
    (85) loadfile_2 -> . ID

    CTEI            shift and go to state 333
    ID              shift and go to state 331

    loadfile_2                     shift and go to state 332

state 321

    (36) assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .

    ID              reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    IF              reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    WHILE           reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    FROM            reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    READ            reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    WRITE           reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    LOADFILE        reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    RETURN          reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    RCURLY          reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)
    END             reduce using rule 36 (assign -> ID see_id assign_1 push_id EQUAL push_equal expression generate_assign SEMICOL .)


state 322

    (53) cond_1 -> ELSE generate_g_else cond_2 .

    ID              reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    IF              reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    WHILE           reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    FROM            reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    READ            reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    WRITE           reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    LOADFILE        reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    RETURN          reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    RCURLY          reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)
    END             reduce using rule 53 (cond_1 -> ELSE generate_g_else cond_2 .)


state 323

    (54) cond_2 -> cond_3 .

    ID              reduce using rule 54 (cond_2 -> cond_3 .)
    IF              reduce using rule 54 (cond_2 -> cond_3 .)
    WHILE           reduce using rule 54 (cond_2 -> cond_3 .)
    FROM            reduce using rule 54 (cond_2 -> cond_3 .)
    READ            reduce using rule 54 (cond_2 -> cond_3 .)
    WRITE           reduce using rule 54 (cond_2 -> cond_3 .)
    LOADFILE        reduce using rule 54 (cond_2 -> cond_3 .)
    RETURN          reduce using rule 54 (cond_2 -> cond_3 .)
    RCURLY          reduce using rule 54 (cond_2 -> cond_3 .)
    END             reduce using rule 54 (cond_2 -> cond_3 .)


state 324

    (55) cond_2 -> block .

    ID              reduce using rule 55 (cond_2 -> block .)
    IF              reduce using rule 55 (cond_2 -> block .)
    WHILE           reduce using rule 55 (cond_2 -> block .)
    FROM            reduce using rule 55 (cond_2 -> block .)
    READ            reduce using rule 55 (cond_2 -> block .)
    WRITE           reduce using rule 55 (cond_2 -> block .)
    LOADFILE        reduce using rule 55 (cond_2 -> block .)
    RETURN          reduce using rule 55 (cond_2 -> block .)
    RCURLY          reduce using rule 55 (cond_2 -> block .)
    END             reduce using rule 55 (cond_2 -> block .)


state 325

    (56) cond_3 -> cond .

    ID              reduce using rule 56 (cond_3 -> cond .)
    IF              reduce using rule 56 (cond_3 -> cond .)
    WHILE           reduce using rule 56 (cond_3 -> cond .)
    FROM            reduce using rule 56 (cond_3 -> cond .)
    READ            reduce using rule 56 (cond_3 -> cond .)
    WRITE           reduce using rule 56 (cond_3 -> cond .)
    LOADFILE        reduce using rule 56 (cond_3 -> cond .)
    RETURN          reduce using rule 56 (cond_3 -> cond .)
    RCURLY          reduce using rule 56 (cond_3 -> cond .)
    END             reduce using rule 56 (cond_3 -> cond .)


state 326

    (57) cond_3 -> empty .

    ID              reduce using rule 57 (cond_3 -> empty .)
    IF              reduce using rule 57 (cond_3 -> empty .)
    WHILE           reduce using rule 57 (cond_3 -> empty .)
    FROM            reduce using rule 57 (cond_3 -> empty .)
    READ            reduce using rule 57 (cond_3 -> empty .)
    WRITE           reduce using rule 57 (cond_3 -> empty .)
    LOADFILE        reduce using rule 57 (cond_3 -> empty .)
    RETURN          reduce using rule 57 (cond_3 -> empty .)
    RCURLY          reduce using rule 57 (cond_3 -> empty .)
    END             reduce using rule 57 (cond_3 -> empty .)


state 327

    (62) nloop_2 -> push_id EQUAL push_equal expression . generate_assign
    (151) generate_assign -> . empty
    (170) empty -> .

    TO              reduce using rule 170 (empty -> .)

    generate_assign                shift and go to state 334
    empty                          shift and go to state 307

state 328

    (59) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s . block generate_g_nloop_e
    (21) block -> . LCURLY block_1 RCURLY

    LCURLY          shift and go to state 281

    block                          shift and go to state 335

state 329

    (160) generate_g_nloop_s -> empty .

    LCURLY          reduce using rule 160 (generate_g_nloop_s -> empty .)


state 330

    (73) read_3 -> COMMA read_1 .

    RPAR            reduce using rule 73 (read_3 -> COMMA read_1 .)


state 331

    (85) loadfile_2 -> ID .

    RPAR            reduce using rule 85 (loadfile_2 -> ID .)


state 332

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 . RPAR SEMICOL

    RPAR            shift and go to state 336


state 333

    (84) loadfile_2 -> CTEI .

    RPAR            reduce using rule 84 (loadfile_2 -> CTEI .)


state 334

    (62) nloop_2 -> push_id EQUAL push_equal expression generate_assign .

    TO              reduce using rule 62 (nloop_2 -> push_id EQUAL push_equal expression generate_assign .)


state 335

    (59) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block . generate_g_nloop_e
    (161) generate_g_nloop_e -> . empty
    (170) empty -> .

    ID              reduce using rule 170 (empty -> .)
    IF              reduce using rule 170 (empty -> .)
    WHILE           reduce using rule 170 (empty -> .)
    FROM            reduce using rule 170 (empty -> .)
    READ            reduce using rule 170 (empty -> .)
    WRITE           reduce using rule 170 (empty -> .)
    LOADFILE        reduce using rule 170 (empty -> .)
    RETURN          reduce using rule 170 (empty -> .)
    RCURLY          reduce using rule 170 (empty -> .)
    END             reduce using rule 170 (empty -> .)

    generate_g_nloop_e             shift and go to state 337
    empty                          shift and go to state 338

state 336

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR . SEMICOL

    SEMICOL         shift and go to state 339


state 337

    (59) nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .

    ID              reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    IF              reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    WHILE           reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    FROM            reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    READ            reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    WRITE           reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    LOADFILE        reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    RETURN          reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    RCURLY          reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)
    END             reduce using rule 59 (nloop -> FROM ID see_id nloop_1 push_id nloop_2 TO expression generate_g_nloop_s block generate_g_nloop_e .)


state 338

    (161) generate_g_nloop_e -> empty .

    ID              reduce using rule 161 (generate_g_nloop_e -> empty .)
    IF              reduce using rule 161 (generate_g_nloop_e -> empty .)
    WHILE           reduce using rule 161 (generate_g_nloop_e -> empty .)
    FROM            reduce using rule 161 (generate_g_nloop_e -> empty .)
    READ            reduce using rule 161 (generate_g_nloop_e -> empty .)
    WRITE           reduce using rule 161 (generate_g_nloop_e -> empty .)
    LOADFILE        reduce using rule 161 (generate_g_nloop_e -> empty .)
    RETURN          reduce using rule 161 (generate_g_nloop_e -> empty .)
    RCURLY          reduce using rule 161 (generate_g_nloop_e -> empty .)
    END             reduce using rule 161 (generate_g_nloop_e -> empty .)


state 339

    (81) loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .

    ID              reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    IF              reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    WHILE           reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    FROM            reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    READ            reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    WRITE           reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    LOADFILE        reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    RETURN          reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    RCURLY          reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)
    END             reduce using rule 81 (loadfile -> LOADFILE LPAR ID COMMA CTES COMMA loadfile_1 COMMA loadfile_2 RPAR SEMICOL .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 310 resolved as shift
